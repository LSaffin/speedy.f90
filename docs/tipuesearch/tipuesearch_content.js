var tipuesearch = {"pages":[{"title":" SPEEDY.f90 ","text":"SPEEDY.f90 SPEEDY.f90 is an intermediate complexity atmospheric general circulation model written in modern Fortran. It is based on SPEEDY , developed by Fred Kucharski, Franco Molteni and Martin P. King. Installation SPEEDY.f90 has only one dependency: the NetCDF library. To build SPEEDY.f90: Install the NetCDF library and locate the netcdf.mod file. For example, on my system it is stored in /usr/include . Set the NETCDF environment variable to point to the directory containing netcdf.mod . For example, for my system I run export NETCDF=/usr/include . Run build.sh to build SPEEDY.f90: bash build.sh . A binary directory, bin , will be created an the SPEEDY.f90 executable speedy will be placed in this directory. Run run.sh to run SPEEDY.f90: bash run.sh . The output will be stored in rundir . By default, SPEEDY.f90 will run for two days and output one NetCDF file for each time step Developer Info Sam Hatfield Graduate student in Predictability of Weather and Climate Group, Atmospheric, Oceanic and Planetary Physics, University of Oxford.","tags":"home","loc":"index.html"},{"title":"auxiliaries.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~auxiliaries.f90~~EfferentGraph sourcefile~auxiliaries.f90 auxiliaries.f90 sourcefile~params.f90 params.f90 sourcefile~auxiliaries.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~auxiliaries.f90~~AfferentGraph sourcefile~auxiliaries.f90 auxiliaries.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~land_model.f90->sourcefile~auxiliaries.f90 sourcefile~physics.f90 physics.f90 sourcefile~physics.f90->sourcefile~auxiliaries.f90 sourcefile~physics.f90->sourcefile~land_model.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~physics.f90->sourcefile~sea_model.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~sea_model.f90->sourcefile~auxiliaries.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 sourcefile~coupler.f90 coupler.f90 sourcefile~coupler.f90->sourcefile~land_model.f90 sourcefile~coupler.f90->sourcefile~sea_model.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~forcing.f90->sourcefile~land_model.f90 sourcefile~forcing.f90->sourcefile~sea_model.f90 sourcefile~forcing.f90->sourcefile~surface_fluxes.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~initialization.f90->sourcefile~sea_model.f90 sourcefile~initialization.f90->sourcefile~coupler.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~coupler.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 var pansourcefileauxiliariesf90AfferentGraph = svgPanZoom('#sourcefileauxiliariesf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules auxiliaries Source Code auxiliaries.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !  date: 29/04/2019 !  For storing variables used by multiple physics schemes. module auxiliaries use params implicit none private public precnv , precls , snowcv , snowls , cbmf , tsr , ssrd , ssr , slrd , slr , olr , slru public ustr , vstr , shf , evap , hfluxn ! Physical variables shared among all physics schemes real , dimension ( ix , il ) :: precnv !! Convective precipitation  [g/(m&#94;2 s)], total real , dimension ( ix , il ) :: precls !! Large-scale precipitation [g/(m&#94;2 s)], total real , dimension ( ix , il ) :: snowcv !! Convective precipitation  [g/(m&#94;2 s)], snow only real , dimension ( ix , il ) :: snowls !! Large-scale precipitation [g/(m&#94;2 s)], snow only real , dimension ( ix , il ) :: cbmf !! Cloud-base mass flux real , dimension ( ix , il ) :: tsr !! Top-of-atmosphere shortwave radiation (downward) real , dimension ( ix , il ) :: ssrd !! Surface shortwave radiation (downward-only) real , dimension ( ix , il ) :: ssr !! Surface shortwave radiation (net downward) real , dimension ( ix , il ) :: slrd !! Surface longwave radiation (downward-only) real , dimension ( ix , il ) :: slr !! Surface longwave radiation (net upward) real , dimension ( ix , il ) :: olr !! Outgoing longwave radiation (upward) real , dimension ( ix , il , 3 ) :: slru !! Surface longwave emission (upward) ! Third dimension -> 1:land, 2:sea, 3: weighted average real , dimension ( ix , il , 3 ) :: ustr !! U-stress real , dimension ( ix , il , 3 ) :: vstr !! V-stress real , dimension ( ix , il , 3 ) :: shf !! Sensible heat flux real , dimension ( ix , il , 3 ) :: evap !! Evaporation [g/(m&#94;2 s)] real , dimension ( ix , il , 3 ) :: hfluxn !! Net heat flux into surface end module","tags":"","loc":"sourcefile/auxiliaries.f90.html"},{"title":"dynamical_constants.f90 – SPEEDY.f90","text":"Files dependent on this one sourcefile~~dynamical_constants.f90~~AfferentGraph sourcefile~dynamical_constants.f90 dynamical_constants.f90 sourcefile~prognostics.f90 prognostics.f90 sourcefile~prognostics.f90->sourcefile~dynamical_constants.f90 sourcefile~implicit.f90 implicit.f90 sourcefile~implicit.f90->sourcefile~dynamical_constants.f90 sourcefile~horizontal_diffusion.f90 horizontal_diffusion.f90 sourcefile~implicit.f90->sourcefile~horizontal_diffusion.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~time_stepping.f90->sourcefile~dynamical_constants.f90 sourcefile~time_stepping.f90->sourcefile~prognostics.f90 sourcefile~time_stepping.f90->sourcefile~implicit.f90 sourcefile~time_stepping.f90->sourcefile~horizontal_diffusion.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 sourcefile~horizontal_diffusion.f90->sourcefile~dynamical_constants.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~forcing.f90->sourcefile~dynamical_constants.f90 sourcefile~forcing.f90->sourcefile~horizontal_diffusion.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~prognostics.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~initialization.f90->sourcefile~prognostics.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~initialization.f90->sourcefile~horizontal_diffusion.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~tendencies.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90->sourcefile~implicit.f90 var pansourcefiledynamical_constantsf90AfferentGraph = svgPanZoom('#sourcefiledynamical_constantsf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules dynamical_constants Source Code dynamical_constants.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !  date: 01/05/2019 !  Constants for initialization of dynamics. module dynamical_constants implicit none private public gamma , hscale , hshum , refrh1 , thd , thdd , thds , tdrs real , parameter :: gamma = 6.0 ! Reference temperature lapse rate (-dT/dz in deg/km) real , parameter :: hscale = 7.5 ! Reference scale height for pressure (in km) real , parameter :: hshum = 2.5 ! Reference scale height for specific humidity (in km) real , parameter :: refrh1 = 0.7 ! Reference relative humidity of near-surface air real , parameter :: thd = 2.4 ! Max damping time (in hours) for horizontal diffusion ! (del&#94;6) of temperature and vorticity real , parameter :: thdd = 2.4 ! Max damping time (in hours) for horizontal diffusion ! (del&#94;6) of divergence real , parameter :: thds = 1 2.0 ! Max damping time (in hours) for extra diffusion (del&#94;2) ! in the stratosphere real , parameter :: tdrs = 2 4.0 * 3 0.0 ! Damping time (in hours) for drag on zonal-mean wind ! in the stratosphere end module","tags":"","loc":"sourcefile/dynamical_constants.f90.html"},{"title":"geopotential.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~geopotential.f90~~EfferentGraph sourcefile~geopotential.f90 geopotential.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~geopotential.f90->sourcefile~geometry.f90 sourcefile~params.f90 params.f90 sourcefile~geopotential.f90->sourcefile~params.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~geopotential.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~geopotential.f90~~AfferentGraph sourcefile~geopotential.f90 geopotential.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~initialization.f90->sourcefile~geopotential.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~geopotential.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules geopotential Source Code geopotential.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !  date: 07/05/2019 !  For performing geopotential calculations. module geopotential use params implicit none private public initialize_geopotential , get_geopotential real :: xgeop1 ( kx ) !! Constants for hydrostatic equation real :: xgeop2 ( kx ) !! Constants for hydrostatic equation contains !> Initializes the arrays used for geopotential calculations subroutine initialize_geopotential use physical_constants , only : rgas use geometry , only : hsg , fsg integer :: k ! Coefficients to compute geopotential do k = 1 , kx xgeop1 ( k ) = rgas * log ( hsg ( k + 1 ) / fsg ( k )) if ( k /= kx ) xgeop2 ( k + 1 ) = rgas * log ( fsg ( k + 1 ) / hsg ( k + 1 )) end do end subroutine !> Computes spectral geopotential from spectral temperature T and spectral !  topography phis, as in GFDL Climate Group GCM. function get_geopotential ( t , phis ) result ( phi ) use geometry , only : hsg , fsg complex , intent ( in ) :: t ( mx , nx , kx ) !! Spectral temperature complex , intent ( in ) :: phis ( mx , nx ) !! Spectral surface geopotential complex :: phi ( mx , nx , kx ) !! Spectral geopotential integer :: k real :: corf ! 1. Bottom layer (integration over half a layer) phi (:,:, kx ) = phis + xgeop1 ( kx ) * t (:,:, kx ) ! 2. Other layers (integration two half-layers) do k = kx - 1 , 1 , - 1 phi (:,:, k ) = phi (:,:, k + 1 ) + xgeop2 ( k + 1 ) * t (:,:, k + 1 )& & + xgeop1 ( k ) * t (:,:, k ) end do ! 3. lapse-rate correction in the free troposphere do k = 2 , kx - 1 corf = xgeop1 ( k ) * 0.5 * log ( hsg ( k + 1 ) / fsg ( k )) / log ( fsg ( k + 1 ) / fsg ( k - 1 )) phi ( 1 ,:, k ) = phi ( 1 ,:, k ) + corf * ( t ( 1 ,:, k + 1 ) - t ( 1 ,:, k - 1 )) end do end function end module","tags":"","loc":"sourcefile/geopotential.f90.html"},{"title":"interpolation.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~interpolation.f90~~EfferentGraph sourcefile~interpolation.f90 interpolation.f90 sourcefile~date.f90 date.f90 sourcefile~interpolation.f90->sourcefile~date.f90 sourcefile~params.f90 params.f90 sourcefile~interpolation.f90->sourcefile~params.f90 sourcefile~date.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~interpolation.f90~~AfferentGraph sourcefile~interpolation.f90 interpolation.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~land_model.f90->sourcefile~interpolation.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~sea_model.f90->sourcefile~interpolation.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 sourcefile~coupler.f90 coupler.f90 sourcefile~coupler.f90->sourcefile~land_model.f90 sourcefile~coupler.f90->sourcefile~sea_model.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~forcing.f90->sourcefile~land_model.f90 sourcefile~forcing.f90->sourcefile~sea_model.f90 sourcefile~forcing.f90->sourcefile~surface_fluxes.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~initialization.f90->sourcefile~sea_model.f90 sourcefile~initialization.f90->sourcefile~coupler.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~physics.f90 physics.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~physics.f90->sourcefile~land_model.f90 sourcefile~physics.f90->sourcefile~sea_model.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~coupler.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 var pansourcefileinterpolationf90AfferentGraph = svgPanZoom('#sourcefileinterpolationf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules interpolation Source Code interpolation.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !  date: 09/05/2019 !  For interpolating fields in time. module interpolation use date , only : tmonth use params , only : ix , il implicit none private public forint , forin5 contains !> Performs linear interpolation of monthly-mean forcing fields. subroutine forint ( imon , for12 , for1 ) integer , intent ( in ) :: imon !! The month real , intent ( in ) :: for12 ( ix * il , * ) !! The input field real , intent ( inout ) :: for1 ( ix * il ) !! The output field integer :: imon2 real :: wmon if ( tmonth <= 0.5 ) then imon2 = imon - 1 if ( imon == 1 ) imon2 = 12 wmon = 0.5 - tmonth else imon2 = imon + 1 if ( imon == 12 ) imon2 = 1 wmon = tmonth - 0.5 end if for1 = for12 (:, imon ) + wmon * ( for12 (:, imon2 ) - for12 (:, imon )) end subroutine !> Performs nonlinear, mean-conserving interpolation of monthly-mean forcing fields. subroutine forin5 ( imon , for12 , for1 ) integer , intent ( in ) :: imon !! The month real , intent ( in ) :: for12 ( ix * il , 12 ) !! The input field real , intent ( inout ) :: for1 ( ix * il ) !! The output field integer :: im1 , im2 , ip1 , ip2 real :: c0 , t0 , t1 , t2 , wm1 , wm2 , w0 , wp1 , wp2 im2 = imon - 2 im1 = imon - 1 ip1 = imon + 1 ip2 = imon + 2 if ( im2 < 1 ) im2 = im2 + 12 if ( im1 < 1 ) im1 = im1 + 12 if ( ip1 > 12 ) ip1 = ip1 - 12 if ( ip2 > 12 ) ip2 = ip2 - 12 c0 = 1.0 / 1 2.0 t0 = c0 * tmonth t1 = c0 * ( 1.0 - tmonth ) t2 = 0.25 * tmonth * ( 1 - tmonth ) wm2 = - t1 + t2 wm1 = - c0 + 8 * t1 - 6 * t2 w0 = 7 * c0 + 10 * t2 wp1 = - c0 + 8 * t0 - 6 * t2 wp2 = - t0 + t2 for1 = wm2 * for12 (:, im2 ) + wm1 * for12 (:, im1 ) + w0 * for12 (:, imon ) + & & wp1 * for12 (:, ip1 ) + wp2 * for12 (:, ip2 ) end subroutine end module","tags":"","loc":"sourcefile/interpolation.f90.html"},{"title":"input_output.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~input_output.f90~~EfferentGraph sourcefile~input_output.f90 input_output.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~input_output.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~input_output.f90->sourcefile~geometry.f90 sourcefile~params.f90 params.f90 sourcefile~input_output.f90->sourcefile~params.f90 sourcefile~date.f90 date.f90 sourcefile~input_output.f90->sourcefile~date.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~date.f90->sourcefile~params.f90 sourcefile~spectral.f90->sourcefile~physical_constants.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~spectral.f90->sourcefile~params.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~legendre.f90->sourcefile~params.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 sourcefile~fourier.f90->sourcefile~params.f90 var pansourcefileinput_outputf90EfferentGraph = svgPanZoom('#sourcefileinput_outputf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~input_output.f90~~AfferentGraph sourcefile~input_output.f90 input_output.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~input_output.f90 sourcefile~prognostics.f90 prognostics.f90 sourcefile~speedy.f90->sourcefile~prognostics.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~coupler.f90 coupler.f90 sourcefile~speedy.f90->sourcefile~coupler.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~prognostics.f90->sourcefile~input_output.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~prognostics.f90->sourcefile~boundaries.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~land_model.f90->sourcefile~input_output.f90 sourcefile~land_model.f90->sourcefile~boundaries.f90 sourcefile~initialization.f90->sourcefile~input_output.f90 sourcefile~initialization.f90->sourcefile~prognostics.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~initialization.f90->sourcefile~sea_model.f90 sourcefile~initialization.f90->sourcefile~boundaries.f90 sourcefile~initialization.f90->sourcefile~coupler.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~physics.f90 physics.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~sea_model.f90->sourcefile~input_output.f90 sourcefile~sea_model.f90->sourcefile~boundaries.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 sourcefile~coupler.f90->sourcefile~land_model.f90 sourcefile~coupler.f90->sourcefile~sea_model.f90 sourcefile~time_stepping.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 sourcefile~forcing.f90->sourcefile~land_model.f90 sourcefile~forcing.f90->sourcefile~sea_model.f90 sourcefile~forcing.f90->sourcefile~boundaries.f90 sourcefile~forcing.f90->sourcefile~surface_fluxes.f90 sourcefile~physics.f90->sourcefile~land_model.f90 sourcefile~physics.f90->sourcefile~sea_model.f90 sourcefile~physics.f90->sourcefile~boundaries.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~tendencies.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 var pansourcefileinput_outputf90AfferentGraph = svgPanZoom('#sourcefileinput_outputf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules input_output Source Code input_output.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !  date: 08/05/2019 !  For performing input and output. module input_output use netcdf use params implicit none private public output , load_boundary_file !> Interface for reading boundary files. interface load_boundary_file module procedure load_boundary_file_2d module procedure load_boundary_file_one_month_from_year module procedure load_boundary_file_one_month_from_long end interface contains !> Loads the given 2D field from the given boundary file. function load_boundary_file_2d ( file_name , field_name ) result ( field ) character ( len =* ), intent ( in ) :: file_name !! The NetCDF file to read from character ( len =* ), intent ( in ) :: field_name !! The field to read integer :: ncid , varid real ( 4 ), dimension ( ix , il ) :: raw_input real , dimension ( ix , il ) :: field ! Open boundary file, read variable and then close call check ( nf90_open ( file_name , nf90_nowrite , ncid )) call check ( nf90_inq_varid ( ncid , field_name , varid )) call check ( nf90_get_var ( ncid , varid , raw_input , start = ( / 1 , 1 / ), count = ( / ix , il / ))) call check ( nf90_close ( ncid )) field = raw_input (:, il : 1 : - 1 ) ! Fix undefined values where ( field <= - 999 ) field = 0.0 end function !> Loads the given 2D field at the given month from the given monthly !  boundary file. function load_boundary_file_one_month_from_year ( file_name , field_name , month ) result ( field ) character ( len =* ), intent ( in ) :: file_name !! The NetCDF file to read from character ( len =* ), intent ( in ) :: field_name !! The field to read integer , intent ( in ) :: month !! The month to read integer :: ncid , varid real ( 4 ), dimension ( ix , il , 12 ) :: raw_input real , dimension ( ix , il ) :: field ! Open boundary file, read variable and then close call check ( nf90_open ( file_name , nf90_nowrite , ncid )) call check ( nf90_inq_varid ( ncid , field_name , varid )) call check ( nf90_get_var ( ncid , varid , raw_input )) call check ( nf90_close ( ncid )) field = raw_input (:, il : 1 : - 1 , month ) ! Fix undefined values where ( field <= - 999 ) field = 0.0 end !> Loads the given 2D field at the given month from the given boundary file !  of a given length. ! !  This is used for reading the SST anomalies from a particular month of a !  particular year. The SST anomalies are stored in a long multidecadal !  file and the total number of months in this file must be passed as an !  argument (`length`). function load_boundary_file_one_month_from_long ( file_name , field_name , month , length ) & & result ( field ) character ( len =* ), intent ( in ) :: file_name !! The NetCDF file to read from character ( len =* ), intent ( in ) :: field_name !! The field to read integer , intent ( in ) :: month !! The month to read integer , intent ( in ) :: length !! The total length of the file in number of !! months integer :: ncid , varid real ( 4 ), dimension ( ix , il , length ) :: raw_input real , dimension ( ix , il ) :: field ! Open boundary file, read variable and then close call check ( nf90_open ( file_name , nf90_nowrite , ncid )) call check ( nf90_inq_varid ( ncid , field_name , varid )) call check ( nf90_get_var ( ncid , varid , raw_input )) call check ( nf90_close ( ncid )) field = raw_input (:, il : 1 : - 1 , month ) ! Fix undefined values where ( field <= - 999 ) field = 0.0 end !> Writes a snapshot of all prognostic variables to a NetCDF file. subroutine output ( timestep , vor , div , t , ps , tr , phi ) use geometry , only : radang , fsg use physical_constants , only : p0 , grav use date , only : model_datetime , start_datetime use spectral , only : spec_to_grid , uvspec integer , intent ( in ) :: timestep !! The time step that is being written complex , intent ( in ) :: vor ( mx , nx , kx , 2 ) !! Vorticity complex , intent ( in ) :: div ( mx , nx , kx , 2 ) !! Divergence complex , intent ( in ) :: t ( mx , nx , kx , 2 ) !! Temperature complex , intent ( in ) :: ps ( mx , nx , 2 ) !! log(normalized surface pressure) complex , intent ( in ) :: tr ( mx , nx , kx , 2 , ntr ) !! Tracers complex , intent ( in ) :: phi ( mx , nx , kx ) !! Geopotential complex , dimension ( mx , nx ) :: ucos , vcos real , dimension ( ix , il , kx ) :: u_grid , v_grid , t_grid , q_grid , phi_grid real , dimension ( ix , il ) :: ps_grid real ( 4 ), dimension ( ix , il , kx ) :: u_out , v_out , t_out , q_out , phi_out real ( 4 ), dimension ( ix , il ) :: ps_out character ( len = 15 ) :: file_name = 'yyyymmddhhmm.nc' character ( len = 32 ) :: time_template = 'hours since yyyy-mm-dd hh:mm:0.0' integer :: k , ncid integer :: timedim , latdim , londim , levdim integer :: timevar , latvar , lonvar , levvar , uvar , vvar , tvar , qvar , phivar , psvar ! Construct file_name write ( file_name ( 1 : 4 ), '(i4.4)' ) model_datetime % year write ( file_name ( 5 : 6 ), '(i2.2)' ) model_datetime % month write ( file_name ( 7 : 8 ), '(i2.2)' ) model_datetime % day write ( file_name ( 9 : 10 ), '(i2.2)' ) model_datetime % hour write ( file_name ( 11 : 12 ), '(i2.2)' ) model_datetime % minute ! Construct time string write ( time_template ( 13 : 16 ), '(i4.4)' ) start_datetime % year write ( time_template ( 18 : 19 ), '(i2.2)' ) start_datetime % month write ( time_template ( 21 : 22 ), '(i2.2)' ) start_datetime % day write ( time_template ( 24 : 25 ), '(i2.2)' ) start_datetime % hour write ( time_template ( 27 : 28 ), '(i2.2)' ) start_datetime % minute ! Create NetCDF output file call check ( nf90_create ( file_name , nf90_clobber , ncid )) ! Define time call check ( nf90_def_dim ( ncid , \"time\" , nf90_unlimited , timedim )) call check ( nf90_def_var ( ncid , \"time\" , nf90_real4 , timedim , timevar )) call check ( nf90_put_att ( ncid , timevar , \"units\" , time_template )) ! Define space call check ( nf90_def_dim ( ncid , \"lon\" , ix , londim )) call check ( nf90_def_dim ( ncid , \"lat\" , il , latdim )) call check ( nf90_def_dim ( ncid , \"lev\" , kx , levdim )) call check ( nf90_def_var ( ncid , \"lon\" , nf90_real4 , londim , lonvar )) call check ( nf90_put_att ( ncid , lonvar , \"long_name\" , \"longitude\" )) call check ( nf90_def_var ( ncid , \"lat\" , nf90_real4 , latdim , latvar )) call check ( nf90_put_att ( ncid , latvar , \"long_name\" , \"latitude\" )) call check ( nf90_def_var ( ncid , \"lev\" , nf90_real4 , levdim , levvar )) call check ( nf90_put_att ( ncid , levvar , \"long_name\" , \"atmosphere_sigma_coordinate\" )) ! Define prognostic fields call check ( nf90_def_var ( ncid , \"u\" , nf90_real4 , ( / londim , latdim , levdim , timedim / ), uvar )) call check ( nf90_put_att ( ncid , uvar , \"long_name\" , \"eastward_wind\" )) call check ( nf90_put_att ( ncid , uvar , \"units\" , \"m/s\" )) call check ( nf90_def_var ( ncid , \"v\" , nf90_real4 , ( / londim , latdim , levdim , timedim / ), vvar )) call check ( nf90_put_att ( ncid , vvar , \"long_name\" , \"northward_wind\" )) call check ( nf90_put_att ( ncid , vvar , \"units\" , \"m/s\" )) call check ( nf90_def_var ( ncid , \"t\" , nf90_real4 , ( / londim , latdim , levdim , timedim / ), tvar )) call check ( nf90_put_att ( ncid , tvar , \"long_name\" , \"air_temperature\" )) call check ( nf90_put_att ( ncid , tvar , \"units\" , \"K\" )) call check ( nf90_def_var ( ncid , \"q\" , nf90_real4 , ( / londim , latdim , levdim , timedim / ), qvar )) call check ( nf90_put_att ( ncid , qvar , \"long_name\" , \"specific_humidity\" )) call check ( nf90_put_att ( ncid , qvar , \"units\" , \"1\" )) call check ( nf90_def_var ( ncid , \"phi\" , nf90_real4 , ( / londim , latdim , levdim , timedim / ), & & phivar )) call check ( nf90_put_att ( ncid , phivar , \"long_name\" , \"geopotential_height\" )) call check ( nf90_put_att ( ncid , phivar , \"units\" , \"m\" )) call check ( nf90_def_var ( ncid , \"ps\" , nf90_real4 , ( / londim , latdim , timedim / ), psvar )) call check ( nf90_put_att ( ncid , psvar , \"long_name\" , \"surface_air_pressure\" )) call check ( nf90_put_att ( ncid , psvar , \"units\" , \"Pa\" )) call check ( nf90_enddef ( ncid )) ! Write dimensions to file call check ( nf90_put_var ( ncid , timevar , timestep * 2 4.0 / real ( nsteps , 4 ), ( / 1 / ))) call check ( nf90_put_var ( ncid , lonvar , ( / ( 3.75 * k , k = 0 , ix - 1 ) / ), ( / 1 / ))) call check ( nf90_put_var ( ncid , latvar , ( / ( radang ( k ) * 9 0.0 / asin ( 1.0 ), k = 1 , il ) / ), ( / 1 / ))) call check ( nf90_put_var ( ncid , levvar , ( / ( fsg ( k ), k = 1 , 8 ) / ), ( / 1 / ))) ! Convert prognostic fields from spectral space to grid point space do k = 1 , kx call uvspec ( vor (:,:, k , 1 ), div (:,:, k , 1 ), ucos , vcos ) u_grid (:,:, k ) = spec_to_grid ( ucos , 2 ) v_grid (:,:, k ) = spec_to_grid ( vcos , 2 ) t_grid (:,:, k ) = spec_to_grid ( t (:,:, k , 1 ), 1 ) q_grid (:,:, k ) = spec_to_grid ( tr (:,:, k , 1 , 1 ), 1 ) phi_grid (:,:, k ) = spec_to_grid ( phi (:,:, k ), 1 ) end do ps_grid = spec_to_grid ( ps (:,:, 1 ), 1 ) ! Output date print '(A,I4.4,A,I2.2,A,I2.2,A,I2.2,A,I2.2)' ,& & 'Write gridded dataset for year/month/date/hour/minute: ' , & & model_datetime % year , '/' , model_datetime % month , '/' , model_datetime % day , '/' , & & model_datetime % hour , '/' , model_datetime % minute ! Preprocess output variables u_out = real ( u_grid , 4 ) v_out = real ( v_grid , 4 ) t_out = real ( t_grid , 4 ) q_out = real ( q_grid * 1.0e-3 , 4 ) ! kg/kg phi_out = real ( phi_grid / grav , 4 ) ! m ps_out = real ( p0 * exp ( ps_grid ), 4 ) ! Pa ! Write prognostic variables to file call check ( nf90_put_var ( ncid , uvar , u_out , ( / 1 , 1 , 1 , 1 / ))) call check ( nf90_put_var ( ncid , vvar , v_out , ( / 1 , 1 , 1 , 1 / ))) call check ( nf90_put_var ( ncid , tvar , t_out , ( / 1 , 1 , 1 , 1 / ))) call check ( nf90_put_var ( ncid , qvar , q_out , ( / 1 , 1 , 1 , 1 / ))) call check ( nf90_put_var ( ncid , phivar , phi_out , ( / 1 , 1 , 1 , 1 / ))) call check ( nf90_put_var ( ncid , psvar , ps_out , ( / 1 , 1 , 1 / ))) call check ( nf90_close ( ncid )) end subroutine !> Handles any errors from the NetCDF API. subroutine check ( ierr ) integer , intent ( in ) :: ierr if ( ierr /= nf90_noerr ) then print * , trim ( adjustl ( nf90_strerror ( ierr ))) stop end if end subroutine end module","tags":"","loc":"sourcefile/input_output.f90.html"},{"title":"sppt.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~sppt.f90~~EfferentGraph sourcefile~sppt.f90 sppt.f90 sourcefile~params.f90 params.f90 sourcefile~sppt.f90->sourcefile~params.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~sppt.f90->sourcefile~spectral.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~sppt.f90->sourcefile~physical_constants.f90 sourcefile~spectral.f90->sourcefile~params.f90 sourcefile~spectral.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 sourcefile~legendre.f90->sourcefile~params.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~fourier.f90->sourcefile~params.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 var pansourcefilespptf90EfferentGraph = svgPanZoom('#sourcefilespptf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~sppt.f90~~AfferentGraph sourcefile~sppt.f90 sppt.f90 sourcefile~physics.f90 physics.f90 sourcefile~physics.f90->sourcefile~sppt.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules sppt Source Code sppt.f90 Source Code !> author: Sam Hatfield !  date: 29/04/2019 !  For computing stochastically perturbed parametrization tendency (SPPT) !  patterns. ! !  To be used as multiplicative noise applied to physical tendencies. SPPT is !  a parametrization of model error. !  See ECMWF Tech. Memo. #598 (Palmer et al. 2009). module sppt use params implicit none private public mu , gen_sppt !> Array for tapering value of SPPT in the different layers of the !  atmosphere. A value of 1 means the tendency is not tapered at that level real :: mu ( kx ) = ( / 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 / ) !> SPPT pattern in spectral space complex :: sppt_spec ( mx , nx , kx ) !> Flag for controlling first-use behaviour logical :: first = . true . !> Decorrelation time of SPPT perturbation (in hours) real , parameter :: time_decorr = 6.0 !> Time autocorrelation of spectral AR(1) signals real :: phi = exp ( - ( 24 / real ( nsteps )) / time_decorr ) !> Correlation length scale of SPPT perturbation (in metres) real , parameter :: len_decorr = 50000 0.0 !> Standard deviation of SPPT perturbation (in grid point space) real , parameter :: stddev = 0.33 !> Total wavenumber-wise standard deviation of spectral signals real :: sigma ( mx , nx , kx ) contains !> Generate grid point space SPPT pattern distribution. function gen_sppt () result ( sppt_grid ) use spectral , only : el2 , spec_to_grid use physical_constants , only : rearth real :: sppt_grid ( ix , il , kx ) !! The generated grid point pattern integer :: m , n , k complex :: eta ( mx , nx , kx ) real :: f0 , randreal , randimag ! Seed RNG if first use of SPPT if ( first ) call time_seed () ! Generate Gaussian noise do m = 1 , mx do n = 1 , nx do k = 1 , kx randreal = randn ( 0.0 , 1.0 ) randimag = randn ( 0.0 , 1.0 ) ! Clip noise to +- 10 standard deviations eta ( m , n , k ) = cmplx (& & min ( 1 0.0 , abs ( randreal )) * sign ( 1.0 , randreal ),& & min ( 1 0.0 , abs ( randimag )) * sign ( 1.0 , randimag )) end do end do end do ! If first timestep if ( first ) then ! Generate spatial amplitude pattern and time correlation f0 = sum (( / (( 2 * n + 1 ) * exp ( - 0.5 * ( len_decorr / rearth ) ** 2 * n * ( n + 1 )), n = 1 , trunc ) / )) f0 = sqrt (( stddev ** 2 * ( 1 - phi ** 2 )) / ( 2 * f0 )) do k = 1 , kx sigma (:,:, k ) = f0 * exp ( - 0.25 * len_decorr ** 2 * el2 ) end do ! First AR(1) step sppt_spec = ( 1 - phi ** 2 ) ** ( - 0.5 ) * sigma * eta first = . false . else ! Subsequent AR(1) steps sppt_spec = phi * sppt_spec + sigma * eta end if ! Convert to grid point space do k = 1 , kx sppt_grid (:,:, k ) = spec_to_grid ( sppt_spec (:,:, k ), 1 ) end do ! Clip to +/- 1.0 sppt_grid = min ( 1.0 , abs ( sppt_grid )) * sign ( 1.0 , sppt_grid ) end function !> Generates a random number drawn for the specified normal distribution. function randn ( mean , stdev ) real , intent ( in ) :: mean !! The mean of the distribution to draw from real , intent ( in ) :: stdev !! The standard deviation of the distribution to draw from real :: randn !! The generated random number real :: u , v real :: rand ( 2 ) call random_number ( rand ) ! Box-Muller method u = ( - 2.0 * log ( rand ( 1 ))) ** 0.5 v = 2.0 * 6.28318530718 * rand ( 2 ) randn = mean + stdev * u * sin ( v ) end function !> Seeds RNG from system clock. subroutine time_seed () integer :: i , n , clock integer , allocatable :: seed (:) call random_seed ( size = n ) allocate ( seed ( n )) call system_clock ( count = clock ) seed = clock + 37 * ( / ( i - 1 , i = 1 , n ) / ) call random_seed ( put = seed ) deallocate ( seed ) end subroutine end module","tags":"","loc":"sourcefile/sppt.f90.html"},{"title":"convection.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~convection.f90~~EfferentGraph sourcefile~convection.f90 convection.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~convection.f90->sourcefile~geometry.f90 sourcefile~params.f90 params.f90 sourcefile~convection.f90->sourcefile~params.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~convection.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~convection.f90~~AfferentGraph sourcefile~convection.f90 convection.f90 sourcefile~physics.f90 physics.f90 sourcefile~physics.f90->sourcefile~convection.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 var pansourcefileconvectionf90AfferentGraph = svgPanZoom('#sourcefileconvectionf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules convection Source Code convection.f90 Source Code !> Parametrization of convection ! !  Convection is modelled using a simplified version of the Tiedke (1993) !  mass-flux convection scheme. module convection use params implicit none private public get_convection_tendencies ! Constants for convection real , parameter :: psmin = 0.8 !! Minimum (normalised) surface pressure for the occurrence of !! convection real , parameter :: trcnv = 6.0 !! Time of relaxation (in hours) towards reference state real , parameter :: rhbl = 0.9 !! Relative humidity threshold in the boundary layer real , parameter :: rhil = 0.7 !! Relative humidity threshold in intermeduate layers for !! secondary mass flux real , parameter :: entmax = 0.5 !! Maximum entrainment as a fraction of cloud-base mass flux real , parameter :: smf = 0.8 !! Ratio between secondary and primary mass flux at cloud-base contains !> Compute convective fluxes of dry static energy and moisture using a !  simplified mass-flux scheme subroutine get_convection_tendencies ( psa , se , qa , qsat , itop , cbmf , precnv , dfse , dfqa ) use physical_constants , only : p0 , alhc , alhs , wvi , grav use geometry , only : fsg , dhs real , intent ( in ) :: psa ( ix , il ) !! Normalised surface pressure [p/p0] real , intent ( in ) :: se ( ix , il , kx ) !! Dry static energy [c_p.T + g.z] real , intent ( in ) :: qa ( ix , il , kx ) !! Specific humidity [g/kg] real , intent ( in ) :: qsat ( ix , il , kx ) !! Saturation specific humidity [g/kg] integer , intent ( out ) :: itop ( ix , il ) !! Top of convection (layer index) real , intent ( out ) :: cbmf ( ix , il ) !! Cloud-base mass flux real , intent ( out ) :: precnv ( ix , il ) !! Convective precipitation [g/(m&#94;2 s)] real , intent ( out ) :: dfse ( ix , il , kx ) !! Net flux of dry static energy into each atmospheric !! layer real , intent ( out ) :: dfqa ( ix , il , kx ) !! Net flux of specific humidity into each atmospheric !! layer integer :: i , j , k , k1 , nl1 , nlp real :: qdif ( ix , il ) real :: entr ( 2 : kx - 1 ), delq , enmass , fdq , fds , fm0 , fmass , fpsa , fqmax real :: fsq , fuq , fus , qb , qmax , qsatb , rdps , sb , sentr ! 1. Initialization of output and workspace arrays nl1 = kx - 1 nlp = kx + 1 fqmax = 5.0 fm0 = p0 * dhs ( kx ) / ( grav * trcnv * 360 0.0 ) rdps = 2.0 / ( 1.0 - psmin ) dfse = 0.0 dfqa = 0.0 cbmf = 0.0 precnv = 0.0 ! Entrainment profile (up to sigma = 0.5) sentr = 0.0 do k = 2 , nl1 entr ( k ) = ( max ( 0.0 , fsg ( k ) - 0.5 )) ** 2.0 sentr = sentr + entr ( k ) end do sentr = entmax / sentr entr ( 2 : nl1 ) = entr ( 2 : nl1 ) * sentr ! 2. Check of conditions for convection call diagnose_convection ( psa , se , qa , qsat , itop , qdif ) ! 3. Convection over selected grid-points do i = 1 , ix do j = 1 , il if ( itop ( i , j ) == nlp ) cycle ! 3.1 Boundary layer (cloud base) k = kx k1 = k - 1 ! Maximum specific humidity in the PBL qmax = max ( 1.01 * qa ( i , j , k ), qsat ( i , j , k )) ! Dry static energy and moisture at upper boundary sb = se ( i , j , k1 ) + wvi ( k1 , 2 ) * ( se ( i , j , k ) - se ( i , j , k1 )) qb = qa ( i , j , k1 ) + wvi ( k1 , 2 ) * ( qa ( i , j , k ) - qa ( i , j , k1 )) qb = min ( qb , qa ( i , j , k )) ! Cloud-base mass flux, computed to satisfy: ! fmass*(qmax-qb)*(g/dp)=qdif/trcnv fpsa = psa ( i , j ) * min ( 1.0 , ( psa ( i , j ) - psmin ) * rdps ) fmass = fm0 * fpsa * min ( fqmax , qdif ( i , j ) / ( qmax - qb )) cbmf ( i , j ) = fmass ! Upward fluxes at upper boundary fus = fmass * se ( i , j , k ) fuq = fmass * qmax ! Downward fluxes at upper boundary fds = fmass * sb fdq = fmass * qb ! Net flux of dry static energy and moisture dfse ( i , j , k ) = fds - fus dfqa ( i , j , k ) = fdq - fuq ! 3.2 Intermediate layers (entrainment) do k = kx - 1 , itop ( i , j ) + 1 , - 1 k1 = k - 1 ! Fluxes at lower boundary dfse ( i , j , k ) = fus - fds dfqa ( i , j , k ) = fuq - fdq ! Mass entrainment enmass = entr ( k ) * psa ( i , j ) * cbmf ( i , j ) fmass = fmass + enmass ! Upward fluxes at upper boundary fus = fus + enmass * se ( i , j , k ) fuq = fuq + enmass * qa ( i , j , k ) ! Downward fluxes at upper boundary sb = se ( i , j , k1 ) + wvi ( k1 , 2 ) * ( se ( i , j , k ) - se ( i , j , k1 )) qb = qa ( i , j , k1 ) + wvi ( k1 , 2 ) * ( qa ( i , j , k ) - qa ( i , j , k1 )) fds = fmass * sb fdq = fmass * qb ! Net flux of dry static energy and moisture dfse ( i , j , k ) = dfse ( i , j , k ) + fds - fus dfqa ( i , j , k ) = dfqa ( i , j , k ) + fdq - fuq ! Secondary moisture flux delq = rhil * qsat ( i , j , k ) - qa ( i , j , k ) if ( delq > 0.0 ) then fsq = smf * cbmf ( i , j ) * delq dfqa ( i , j , k ) = dfqa ( i , j , k ) + fsq dfqa ( i , j , kx ) = dfqa ( i , j , kx ) - fsq end if end do ! 3.3 Top layer (condensation and detrainment) k = itop ( i , j ) ! Flux of convective precipitation qsatb = qsat ( i , j , k ) + wvi ( k , 2 ) * ( qsat ( i , j , k + 1 ) - qsat ( i , j , k )) precnv ( i , j ) = max ( fuq - fmass * qsatb , 0.0 ) ! Net flux of dry static energy and moisture dfse ( i , j , k ) = fus - fds + alhc * precnv ( i , j ) dfqa ( i , j , k ) = fuq - fdq - precnv ( i , j ) end do end do end !> Diagnose convectively unstable gridboxes ! !  Convection is activated in gridboxes with conditional instability. This !  is diagnosed by checking for any tropopsheric half level where the !  saturation moist static energy is lower than in the boundary-layer level. !  In gridboxes where this is true, convection is activated if either: there !  is convective instability - the actual moist static energy at the !  tropospheric level is lower than in the boundary-layer level, or, the !  relative humidity in the boundary-layer level and lowest tropospheric !  level exceed a set threshold (rhbl). subroutine diagnose_convection ( psa , se , qa , qsat , itop , qdif ) use physical_constants , only : alhc , wvi real , intent ( in ) :: psa ( ix , il ) !! Normalised surface pressure [p/p0] real , intent ( in ) :: se ( ix , il , kx ) !! Dry static energy [c_p.T + g.z] real , intent ( in ) :: qa ( ix , il , kx ) !! Specific humidity [g/kg] real , intent ( in ) :: qsat ( ix , il , kx ) !! Saturation specific humidity [g/kg] integer , intent ( out ) :: itop ( ix , il ) !! Top of convection (layer index) real , intent ( out ) :: qdif ( ix , il ) !! Excess humidity in convective gridboxes integer :: i , j , k , ktop1 , ktop2 , nl1 , nlp real :: mss ( ix , il , 2 : kx ), mse0 , mse1 , mss0 , mss2 , msthr real :: qthr0 , qthr1 , rlhc logical :: lqthr nl1 = kx - 1 nlp = kx + 1 ! Saturation moist static energy do k = 2 , kx mss (:,:, k ) = se (:,:, k ) + alhc * qsat (:,:, k ) end do rlhc = 1.0 / alhc do i = 1 , ix do j = 1 , il itop ( i , j ) = nlp if ( psa ( i , j ) > psmin ) then ! Minimum of moist static energy in the lowest two levels mse0 = se ( i , j , kx ) + alhc * qa ( i , j , kx ) mse1 = se ( i , j , nl1 ) + alhc * qa ( i , j , nl1 ) mse1 = min ( mse0 , mse1 ) ! Saturation (or super-saturated) moist static energy in PBL mss0 = max ( mse0 , mss ( i , j , kx )) ktop1 = kx ktop2 = kx do k = kx - 3 , 3 , - 1 mss2 = mss ( i , j , k ) + wvi ( k , 2 ) * ( mss ( i , j , k + 1 ) - mss ( i , j , k )) ! Check 1: conditional instability !          (MSS in PBL > MSS at top level) if ( mss0 > mss2 ) then ktop1 = k end if ! Check 2: gradient of actual moist static energy !          between lower and upper troposphere if ( mse1 > mss2 ) then ktop2 = k msthr = mss2 end if end do if ( ktop1 < kx ) then ! Check 3: RH > RH_c at both k=NLEV and k=NL1 qthr0 = rhbl * qsat ( i , j , kx ) qthr1 = rhbl * qsat ( i , j , nl1 ) lqthr = ( qa ( i , j , kx ) > qthr0 . and . qa ( i , j , nl1 ) > qthr1 ) if ( ktop2 < kx ) then itop ( i , j ) = ktop1 qdif ( i , j ) = max ( qa ( i , j , kx ) - qthr0 , ( mse0 - msthr ) * rlhc ) else if ( lqthr ) then itop ( i , j ) = ktop1 qdif ( i , j ) = qa ( i , j , kx ) - qthr0 end if end if end if end do end do end end module","tags":"","loc":"sourcefile/convection.f90.html"},{"title":"large_scale_condensation.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~large_scale_condensation.f90~~EfferentGraph sourcefile~large_scale_condensation.f90 large_scale_condensation.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~large_scale_condensation.f90->sourcefile~geometry.f90 sourcefile~params.f90 params.f90 sourcefile~large_scale_condensation.f90->sourcefile~params.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~large_scale_condensation.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~large_scale_condensation.f90~~AfferentGraph sourcefile~large_scale_condensation.f90 large_scale_condensation.f90 sourcefile~physics.f90 physics.f90 sourcefile~physics.f90->sourcefile~large_scale_condensation.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 var pansourcefilelarge_scale_condensationf90AfferentGraph = svgPanZoom('#sourcefilelarge_scale_condensationf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules large_scale_condensation Source Code large_scale_condensation.f90 Source Code !> Parametrization of large-scale condensation ! !  Large-scale condensation is modelled as a relaxation of humidity to a !  sigma-dependent threshold value RH(\\sigma). !  \\frac{\\partial q}{\\partial t} = !      -\\frac{q - RH(\\sigma) q_{sat}}{\\tau_{lsc}}, !  where \\tau_{lsc} is the relaxation timescale. The temperature tendency is !  computed as the resultant latent heating, !  \\frac{\\partial T}{\\partial t} = !      - \\frac{L}{c_p} \\frac{\\partial q}{\\partial t}. !  Precipitation is diagnosed as all the moisture lost to condensation falling !  out of the atmospheric column in the timestep, !  P = -\\frac{1}{g} \\sum_{k=2}&#94;N \\Delta p \\frac{\\partial q}{\\partial t}. module large_scale_condensation use params implicit none private public get_large_scale_condensation_tendencies ! Constants for large-scale condensation real , parameter :: trlsc = 4.0 !! Relaxation time (in hours) for specific humidity real , parameter :: rhlsc = 0.9 !! Maximum relative humidity threshold (at sigma=1) real , parameter :: drhlsc = 0.1 !! Vertical range of relative humidity threshold real , parameter :: rhblsc = 0.95 !! Relative humidity threshold for boundary layer contains !> Compute large-scale condensation and associated tendencies of temperature !  and moisture subroutine get_large_scale_condensation_tendencies ( psa , qa , qsat , itop , precls , dtlsc , dqlsc ) use physical_constants , only : p0 , cp , alhc , alhs , grav use geometry , only : fsg , dhs real , intent ( in ) :: psa ( ix , il ) !! Normalised surface pressure [p/p0] real , intent ( in ) :: qa ( ix , il , kx ) !! Specific humidity [g/kg] real , intent ( in ) :: qsat ( ix , il , kx ) !! Saturation specific humidity [g/kg] integer , intent ( inout ) :: itop ( ix , il ) !! Cloud top diagnosed from precipitation due to !! convection and large-scale condensation real , intent ( out ) :: precls ( ix , il ) !! Precipitation due to large-scale condensation real , intent ( out ) :: dtlsc ( ix , il , kx ) !! Temperature tendency due to large-scale !! condensation real , intent ( out ) :: dqlsc ( ix , il , kx ) !! Specific humidity tendency due to large-scale !! condensation integer :: i , j , k real :: psa2 ( ix , il ), dqa , dqmax , pfact , prg , qsmax , rhref , rtlsc , sig2 , tfact ! 1. Initialization qsmax = 1 0.0 rtlsc = 1.0 / ( trlsc * 360 0.0 ) tfact = alhc / cp prg = p0 / grav dtlsc (:,:, 1 ) = 0.0 dqlsc (:,:, 1 ) = 0.0 precls = 0.0 psa2 = psa ** 2.0 ! Tendencies of temperature and moisture ! NB. A maximum heating rate is imposed to avoid grid-point-storm ! instability do k = 2 , kx sig2 = fsg ( k ) ** 2.0 rhref = rhlsc + drhlsc * ( sig2 - 1.0 ) if ( k == kx ) rhref = max ( rhref , rhblsc ) dqmax = qsmax * sig2 * rtlsc do i = 1 , ix do j = 1 , il dqa = rhref * qsat ( i , j , k ) - qa ( i , j , k ) if ( dqa < 0.0 ) then itop ( i , j ) = min ( k , itop ( i , j )) dqlsc ( i , j , k ) = dqa * rtlsc dtlsc ( i , j , k ) = tfact * min ( - dqlsc ( i , j , k ), dqmax * psa2 ( i , j )) else dqlsc ( i , j , k ) = 0.0 dtlsc ( i , j , k ) = 0.0 end if end do end do end do ! Large-scale precipitation do k = 2 , kx pfact = dhs ( k ) * prg precls = precls - pfact * dqlsc (:,:, k ) end do precls = precls * psa end end module","tags":"","loc":"sourcefile/large_scale_condensation.f90.html"},{"title":"longwave_radiation.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~longwave_radiation.f90~~EfferentGraph sourcefile~longwave_radiation.f90 longwave_radiation.f90 sourcefile~mod_radcon.f90 mod_radcon.f90 sourcefile~longwave_radiation.f90->sourcefile~mod_radcon.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~longwave_radiation.f90->sourcefile~geometry.f90 sourcefile~params.f90 params.f90 sourcefile~longwave_radiation.f90->sourcefile~params.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~longwave_radiation.f90->sourcefile~physical_constants.f90 sourcefile~mod_radcon.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~longwave_radiation.f90~~AfferentGraph sourcefile~longwave_radiation.f90 longwave_radiation.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~forcing.f90->sourcefile~longwave_radiation.f90 sourcefile~physics.f90 physics.f90 sourcefile~physics.f90->sourcefile~longwave_radiation.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 var pansourcefilelongwave_radiationf90AfferentGraph = svgPanZoom('#sourcefilelongwave_radiationf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules longwave_radiation Source Code longwave_radiation.f90 Source Code !> Parametrization of long-wave radiation module longwave_radiation use params implicit none private public get_downward_longwave_rad_fluxes , get_upward_longwave_rad_fluxes , radset ! Number of radiation bands with tau < 1 integer , parameter :: nband = 4 contains !> Compute the downward flux of long-wave radiation subroutine get_downward_longwave_rad_fluxes ( ta , fsfcd , dfabs ) use physical_constants , only : sbc , wvi use mod_radcon , only : epslw , emisfc , fband , tau2 , st4a , flux real , intent ( in ) :: ta ( ix , il , kx ) !! Absolute temperature [K] real , intent ( out ) :: fsfcd ( ix , il ) !! Downward flux of long-wave radiation at the surface real , intent ( out ) :: dfabs ( ix , il , kx ) !! Flux of long-wave radiation absorbed in each !! atmospheric layer integer :: i , j , jb , k , nl1 real :: anis , brad , corlw ( ix , il ), emis real :: st3a ( ix , il ) nl1 = kx - 1 ! 1. Blackbody emission from atmospheric levels. ! The linearized gradient of the blakbody emission is computed ! from temperatures at layer boundaries, which are interpolated ! assuming a linear dependence of T on log_sigma. ! Above the first (top) level, the atmosphere is assumed isothermal. ! Temperature at level boundaries do k = 1 , nl1 st4a (:,:, k , 1 ) = ta (:,:, k ) + wvi ( k , 2 ) * ( ta (:,:, k + 1 ) - ta (:,:, k )) end do ! Mean temperature in stratospheric layers st4a (:,:, 1 , 2 ) = 0.75 * ta (:,:, 1 ) + 0.25 * st4a (:,:, 1 , 1 ) st4a (:,:, 2 , 2 ) = 0.50 * ta (:,:, 2 ) + 0.25 * ( st4a (:,:, 1 , 1 ) + st4a (:,:, 2 , 1 )) ! Temperature gradient in tropospheric layers anis = 1.0 do k = 3 , nl1 st4a (:,:, k , 2 ) = 0.5 * anis * max ( st4a (:,:, k , 1 ) - st4a (:,:, k - 1 , 1 ), 0.0 ) end do st4a (:,:, kx , 2 ) = anis * max ( ta (:,:, kx ) - st4a (:,:, nl1 , 1 ), 0.0 ) ! Blackbody emission in the stratosphere do k = 1 , 2 st4a (:,:, k , 1 ) = sbc * st4a (:,:, k , 2 ) ** 4.0 st4a (:,:, k , 2 ) = 0.0 end do ! Blackbody emission in the troposphere do k = 3 , kx st3a = sbc * ta (:,:, k ) ** 3.0 st4a (:,:, k , 1 ) = st3a * ta (:,:, k ) st4a (:,:, k , 2 ) = 4.0 * st3a * st4a (:,:, k , 2 ) end do ! 2. Initialization of fluxes fsfcd = 0.0 dfabs = 0.0 ! 3. Emission ad absorption of longwave downward flux. !    For downward emission, a correction term depending on the !    local temperature gradient and on the layer transmissivity is !    added to the average (full-level) emission of each layer. ! 3.1  Stratosphere k = 1 do jb = 1 , 2 do i = 1 , ix do j = 1 , il emis = 1.0 - tau2 ( i , j , k , jb ) brad = fband ( nint ( ta ( i , j , k )), jb ) * ( st4a ( i , j , k , 1 ) + emis * st4a ( i , j , k , 2 )) flux ( i , j , jb ) = emis * brad dfabs ( i , j , k ) = dfabs ( i , j , k ) - flux ( i , j , jb ) end do end do end do flux (:,:, 3 : nband ) = 0.0 ! 3.2  Troposphere do jb = 1 , nband do k = 2 , kx do i = 1 , ix do j = 1 , il emis = 1.0 - tau2 ( i , j , k , jb ) brad = fband ( nint ( ta ( i , j , k )), jb ) * ( st4a ( i , j , k , 1 ) + emis * st4a ( i , j , k , 2 )) dfabs ( i , j , k ) = dfabs ( i , j , k ) + flux ( i , j , jb ) flux ( i , j , jb ) = tau2 ( i , j , k , jb ) * flux ( i , j , jb ) + emis * brad dfabs ( i , j , k ) = dfabs ( i , j , k ) - flux ( i , j , jb ) end do end do end do end do ! 3.3 Surface downward flux do jb = 1 , nband fsfcd = fsfcd + emisfc * flux (:,:, jb ) end do ! 3.4 Correction for \"black\" band (incl. surface reflection) corlw = epslw * emisfc * st4a (:,:, kx , 1 ) dfabs (:,:, kx ) = dfabs (:,:, kx ) - corlw fsfcd = fsfcd + corlw end !> Compute the absorption of upward long-wave radiation fluxes subroutine get_upward_longwave_rad_fluxes ( ta , ts , fsfcd , fsfcu , fsfc , ftop , dfabs ) use geometry , only : dhs use mod_radcon , only : epslw , emisfc , fband , tau2 , st4a , stratc , flux real , intent ( in ) :: ta ( ix , il , kx ) !! Absolute temperature real , intent ( in ) :: ts ( ix , il ) !! Surface temperature real , intent ( in ) :: fsfcd ( ix , il ) !! Downward flux of long-wave radiation at the !! surface real , intent ( in ) :: fsfcu ( ix , il ) !! Surface blackbody emission real , intent ( out ) :: fsfc ( ix , il ) !! Net upward flux of long-wave radiation at the !! surface real , intent ( out ) :: ftop ( ix , il ) !! Outgoing flux of long-wave radiation at the !! top of the atmosphere real , intent ( inout ) :: dfabs ( ix , il , kx ) !! Flux of long-wave radiation absorbed in each !! atmospheric layer integer :: i , j , jb , k real :: brad , corlw1 ( ix , il ), corlw2 ( ix , il ), emis , refsfc refsfc = 1.0 - emisfc fsfc = fsfcu - fsfcd do jb = 1 , nband do i = 1 , ix do j = 1 , il flux ( i , j , jb ) = fband ( nint ( ts ( i , j )), jb ) * fsfcu ( i , j ) + refsfc * flux ( i , j , jb ) end do end do end do ! 4.2  Troposphere ! Correction for \"black\" band dfabs (:,:, kx ) = dfabs (:,:, kx ) + epslw * fsfcu do jb = 1 , nband do k = kx , 2 , - 1 do i = 1 , ix do j = 1 , il emis = 1.0 - tau2 ( i , j , k , jb ) brad = fband ( nint ( ta ( i , j , k )), jb ) * ( st4a ( i , j , k , 1 ) - emis * st4a ( i , j , k , 2 )) dfabs ( i , j , k ) = dfabs ( i , j , k ) + flux ( i , j , jb ) flux ( i , j , jb ) = tau2 ( i , j , k , jb ) * flux ( i , j , jb ) + emis * brad dfabs ( i , j , k ) = dfabs ( i , j , k ) - flux ( i , j , jb ) end do end do end do end do ! 4.3  Stratosphere k = 1 do jb = 1 , 2 do i = 1 , ix do j = 1 , il emis = 1.0 - tau2 ( i , j , k , jb ) brad = fband ( nint ( ta ( i , j , k )), jb ) * ( st4a ( i , j , k , 1 ) - emis * st4a ( i , j , k , 2 )) dfabs ( i , j , k ) = dfabs ( i , j , k ) + flux ( i , j , jb ) flux ( i , j , jb ) = tau2 ( i , j , k , jb ) * flux ( i , j , jb ) + emis * brad dfabs ( i , j , k ) = dfabs ( i , j , k ) - flux ( i , j , jb ) end do end do end do ! Correction for \"black\" band and polar night cooling corlw1 = dhs ( 1 ) * stratc (:,:, 2 ) * st4a (:,:, 1 , 1 ) + stratc (:,:, 1 ) corlw2 = dhs ( 2 ) * stratc (:,:, 2 ) * st4a (:,:, 2 , 1 ) dfabs (:,:, 1 ) = dfabs (:,:, 1 ) - corlw1 dfabs (:,:, 2 ) = dfabs (:,:, 2 ) - corlw2 ftop = corlw1 + corlw2 ! 4.4  Outgoing longwave radiation do jb = 1 , nband ftop = ftop + flux (:,:, jb ) end do end !> Compute energy fractions in longwave bands as a function of temperature subroutine radset use mod_radcon , only : epslw , fband integer :: jb , jtemp real :: eps1 eps1 = 1.0 - epslw do jtemp = 200 , 320 fband ( jtemp , 2 ) = ( 0.148 - 3.0e-6 * ( jtemp - 247 ) ** 2 ) * eps1 fband ( jtemp , 3 ) = ( 0.356 - 5.2e-6 * ( jtemp - 282 ) ** 2 ) * eps1 fband ( jtemp , 4 ) = ( 0.314 + 1.0e-5 * ( jtemp - 315 ) ** 2 ) * eps1 fband ( jtemp , 1 ) = eps1 - ( fband ( jtemp , 2 ) + fband ( jtemp , 3 ) + fband ( jtemp , 4 )) end do do jb = 1 , 4 do jtemp = 100 , 199 fband ( jtemp , jb ) = fband ( 200 , jb ) end do do jtemp = 321 , 400 fband ( jtemp , jb ) = fband ( 320 , jb ) end do end do end end module","tags":"","loc":"sourcefile/longwave_radiation.f90.html"},{"title":"fftpack.f90 – SPEEDY.f90","text":"Contents Subroutines rffti1 rfftb1 rfftf1 radb2 radb3 radb4 radb5 radbg radf2 radf3 radf4 radf5 radfg Source Code fftpack.f90 Source Code subroutine rffti1 ( n , wa , ifac ) implicit none integer , intent ( in ) :: n real , intent ( inout ) :: wa ( * ) integer , intent ( inout ) :: ifac ( * ) integer , save :: ntryh ( 4 ) = ( / 4 , 2 , 3 , 5 / ) integer :: nl , nf , i , j , ib , ido , ii , ip , ipm , is , k1 , l1 , l2 , ld , nfm1 ,& & nq , nr , ntry real :: arg , argh , argld , fi , tpi !***first executable statement  rffti1 nl = n nf = 0 j = 0 101 j = j + 1 if ( j - 4 ) 102 , 102 , 103 102 ntry = ntryh ( j ) go to 104 103 ntry = ntry + 2 104 nq = nl / ntry nr = nl - ntry * nq if ( nr ) 101 , 105 , 101 105 nf = nf + 1 ifac ( nf + 2 ) = ntry nl = nq if ( ntry . ne . 2 ) go to 107 if ( nf . eq . 1 ) go to 107 do 106 i = 2 , nf ib = nf - i + 2 ifac ( ib + 2 ) = ifac ( ib + 1 ) 106 continue ifac ( 3 ) = 2 107 if ( nl . ne . 1 ) go to 104 ifac ( 1 ) = n ifac ( 2 ) = nf tpi = 8. * atan ( 1. ) argh = tpi / n is = 0 nfm1 = nf - 1 l1 = 1 if ( nfm1 . eq . 0 ) return do 110 k1 = 1 , nfm1 ip = ifac ( k1 + 2 ) ld = 0 l2 = l1 * ip ido = n / l2 ipm = ip - 1 do 109 j = 1 , ipm ld = ld + l1 i = is argld = ld * argh fi = 0. do 108 ii = 3 , ido , 2 i = i + 2 fi = fi + 1. arg = fi * argld wa ( i - 1 ) = cos ( arg ) wa ( i ) = sin ( arg ) 108 continue is = is + ido 109 continue l1 = l2 110 continue end subroutine rfftb1 ( n , c , ch , wa , ifac ) implicit none integer , intent ( in ) :: n , ifac ( * ) real , intent ( inout ) :: ch ( * ), c ( * ), wa ( * ) integer :: nf , na , l1 , iw , ip , l2 , ido , idl1 , ix2 , ix3 , ix4 , i , k1 !***first executable statement  rfftb1 nf = ifac ( 2 ) na = 0 l1 = 1 iw = 1 do 116 k1 = 1 , nf ip = ifac ( k1 + 2 ) l2 = ip * l1 ido = n / l2 idl1 = ido * l1 if ( ip . ne . 4 ) go to 103 ix2 = iw + ido ix3 = ix2 + ido if ( na . ne . 0 ) go to 101 call radb4 ( ido , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 )) go to 102 101 call radb4 ( ido , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 )) 102 na = 1 - na go to 115 103 if ( ip . ne . 2 ) go to 106 if ( na . ne . 0 ) go to 104 call radb2 ( ido , l1 , c , ch , wa ( iw )) go to 105 104 call radb2 ( ido , l1 , ch , c , wa ( iw )) 105 na = 1 - na go to 115 106 if ( ip . ne . 3 ) go to 109 ix2 = iw + ido if ( na . ne . 0 ) go to 107 call radb3 ( ido , l1 , c , ch , wa ( iw ), wa ( ix2 )) go to 108 107 call radb3 ( ido , l1 , ch , c , wa ( iw ), wa ( ix2 )) 108 na = 1 - na go to 115 109 if ( ip . ne . 5 ) go to 112 ix2 = iw + ido ix3 = ix2 + ido ix4 = ix3 + ido if ( na . ne . 0 ) go to 110 call radb5 ( ido , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) go to 111 110 call radb5 ( ido , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) 111 na = 1 - na go to 115 112 if ( na . ne . 0 ) go to 113 call radbg ( ido , ip , l1 , idl1 , c , c , c , ch , ch , wa ( iw )) go to 114 113 call radbg ( ido , ip , l1 , idl1 , ch , ch , ch , c , c , wa ( iw )) 114 if ( ido . eq . 1 ) na = 1 - na 115 l1 = l2 iw = iw + ( ip - 1 ) * ido 116 continue if ( na . eq . 0 ) return do 117 i = 1 , n c ( i ) = ch ( i ) 117 continue end subroutine rfftf1 ( n , c , ch , wa , ifac ) implicit none integer , intent ( in ) :: n , ifac ( * ) real , intent ( inout ) :: ch ( * ), wa ( * ) real , intent ( inout ) :: c ( * ) integer :: nf , na , l2 , iw , k1 , kh , ip , l1 , ido , idl1 , ix2 , ix3 , ix4 , i !***FIRST EXECUTABLE STATEMENT  RFFTF1 nf = ifac ( 2 ) na = 1 l2 = n iw = n do 111 k1 = 1 , nf kh = nf - k1 ip = ifac ( kh + 3 ) l1 = l2 / ip ido = n / l2 idl1 = ido * l1 iw = iw - ( ip - 1 ) * ido na = 1 - na if ( ip . ne . 4 ) go to 102 ix2 = iw + ido ix3 = ix2 + ido if ( na . ne . 0 ) go to 101 call radf4 ( ido , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 )) go to 110 101 call radf4 ( ido , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 )) go to 110 102 if ( ip . ne . 2 ) go to 104 if ( na . ne . 0 ) go to 103 call radf2 ( ido , l1 , c , ch , wa ( iw )) go to 110 103 call radf2 ( ido , l1 , ch , c , wa ( iw )) go to 110 104 if ( ip . ne . 3 ) go to 106 ix2 = iw + ido if ( na . ne . 0 ) go to 105 call radf3 ( ido , l1 , c , ch , wa ( iw ), wa ( ix2 )) go to 110 105 call radf3 ( ido , l1 , ch , c , wa ( iw ), wa ( ix2 )) go to 110 106 if ( ip . ne . 5 ) go to 108 ix2 = iw + ido ix3 = ix2 + ido ix4 = ix3 + ido if ( na . ne . 0 ) go to 107 call radf5 ( ido , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) go to 110 107 call radf5 ( ido , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) go to 110 108 if ( ido . eq . 1 ) na = 1 - na if ( na . ne . 0 ) go to 109 call radfg ( ido , ip , l1 , idl1 , c , c , c , ch , ch , wa ( iw )) na = 1 go to 110 109 call radfg ( ido , ip , l1 , idl1 , ch , ch , ch , c , c , wa ( iw )) na = 0 110 l2 = l1 111 continue if ( na . eq . 1 ) return do 112 i = 1 , n c ( i ) = ch ( i ) 112 continue end subroutine radb2 ( ido , l1 , cc , ch , wa1 ) implicit none integer , intent ( in ) :: ido , l1 real , intent ( in ) :: cc ( ido , 2 , * ) real , intent ( inout ) :: ch ( ido , l1 , 2 ), wa1 ( * ) integer :: k , idp2 , ic , i real :: tr2 , ti2 !***FIRST EXECUTABLE STATEMENT  RADB2 do 101 k = 1 , l1 ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + cc ( ido , 2 , k ) ch ( 1 , k , 2 ) = cc ( 1 , 1 , k ) - cc ( ido , 2 , k ) 101 continue if ( ido - 2 ) 107 , 105 , 102 102 idp2 = ido + 2 if (( ido - 1 ) / 2. lt . l1 ) go to 108 do 104 k = 1 , l1 !dir$ ivdep do 103 i = 3 , ido , 2 ic = idp2 - i ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + cc ( ic - 1 , 2 , k ) tr2 = cc ( i - 1 , 1 , k ) - cc ( ic - 1 , 2 , k ) ch ( i , k , 1 ) = cc ( i , 1 , k ) - cc ( ic , 2 , k ) ti2 = cc ( i , 1 , k ) + cc ( ic , 2 , k ) ch ( i - 1 , k , 2 ) = wa1 ( i - 2 ) * tr2 - wa1 ( i - 1 ) * ti2 ch ( i , k , 2 ) = wa1 ( i - 2 ) * ti2 + wa1 ( i - 1 ) * tr2 103 continue 104 continue go to 111 108 do 110 i = 3 , ido , 2 ic = idp2 - i !dir$ ivdep do 109 k = 1 , l1 ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + cc ( ic - 1 , 2 , k ) tr2 = cc ( i - 1 , 1 , k ) - cc ( ic - 1 , 2 , k ) ch ( i , k , 1 ) = cc ( i , 1 , k ) - cc ( ic , 2 , k ) ti2 = cc ( i , 1 , k ) + cc ( ic , 2 , k ) ch ( i - 1 , k , 2 ) = wa1 ( i - 2 ) * tr2 - wa1 ( i - 1 ) * ti2 ch ( i , k , 2 ) = wa1 ( i - 2 ) * ti2 + wa1 ( i - 1 ) * tr2 109 continue 110 continue 111 if ( mod ( ido , 2 ) . eq . 1 ) return 105 do 106 k = 1 , l1 ch ( ido , k , 1 ) = cc ( ido , 1 , k ) + cc ( ido , 1 , k ) ch ( ido , k , 2 ) = - ( cc ( 1 , 2 , k ) + cc ( 1 , 2 , k )) 106 continue 107 return end subroutine radb3 ( ido , l1 , cc , ch , wa1 , wa2 ) implicit none integer , intent ( in ) :: ido , l1 real , intent ( in ) :: cc ( ido , 3 , * ), wa1 ( * ), wa2 ( * ) real , intent ( inout ) :: ch ( ido , l1 , 3 ) integer :: idp2 , ic , i , k real :: taur , taui , tr2 , cr2 , ci3 , ti2 , ci2 , cr3 , dr2 , dr3 , di2 , di3 !***FIRST EXECUTABLE STATEMENT  RADB3 taur = - . 5 taui = . 5 * sqrt ( 3. ) do 101 k = 1 , l1 tr2 = cc ( ido , 2 , k ) + cc ( ido , 2 , k ) cr2 = cc ( 1 , 1 , k ) + taur * tr2 ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + tr2 ci3 = taui * ( cc ( 1 , 3 , k ) + cc ( 1 , 3 , k )) ch ( 1 , k , 2 ) = cr2 - ci3 ch ( 1 , k , 3 ) = cr2 + ci3 101 continue if ( ido . eq . 1 ) return idp2 = ido + 2 if (( ido - 1 ) / 2. lt . l1 ) go to 104 do 103 k = 1 , l1 !dir$ ivdep do 102 i = 3 , ido , 2 ic = idp2 - i tr2 = cc ( i - 1 , 3 , k ) + cc ( ic - 1 , 2 , k ) cr2 = cc ( i - 1 , 1 , k ) + taur * tr2 ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + tr2 ti2 = cc ( i , 3 , k ) - cc ( ic , 2 , k ) ci2 = cc ( i , 1 , k ) + taur * ti2 ch ( i , k , 1 ) = cc ( i , 1 , k ) + ti2 cr3 = taui * ( cc ( i - 1 , 3 , k ) - cc ( ic - 1 , 2 , k )) ci3 = taui * ( cc ( i , 3 , k ) + cc ( ic , 2 , k )) dr2 = cr2 - ci3 dr3 = cr2 + ci3 di2 = ci2 + cr3 di3 = ci2 - cr3 ch ( i - 1 , k , 2 ) = wa1 ( i - 2 ) * dr2 - wa1 ( i - 1 ) * di2 ch ( i , k , 2 ) = wa1 ( i - 2 ) * di2 + wa1 ( i - 1 ) * dr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 2 ) * dr3 - wa2 ( i - 1 ) * di3 ch ( i , k , 3 ) = wa2 ( i - 2 ) * di3 + wa2 ( i - 1 ) * dr3 102 continue 103 continue return 104 do 106 i = 3 , ido , 2 ic = idp2 - i !dir$ ivdep do 105 k = 1 , l1 tr2 = cc ( i - 1 , 3 , k ) + cc ( ic - 1 , 2 , k ) cr2 = cc ( i - 1 , 1 , k ) + taur * tr2 ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + tr2 ti2 = cc ( i , 3 , k ) - cc ( ic , 2 , k ) ci2 = cc ( i , 1 , k ) + taur * ti2 ch ( i , k , 1 ) = cc ( i , 1 , k ) + ti2 cr3 = taui * ( cc ( i - 1 , 3 , k ) - cc ( ic - 1 , 2 , k )) ci3 = taui * ( cc ( i , 3 , k ) + cc ( ic , 2 , k )) dr2 = cr2 - ci3 dr3 = cr2 + ci3 di2 = ci2 + cr3 di3 = ci2 - cr3 ch ( i - 1 , k , 2 ) = wa1 ( i - 2 ) * dr2 - wa1 ( i - 1 ) * di2 ch ( i , k , 2 ) = wa1 ( i - 2 ) * di2 + wa1 ( i - 1 ) * dr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 2 ) * dr3 - wa2 ( i - 1 ) * di3 ch ( i , k , 3 ) = wa2 ( i - 2 ) * di3 + wa2 ( i - 1 ) * dr3 105 continue 106 continue end subroutine radb4 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 ) implicit none integer , intent ( in ) :: ido , l1 real , intent ( in ) :: cc ( ido , 4 , * ), wa1 ( * ), wa2 ( * ), wa3 ( * ) real , intent ( inout ) :: ch ( ido , l1 , 4 ) real :: sqrt2 , tr1 , tr2 , tr3 , tr4 , ti1 , ti2 , ti3 , ti4 , cr3 , ci3 , cr2 , cr4 ,& & ci2 , ci4 integer :: i , k , idp2 , ic !***First executable statement  radb4 sqrt2 = sqrt ( 2. ) do 101 k = 1 , l1 tr1 = cc ( 1 , 1 , k ) - cc ( ido , 4 , k ) tr2 = cc ( 1 , 1 , k ) + cc ( ido , 4 , k ) tr3 = cc ( ido , 2 , k ) + cc ( ido , 2 , k ) tr4 = cc ( 1 , 3 , k ) + cc ( 1 , 3 , k ) ch ( 1 , k , 1 ) = tr2 + tr3 ch ( 1 , k , 2 ) = tr1 - tr4 ch ( 1 , k , 3 ) = tr2 - tr3 ch ( 1 , k , 4 ) = tr1 + tr4 101 continue if ( ido - 2 ) 107 , 105 , 102 102 idp2 = ido + 2 if (( ido - 1 ) / 2. lt . l1 ) go to 108 do 104 k = 1 , l1 !dir$ ivdep do 103 i = 3 , ido , 2 ic = idp2 - i ti1 = cc ( i , 1 , k ) + cc ( ic , 4 , k ) ti2 = cc ( i , 1 , k ) - cc ( ic , 4 , k ) ti3 = cc ( i , 3 , k ) - cc ( ic , 2 , k ) tr4 = cc ( i , 3 , k ) + cc ( ic , 2 , k ) tr1 = cc ( i - 1 , 1 , k ) - cc ( ic - 1 , 4 , k ) tr2 = cc ( i - 1 , 1 , k ) + cc ( ic - 1 , 4 , k ) ti4 = cc ( i - 1 , 3 , k ) - cc ( ic - 1 , 2 , k ) tr3 = cc ( i - 1 , 3 , k ) + cc ( ic - 1 , 2 , k ) ch ( i - 1 , k , 1 ) = tr2 + tr3 cr3 = tr2 - tr3 ch ( i , k , 1 ) = ti2 + ti3 ci3 = ti2 - ti3 cr2 = tr1 - tr4 cr4 = tr1 + tr4 ci2 = ti1 + ti4 ci4 = ti1 - ti4 ch ( i - 1 , k , 2 ) = wa1 ( i - 2 ) * cr2 - wa1 ( i - 1 ) * ci2 ch ( i , k , 2 ) = wa1 ( i - 2 ) * ci2 + wa1 ( i - 1 ) * cr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 2 ) * cr3 - wa2 ( i - 1 ) * ci3 ch ( i , k , 3 ) = wa2 ( i - 2 ) * ci3 + wa2 ( i - 1 ) * cr3 ch ( i - 1 , k , 4 ) = wa3 ( i - 2 ) * cr4 - wa3 ( i - 1 ) * ci4 ch ( i , k , 4 ) = wa3 ( i - 2 ) * ci4 + wa3 ( i - 1 ) * cr4 103 continue 104 continue go to 111 108 do 110 i = 3 , ido , 2 ic = idp2 - i !dir$ ivdep do 109 k = 1 , l1 ti1 = cc ( i , 1 , k ) + cc ( ic , 4 , k ) ti2 = cc ( i , 1 , k ) - cc ( ic , 4 , k ) ti3 = cc ( i , 3 , k ) - cc ( ic , 2 , k ) tr4 = cc ( i , 3 , k ) + cc ( ic , 2 , k ) tr1 = cc ( i - 1 , 1 , k ) - cc ( ic - 1 , 4 , k ) tr2 = cc ( i - 1 , 1 , k ) + cc ( ic - 1 , 4 , k ) ti4 = cc ( i - 1 , 3 , k ) - cc ( ic - 1 , 2 , k ) tr3 = cc ( i - 1 , 3 , k ) + cc ( ic - 1 , 2 , k ) ch ( i - 1 , k , 1 ) = tr2 + tr3 cr3 = tr2 - tr3 ch ( i , k , 1 ) = ti2 + ti3 ci3 = ti2 - ti3 cr2 = tr1 - tr4 cr4 = tr1 + tr4 ci2 = ti1 + ti4 ci4 = ti1 - ti4 ch ( i - 1 , k , 2 ) = wa1 ( i - 2 ) * cr2 - wa1 ( i - 1 ) * ci2 ch ( i , k , 2 ) = wa1 ( i - 2 ) * ci2 + wa1 ( i - 1 ) * cr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 2 ) * cr3 - wa2 ( i - 1 ) * ci3 ch ( i , k , 3 ) = wa2 ( i - 2 ) * ci3 + wa2 ( i - 1 ) * cr3 ch ( i - 1 , k , 4 ) = wa3 ( i - 2 ) * cr4 - wa3 ( i - 1 ) * ci4 ch ( i , k , 4 ) = wa3 ( i - 2 ) * ci4 + wa3 ( i - 1 ) * cr4 109 continue 110 continue 111 if ( mod ( ido , 2 ) . eq . 1 ) return 105 do 106 k = 1 , l1 ti1 = cc ( 1 , 2 , k ) + cc ( 1 , 4 , k ) ti2 = cc ( 1 , 4 , k ) - cc ( 1 , 2 , k ) tr1 = cc ( ido , 1 , k ) - cc ( ido , 3 , k ) tr2 = cc ( ido , 1 , k ) + cc ( ido , 3 , k ) ch ( ido , k , 1 ) = tr2 + tr2 ch ( ido , k , 2 ) = sqrt2 * ( tr1 - ti1 ) ch ( ido , k , 3 ) = ti2 + ti2 ch ( ido , k , 4 ) = - sqrt2 * ( tr1 + ti1 ) 106 continue 107 return end subroutine radb5 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 , wa4 ) implicit none integer , intent ( in ) :: ido , l1 real , intent ( in ) :: cc ( ido , 5 , * ), wa1 ( * ), wa2 ( * ), wa3 ( * ), wa4 ( * ) real , intent ( inout ) :: ch ( ido , l1 , 5 ) real :: pi , tr11 , ti11 , tr12 , ti12 , ti5 , ti4 , tr2 , tr3 , cr2 , cr3 , ci5 , ci4 ,& & ti2 , ti3 , tr5 , tr4 , ci2 , ci3 , cr5 , cr4 , dr3 , dr4 , di3 , di4 , dr5 ,& & dr2 , di5 , di2 integer :: i , k , ic , idp2 !***First executable statement  radb5 pi = 4. * atan ( 1. ) tr11 = sin (. 1 * pi ) ti11 = sin (. 4 * pi ) tr12 = - sin (. 3 * pi ) ti12 = sin (. 2 * pi ) do 101 k = 1 , l1 ti5 = cc ( 1 , 3 , k ) + cc ( 1 , 3 , k ) ti4 = cc ( 1 , 5 , k ) + cc ( 1 , 5 , k ) tr2 = cc ( ido , 2 , k ) + cc ( ido , 2 , k ) tr3 = cc ( ido , 4 , k ) + cc ( ido , 4 , k ) ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + tr2 + tr3 cr2 = cc ( 1 , 1 , k ) + tr11 * tr2 + tr12 * tr3 cr3 = cc ( 1 , 1 , k ) + tr12 * tr2 + tr11 * tr3 ci5 = ti11 * ti5 + ti12 * ti4 ci4 = ti12 * ti5 - ti11 * ti4 ch ( 1 , k , 2 ) = cr2 - ci5 ch ( 1 , k , 3 ) = cr3 - ci4 ch ( 1 , k , 4 ) = cr3 + ci4 ch ( 1 , k , 5 ) = cr2 + ci5 101 continue if ( ido . eq . 1 ) return idp2 = ido + 2 if (( ido - 1 ) / 2. lt . l1 ) go to 104 do 103 k = 1 , l1 !dir$ ivdep do 102 i = 3 , ido , 2 ic = idp2 - i ti5 = cc ( i , 3 , k ) + cc ( ic , 2 , k ) ti2 = cc ( i , 3 , k ) - cc ( ic , 2 , k ) ti4 = cc ( i , 5 , k ) + cc ( ic , 4 , k ) ti3 = cc ( i , 5 , k ) - cc ( ic , 4 , k ) tr5 = cc ( i - 1 , 3 , k ) - cc ( ic - 1 , 2 , k ) tr2 = cc ( i - 1 , 3 , k ) + cc ( ic - 1 , 2 , k ) tr4 = cc ( i - 1 , 5 , k ) - cc ( ic - 1 , 4 , k ) tr3 = cc ( i - 1 , 5 , k ) + cc ( ic - 1 , 4 , k ) ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + tr2 + tr3 ch ( i , k , 1 ) = cc ( i , 1 , k ) + ti2 + ti3 cr2 = cc ( i - 1 , 1 , k ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( i , 1 , k ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( i - 1 , 1 , k ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( i , 1 , k ) + tr12 * ti2 + tr11 * ti3 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 dr3 = cr3 - ci4 dr4 = cr3 + ci4 di3 = ci3 + cr4 di4 = ci3 - cr4 dr5 = cr2 + ci5 dr2 = cr2 - ci5 di5 = ci2 - cr5 di2 = ci2 + cr5 ch ( i - 1 , k , 2 ) = wa1 ( i - 2 ) * dr2 - wa1 ( i - 1 ) * di2 ch ( i , k , 2 ) = wa1 ( i - 2 ) * di2 + wa1 ( i - 1 ) * dr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 2 ) * dr3 - wa2 ( i - 1 ) * di3 ch ( i , k , 3 ) = wa2 ( i - 2 ) * di3 + wa2 ( i - 1 ) * dr3 ch ( i - 1 , k , 4 ) = wa3 ( i - 2 ) * dr4 - wa3 ( i - 1 ) * di4 ch ( i , k , 4 ) = wa3 ( i - 2 ) * di4 + wa3 ( i - 1 ) * dr4 ch ( i - 1 , k , 5 ) = wa4 ( i - 2 ) * dr5 - wa4 ( i - 1 ) * di5 ch ( i , k , 5 ) = wa4 ( i - 2 ) * di5 + wa4 ( i - 1 ) * dr5 102 continue 103 continue return 104 do 106 i = 3 , ido , 2 ic = idp2 - i !dir$ ivdep do 105 k = 1 , l1 ti5 = cc ( i , 3 , k ) + cc ( ic , 2 , k ) ti2 = cc ( i , 3 , k ) - cc ( ic , 2 , k ) ti4 = cc ( i , 5 , k ) + cc ( ic , 4 , k ) ti3 = cc ( i , 5 , k ) - cc ( ic , 4 , k ) tr5 = cc ( i - 1 , 3 , k ) - cc ( ic - 1 , 2 , k ) tr2 = cc ( i - 1 , 3 , k ) + cc ( ic - 1 , 2 , k ) tr4 = cc ( i - 1 , 5 , k ) - cc ( ic - 1 , 4 , k ) tr3 = cc ( i - 1 , 5 , k ) + cc ( ic - 1 , 4 , k ) ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + tr2 + tr3 ch ( i , k , 1 ) = cc ( i , 1 , k ) + ti2 + ti3 cr2 = cc ( i - 1 , 1 , k ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( i , 1 , k ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( i - 1 , 1 , k ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( i , 1 , k ) + tr12 * ti2 + tr11 * ti3 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 dr3 = cr3 - ci4 dr4 = cr3 + ci4 di3 = ci3 + cr4 di4 = ci3 - cr4 dr5 = cr2 + ci5 dr2 = cr2 - ci5 di5 = ci2 - cr5 di2 = ci2 + cr5 ch ( i - 1 , k , 2 ) = wa1 ( i - 2 ) * dr2 - wa1 ( i - 1 ) * di2 ch ( i , k , 2 ) = wa1 ( i - 2 ) * di2 + wa1 ( i - 1 ) * dr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 2 ) * dr3 - wa2 ( i - 1 ) * di3 ch ( i , k , 3 ) = wa2 ( i - 2 ) * di3 + wa2 ( i - 1 ) * dr3 ch ( i - 1 , k , 4 ) = wa3 ( i - 2 ) * dr4 - wa3 ( i - 1 ) * di4 ch ( i , k , 4 ) = wa3 ( i - 2 ) * di4 + wa3 ( i - 1 ) * dr4 ch ( i - 1 , k , 5 ) = wa4 ( i - 2 ) * dr5 - wa4 ( i - 1 ) * di5 ch ( i , k , 5 ) = wa4 ( i - 2 ) * di5 + wa4 ( i - 1 ) * dr5 105 continue 106 continue return end subroutine radbg ( ido , ip , l1 , idl1 , cc , c1 , c2 , ch , ch2 , wa ) implicit none integer , intent ( in ) :: ido , ip , l1 , idl1 real , intent ( in ) :: cc ( ido , ip , * ), wa ( * ) real , intent ( inout ) :: ch ( ido , l1 , * ), c1 ( ido , l1 , * ), c2 ( idl1 , * ),& & ch2 ( idl1 , * ) real :: tpi , arg , dcp , dsp , ar1 , ai1 , ar1h , ds2 , dc2 , ar2 , ai2 , ar2h integer :: idp2 , nbd , ipp2 , ipph , i , j , k , jc , j2 , is , idij , ic , ik ,& & l , lc !***First executable statement  radbg tpi = 8. * atan ( 1. ) arg = tpi / ip dcp = cos ( arg ) dsp = sin ( arg ) idp2 = ido + 2 nbd = ( ido - 1 ) / 2 ipp2 = ip + 2 ipph = ( ip + 1 ) / 2 if ( ido . lt . l1 ) go to 103 do 102 k = 1 , l1 do 101 i = 1 , ido ch ( i , k , 1 ) = cc ( i , 1 , k ) 101 continue 102 continue go to 106 103 do 105 i = 1 , ido do 104 k = 1 , l1 ch ( i , k , 1 ) = cc ( i , 1 , k ) 104 continue 105 continue 106 do 108 j = 2 , ipph jc = ipp2 - j j2 = j + j do 107 k = 1 , l1 ch ( 1 , k , j ) = cc ( ido , j2 - 2 , k ) + cc ( ido , j2 - 2 , k ) ch ( 1 , k , jc ) = cc ( 1 , j2 - 1 , k ) + cc ( 1 , j2 - 1 , k ) 107 continue 108 continue if ( ido . eq . 1 ) go to 116 if ( nbd . lt . l1 ) go to 112 do 111 j = 2 , ipph jc = ipp2 - j do 110 k = 1 , l1 !dir$ ivdep do 109 i = 3 , ido , 2 ic = idp2 - i ch ( i - 1 , k , j ) = cc ( i - 1 , 2 * j - 1 , k ) + cc ( ic - 1 , 2 * j - 2 , k ) ch ( i - 1 , k , jc ) = cc ( i - 1 , 2 * j - 1 , k ) - cc ( ic - 1 , 2 * j - 2 , k ) ch ( i , k , j ) = cc ( i , 2 * j - 1 , k ) - cc ( ic , 2 * j - 2 , k ) ch ( i , k , jc ) = cc ( i , 2 * j - 1 , k ) + cc ( ic , 2 * j - 2 , k ) 109 continue 110 continue 111 continue go to 116 112 do 115 j = 2 , ipph jc = ipp2 - j !dir$ ivdep do 114 i = 3 , ido , 2 ic = idp2 - i do 113 k = 1 , l1 ch ( i - 1 , k , j ) = cc ( i - 1 , 2 * j - 1 , k ) + cc ( ic - 1 , 2 * j - 2 , k ) ch ( i - 1 , k , jc ) = cc ( i - 1 , 2 * j - 1 , k ) - cc ( ic - 1 , 2 * j - 2 , k ) ch ( i , k , j ) = cc ( i , 2 * j - 1 , k ) - cc ( ic , 2 * j - 2 , k ) ch ( i , k , jc ) = cc ( i , 2 * j - 1 , k ) + cc ( ic , 2 * j - 2 , k ) 113 continue 114 continue 115 continue 116 ar1 = 1. ai1 = 0. do 120 l = 2 , ipph lc = ipp2 - l ar1h = dcp * ar1 - dsp * ai1 ai1 = dcp * ai1 + dsp * ar1 ar1 = ar1h do 117 ik = 1 , idl1 c2 ( ik , l ) = ch2 ( ik , 1 ) + ar1 * ch2 ( ik , 2 ) c2 ( ik , lc ) = ai1 * ch2 ( ik , ip ) 117 continue dc2 = ar1 ds2 = ai1 ar2 = ar1 ai2 = ai1 do 119 j = 3 , ipph jc = ipp2 - j ar2h = dc2 * ar2 - ds2 * ai2 ai2 = dc2 * ai2 + ds2 * ar2 ar2 = ar2h do 118 ik = 1 , idl1 c2 ( ik , l ) = c2 ( ik , l ) + ar2 * ch2 ( ik , j ) c2 ( ik , lc ) = c2 ( ik , lc ) + ai2 * ch2 ( ik , jc ) 118 continue 119 continue 120 continue do 122 j = 2 , ipph do 121 ik = 1 , idl1 ch2 ( ik , 1 ) = ch2 ( ik , 1 ) + ch2 ( ik , j ) 121 continue 122 continue do 124 j = 2 , ipph jc = ipp2 - j do 123 k = 1 , l1 ch ( 1 , k , j ) = c1 ( 1 , k , j ) - c1 ( 1 , k , jc ) ch ( 1 , k , jc ) = c1 ( 1 , k , j ) + c1 ( 1 , k , jc ) 123 continue 124 continue if ( ido . eq . 1 ) go to 132 if ( nbd . lt . l1 ) go to 128 do 127 j = 2 , ipph jc = ipp2 - j do 126 k = 1 , l1 !dir$ ivdep do 125 i = 3 , ido , 2 ch ( i - 1 , k , j ) = c1 ( i - 1 , k , j ) - c1 ( i , k , jc ) ch ( i - 1 , k , jc ) = c1 ( i - 1 , k , j ) + c1 ( i , k , jc ) ch ( i , k , j ) = c1 ( i , k , j ) + c1 ( i - 1 , k , jc ) ch ( i , k , jc ) = c1 ( i , k , j ) - c1 ( i - 1 , k , jc ) 125 continue 126 continue 127 continue go to 132 128 do 131 j = 2 , ipph jc = ipp2 - j do 130 i = 3 , ido , 2 do 129 k = 1 , l1 ch ( i - 1 , k , j ) = c1 ( i - 1 , k , j ) - c1 ( i , k , jc ) ch ( i - 1 , k , jc ) = c1 ( i - 1 , k , j ) + c1 ( i , k , jc ) ch ( i , k , j ) = c1 ( i , k , j ) + c1 ( i - 1 , k , jc ) ch ( i , k , jc ) = c1 ( i , k , j ) - c1 ( i - 1 , k , jc ) 129 continue 130 continue 131 continue 132 continue if ( ido . eq . 1 ) return do 133 ik = 1 , idl1 c2 ( ik , 1 ) = ch2 ( ik , 1 ) 133 continue do 135 j = 2 , ip do 134 k = 1 , l1 c1 ( 1 , k , j ) = ch ( 1 , k , j ) 134 continue 135 continue if ( nbd . gt . l1 ) go to 139 is = - ido do 138 j = 2 , ip is = is + ido idij = is do 137 i = 3 , ido , 2 idij = idij + 2 do 136 k = 1 , l1 c1 ( i - 1 , k , j ) = wa ( idij - 1 ) * ch ( i - 1 , k , j ) - wa ( idij ) * ch ( i , k , j ) c1 ( i , k , j ) = wa ( idij - 1 ) * ch ( i , k , j ) + wa ( idij ) * ch ( i - 1 , k , j ) 136 continue 137 continue 138 continue go to 143 139 is = - ido do 142 j = 2 , ip is = is + ido do 141 k = 1 , l1 idij = is !dir$ ivdep do 140 i = 3 , ido , 2 idij = idij + 2 c1 ( i - 1 , k , j ) = wa ( idij - 1 ) * ch ( i - 1 , k , j ) - wa ( idij ) * ch ( i , k , j ) c1 ( i , k , j ) = wa ( idij - 1 ) * ch ( i , k , j ) + wa ( idij ) * ch ( i - 1 , k , j ) 140 continue 141 continue 142 continue 143 return end subroutine radf2 ( ido , l1 , cc , ch , wa1 ) implicit none integer , intent ( in ) :: ido , l1 real , intent ( in ) :: cc ( ido , l1 , 2 ), wa1 ( * ) real , intent ( inout ) :: ch ( ido , 2 , * ) real :: tr2 , ti2 integer :: i , k , idp2 , ic !***First executable statement  radf2 do 101 k = 1 , l1 ch ( 1 , 1 , k ) = cc ( 1 , k , 1 ) + cc ( 1 , k , 2 ) ch ( ido , 2 , k ) = cc ( 1 , k , 1 ) - cc ( 1 , k , 2 ) 101 continue if ( ido - 2 ) 107 , 105 , 102 102 idp2 = ido + 2 if (( ido - 1 ) / 2. lt . l1 ) go to 108 do 104 k = 1 , l1 !dir$ ivdep do 103 i = 3 , ido , 2 ic = idp2 - i tr2 = wa1 ( i - 2 ) * cc ( i - 1 , k , 2 ) + wa1 ( i - 1 ) * cc ( i , k , 2 ) ti2 = wa1 ( i - 2 ) * cc ( i , k , 2 ) - wa1 ( i - 1 ) * cc ( i - 1 , k , 2 ) ch ( i , 1 , k ) = cc ( i , k , 1 ) + ti2 ch ( ic , 2 , k ) = ti2 - cc ( i , k , 1 ) ch ( i - 1 , 1 , k ) = cc ( i - 1 , k , 1 ) + tr2 ch ( ic - 1 , 2 , k ) = cc ( i - 1 , k , 1 ) - tr2 103 continue 104 continue go to 111 108 do 110 i = 3 , ido , 2 ic = idp2 - i !dir$ ivdep do 109 k = 1 , l1 tr2 = wa1 ( i - 2 ) * cc ( i - 1 , k , 2 ) + wa1 ( i - 1 ) * cc ( i , k , 2 ) ti2 = wa1 ( i - 2 ) * cc ( i , k , 2 ) - wa1 ( i - 1 ) * cc ( i - 1 , k , 2 ) ch ( i , 1 , k ) = cc ( i , k , 1 ) + ti2 ch ( ic , 2 , k ) = ti2 - cc ( i , k , 1 ) ch ( i - 1 , 1 , k ) = cc ( i - 1 , k , 1 ) + tr2 ch ( ic - 1 , 2 , k ) = cc ( i - 1 , k , 1 ) - tr2 109 continue 110 continue 111 if ( mod ( ido , 2 ) . eq . 1 ) return 105 do 106 k = 1 , l1 ch ( 1 , 2 , k ) = - cc ( ido , k , 2 ) ch ( ido , 1 , k ) = cc ( ido , k , 1 ) 106 continue 107 return end subroutine radf3 ( ido , l1 , cc , ch , wa1 , wa2 ) implicit none integer , intent ( in ) :: ido , l1 real , intent ( in ) :: cc ( ido , l1 , 3 ), wa1 ( * ), wa2 ( * ) real , intent ( inout ) :: ch ( ido , 3 , * ) real :: taur , taui , cr2 , dr2 , di2 , dr3 , di3 , ci2 , tr2 , ti2 , tr3 , ti3 integer :: i , k , idp2 , ic !***First executable statement  radf3 taur = - . 5 taui = . 5 * sqrt ( 3. ) do 101 k = 1 , l1 cr2 = cc ( 1 , k , 2 ) + cc ( 1 , k , 3 ) ch ( 1 , 1 , k ) = cc ( 1 , k , 1 ) + cr2 ch ( 1 , 3 , k ) = taui * ( cc ( 1 , k , 3 ) - cc ( 1 , k , 2 )) ch ( ido , 2 , k ) = cc ( 1 , k , 1 ) + taur * cr2 101 continue if ( ido . eq . 1 ) return idp2 = ido + 2 if (( ido - 1 ) / 2. lt . l1 ) go to 104 do 103 k = 1 , l1 !dir$ ivdep do 102 i = 3 , ido , 2 ic = idp2 - i dr2 = wa1 ( i - 2 ) * cc ( i - 1 , k , 2 ) + wa1 ( i - 1 ) * cc ( i , k , 2 ) di2 = wa1 ( i - 2 ) * cc ( i , k , 2 ) - wa1 ( i - 1 ) * cc ( i - 1 , k , 2 ) dr3 = wa2 ( i - 2 ) * cc ( i - 1 , k , 3 ) + wa2 ( i - 1 ) * cc ( i , k , 3 ) di3 = wa2 ( i - 2 ) * cc ( i , k , 3 ) - wa2 ( i - 1 ) * cc ( i - 1 , k , 3 ) cr2 = dr2 + dr3 ci2 = di2 + di3 ch ( i - 1 , 1 , k ) = cc ( i - 1 , k , 1 ) + cr2 ch ( i , 1 , k ) = cc ( i , k , 1 ) + ci2 tr2 = cc ( i - 1 , k , 1 ) + taur * cr2 ti2 = cc ( i , k , 1 ) + taur * ci2 tr3 = taui * ( di2 - di3 ) ti3 = taui * ( dr3 - dr2 ) ch ( i - 1 , 3 , k ) = tr2 + tr3 ch ( ic - 1 , 2 , k ) = tr2 - tr3 ch ( i , 3 , k ) = ti2 + ti3 ch ( ic , 2 , k ) = ti3 - ti2 102 continue 103 continue return 104 do 106 i = 3 , ido , 2 ic = idp2 - i !dir$ ivdep do 105 k = 1 , l1 dr2 = wa1 ( i - 2 ) * cc ( i - 1 , k , 2 ) + wa1 ( i - 1 ) * cc ( i , k , 2 ) di2 = wa1 ( i - 2 ) * cc ( i , k , 2 ) - wa1 ( i - 1 ) * cc ( i - 1 , k , 2 ) dr3 = wa2 ( i - 2 ) * cc ( i - 1 , k , 3 ) + wa2 ( i - 1 ) * cc ( i , k , 3 ) di3 = wa2 ( i - 2 ) * cc ( i , k , 3 ) - wa2 ( i - 1 ) * cc ( i - 1 , k , 3 ) cr2 = dr2 + dr3 ci2 = di2 + di3 ch ( i - 1 , 1 , k ) = cc ( i - 1 , k , 1 ) + cr2 ch ( i , 1 , k ) = cc ( i , k , 1 ) + ci2 tr2 = cc ( i - 1 , k , 1 ) + taur * cr2 ti2 = cc ( i , k , 1 ) + taur * ci2 tr3 = taui * ( di2 - di3 ) ti3 = taui * ( dr3 - dr2 ) ch ( i - 1 , 3 , k ) = tr2 + tr3 ch ( ic - 1 , 2 , k ) = tr2 - tr3 ch ( i , 3 , k ) = ti2 + ti3 ch ( ic , 2 , k ) = ti3 - ti2 105 continue 106 continue end subroutine radf4 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 ) implicit none integer , intent ( in ) :: ido , l1 real , intent ( in ) :: cc ( ido , l1 , 4 ), wa1 ( * ), wa2 ( * ), wa3 ( * ) real , intent ( inout ) :: ch ( ido , 4 , * ) real :: hsqt2 , tr1 , tr2 , tr3 , tr4 , cr2 , ci2 , cr3 , ci3 , cr4 , ci4 , ti1 , ti2 ,& & ti3 , ti4 integer :: i , k , ic , idp2 !***First executable statement  radf4 hsqt2 = . 5 * sqrt ( 2. ) do 101 k = 1 , l1 tr1 = cc ( 1 , k , 2 ) + cc ( 1 , k , 4 ) tr2 = cc ( 1 , k , 1 ) + cc ( 1 , k , 3 ) ch ( 1 , 1 , k ) = tr1 + tr2 ch ( ido , 4 , k ) = tr2 - tr1 ch ( ido , 2 , k ) = cc ( 1 , k , 1 ) - cc ( 1 , k , 3 ) ch ( 1 , 3 , k ) = cc ( 1 , k , 4 ) - cc ( 1 , k , 2 ) 101 continue if ( ido - 2 ) 107 , 105 , 102 102 idp2 = ido + 2 if (( ido - 1 ) / 2. lt . l1 ) go to 111 do 104 k = 1 , l1 !dir$ ivdep do 103 i = 3 , ido , 2 ic = idp2 - i cr2 = wa1 ( i - 2 ) * cc ( i - 1 , k , 2 ) + wa1 ( i - 1 ) * cc ( i , k , 2 ) ci2 = wa1 ( i - 2 ) * cc ( i , k , 2 ) - wa1 ( i - 1 ) * cc ( i - 1 , k , 2 ) cr3 = wa2 ( i - 2 ) * cc ( i - 1 , k , 3 ) + wa2 ( i - 1 ) * cc ( i , k , 3 ) ci3 = wa2 ( i - 2 ) * cc ( i , k , 3 ) - wa2 ( i - 1 ) * cc ( i - 1 , k , 3 ) cr4 = wa3 ( i - 2 ) * cc ( i - 1 , k , 4 ) + wa3 ( i - 1 ) * cc ( i , k , 4 ) ci4 = wa3 ( i - 2 ) * cc ( i , k , 4 ) - wa3 ( i - 1 ) * cc ( i - 1 , k , 4 ) tr1 = cr2 + cr4 tr4 = cr4 - cr2 ti1 = ci2 + ci4 ti4 = ci2 - ci4 ti2 = cc ( i , k , 1 ) + ci3 ti3 = cc ( i , k , 1 ) - ci3 tr2 = cc ( i - 1 , k , 1 ) + cr3 tr3 = cc ( i - 1 , k , 1 ) - cr3 ch ( i - 1 , 1 , k ) = tr1 + tr2 ch ( ic - 1 , 4 , k ) = tr2 - tr1 ch ( i , 1 , k ) = ti1 + ti2 ch ( ic , 4 , k ) = ti1 - ti2 ch ( i - 1 , 3 , k ) = ti4 + tr3 ch ( ic - 1 , 2 , k ) = tr3 - ti4 ch ( i , 3 , k ) = tr4 + ti3 ch ( ic , 2 , k ) = tr4 - ti3 103 continue 104 continue go to 110 111 do 109 i = 3 , ido , 2 ic = idp2 - i !dir$ ivdep do 108 k = 1 , l1 cr2 = wa1 ( i - 2 ) * cc ( i - 1 , k , 2 ) + wa1 ( i - 1 ) * cc ( i , k , 2 ) ci2 = wa1 ( i - 2 ) * cc ( i , k , 2 ) - wa1 ( i - 1 ) * cc ( i - 1 , k , 2 ) cr3 = wa2 ( i - 2 ) * cc ( i - 1 , k , 3 ) + wa2 ( i - 1 ) * cc ( i , k , 3 ) ci3 = wa2 ( i - 2 ) * cc ( i , k , 3 ) - wa2 ( i - 1 ) * cc ( i - 1 , k , 3 ) cr4 = wa3 ( i - 2 ) * cc ( i - 1 , k , 4 ) + wa3 ( i - 1 ) * cc ( i , k , 4 ) ci4 = wa3 ( i - 2 ) * cc ( i , k , 4 ) - wa3 ( i - 1 ) * cc ( i - 1 , k , 4 ) tr1 = cr2 + cr4 tr4 = cr4 - cr2 ti1 = ci2 + ci4 ti4 = ci2 - ci4 ti2 = cc ( i , k , 1 ) + ci3 ti3 = cc ( i , k , 1 ) - ci3 tr2 = cc ( i - 1 , k , 1 ) + cr3 tr3 = cc ( i - 1 , k , 1 ) - cr3 ch ( i - 1 , 1 , k ) = tr1 + tr2 ch ( ic - 1 , 4 , k ) = tr2 - tr1 ch ( i , 1 , k ) = ti1 + ti2 ch ( ic , 4 , k ) = ti1 - ti2 ch ( i - 1 , 3 , k ) = ti4 + tr3 ch ( ic - 1 , 2 , k ) = tr3 - ti4 ch ( i , 3 , k ) = tr4 + ti3 ch ( ic , 2 , k ) = tr4 - ti3 108 continue 109 continue 110 if ( mod ( ido , 2 ) . eq . 1 ) return 105 do 106 k = 1 , l1 ti1 = - hsqt2 * ( cc ( ido , k , 2 ) + cc ( ido , k , 4 )) tr1 = hsqt2 * ( cc ( ido , k , 2 ) - cc ( ido , k , 4 )) ch ( ido , 1 , k ) = tr1 + cc ( ido , k , 1 ) ch ( ido , 3 , k ) = cc ( ido , k , 1 ) - tr1 ch ( 1 , 2 , k ) = ti1 - cc ( ido , k , 3 ) ch ( 1 , 4 , k ) = ti1 + cc ( ido , k , 3 ) 106 continue 107 return end subroutine radf5 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 , wa4 ) implicit none integer , intent ( in ) :: ido , l1 real , intent ( in ) :: cc ( ido , l1 , 5 ), wa1 ( * ), wa2 ( * ), wa3 ( * ), wa4 ( * ) real , intent ( inout ) :: ch ( ido , 5 , * ) real :: pi , tr11 , ti11 , tr12 , ti12 , cr2 , cr3 , cr4 , cr5 , ci2 , ci3 , ci4 , ci5 ,& & dr2 , dr3 , dr4 , dr5 , di2 , di3 , di4 , di5 , tr2 , tr3 , tr4 , tr5 , ti2 , ti3 ,& & ti4 , ti5 integer :: i , k , idp2 , ic !***First executable statement  radf5 pi = 4. * atan ( 1. ) tr11 = sin (. 1 * pi ) ti11 = sin (. 4 * pi ) tr12 = - sin (. 3 * pi ) ti12 = sin (. 2 * pi ) do 101 k = 1 , l1 cr2 = cc ( 1 , k , 5 ) + cc ( 1 , k , 2 ) ci5 = cc ( 1 , k , 5 ) - cc ( 1 , k , 2 ) cr3 = cc ( 1 , k , 4 ) + cc ( 1 , k , 3 ) ci4 = cc ( 1 , k , 4 ) - cc ( 1 , k , 3 ) ch ( 1 , 1 , k ) = cc ( 1 , k , 1 ) + cr2 + cr3 ch ( ido , 2 , k ) = cc ( 1 , k , 1 ) + tr11 * cr2 + tr12 * cr3 ch ( 1 , 3 , k ) = ti11 * ci5 + ti12 * ci4 ch ( ido , 4 , k ) = cc ( 1 , k , 1 ) + tr12 * cr2 + tr11 * cr3 ch ( 1 , 5 , k ) = ti12 * ci5 - ti11 * ci4 101 continue if ( ido . eq . 1 ) return idp2 = ido + 2 if (( ido - 1 ) / 2. lt . l1 ) go to 104 do 103 k = 1 , l1 !dir$ ivdep do 102 i = 3 , ido , 2 ic = idp2 - i dr2 = wa1 ( i - 2 ) * cc ( i - 1 , k , 2 ) + wa1 ( i - 1 ) * cc ( i , k , 2 ) di2 = wa1 ( i - 2 ) * cc ( i , k , 2 ) - wa1 ( i - 1 ) * cc ( i - 1 , k , 2 ) dr3 = wa2 ( i - 2 ) * cc ( i - 1 , k , 3 ) + wa2 ( i - 1 ) * cc ( i , k , 3 ) di3 = wa2 ( i - 2 ) * cc ( i , k , 3 ) - wa2 ( i - 1 ) * cc ( i - 1 , k , 3 ) dr4 = wa3 ( i - 2 ) * cc ( i - 1 , k , 4 ) + wa3 ( i - 1 ) * cc ( i , k , 4 ) di4 = wa3 ( i - 2 ) * cc ( i , k , 4 ) - wa3 ( i - 1 ) * cc ( i - 1 , k , 4 ) dr5 = wa4 ( i - 2 ) * cc ( i - 1 , k , 5 ) + wa4 ( i - 1 ) * cc ( i , k , 5 ) di5 = wa4 ( i - 2 ) * cc ( i , k , 5 ) - wa4 ( i - 1 ) * cc ( i - 1 , k , 5 ) cr2 = dr2 + dr5 ci5 = dr5 - dr2 cr5 = di2 - di5 ci2 = di2 + di5 cr3 = dr3 + dr4 ci4 = dr4 - dr3 cr4 = di3 - di4 ci3 = di3 + di4 ch ( i - 1 , 1 , k ) = cc ( i - 1 , k , 1 ) + cr2 + cr3 ch ( i , 1 , k ) = cc ( i , k , 1 ) + ci2 + ci3 tr2 = cc ( i - 1 , k , 1 ) + tr11 * cr2 + tr12 * cr3 ti2 = cc ( i , k , 1 ) + tr11 * ci2 + tr12 * ci3 tr3 = cc ( i - 1 , k , 1 ) + tr12 * cr2 + tr11 * cr3 ti3 = cc ( i , k , 1 ) + tr12 * ci2 + tr11 * ci3 tr5 = ti11 * cr5 + ti12 * cr4 ti5 = ti11 * ci5 + ti12 * ci4 tr4 = ti12 * cr5 - ti11 * cr4 ti4 = ti12 * ci5 - ti11 * ci4 ch ( i - 1 , 3 , k ) = tr2 + tr5 ch ( ic - 1 , 2 , k ) = tr2 - tr5 ch ( i , 3 , k ) = ti2 + ti5 ch ( ic , 2 , k ) = ti5 - ti2 ch ( i - 1 , 5 , k ) = tr3 + tr4 ch ( ic - 1 , 4 , k ) = tr3 - tr4 ch ( i , 5 , k ) = ti3 + ti4 ch ( ic , 4 , k ) = ti4 - ti3 102 continue 103 continue return 104 do 106 i = 3 , ido , 2 ic = idp2 - i !dir$ ivdep do 105 k = 1 , l1 dr2 = wa1 ( i - 2 ) * cc ( i - 1 , k , 2 ) + wa1 ( i - 1 ) * cc ( i , k , 2 ) di2 = wa1 ( i - 2 ) * cc ( i , k , 2 ) - wa1 ( i - 1 ) * cc ( i - 1 , k , 2 ) dr3 = wa2 ( i - 2 ) * cc ( i - 1 , k , 3 ) + wa2 ( i - 1 ) * cc ( i , k , 3 ) di3 = wa2 ( i - 2 ) * cc ( i , k , 3 ) - wa2 ( i - 1 ) * cc ( i - 1 , k , 3 ) dr4 = wa3 ( i - 2 ) * cc ( i - 1 , k , 4 ) + wa3 ( i - 1 ) * cc ( i , k , 4 ) di4 = wa3 ( i - 2 ) * cc ( i , k , 4 ) - wa3 ( i - 1 ) * cc ( i - 1 , k , 4 ) dr5 = wa4 ( i - 2 ) * cc ( i - 1 , k , 5 ) + wa4 ( i - 1 ) * cc ( i , k , 5 ) di5 = wa4 ( i - 2 ) * cc ( i , k , 5 ) - wa4 ( i - 1 ) * cc ( i - 1 , k , 5 ) cr2 = dr2 + dr5 ci5 = dr5 - dr2 cr5 = di2 - di5 ci2 = di2 + di5 cr3 = dr3 + dr4 ci4 = dr4 - dr3 cr4 = di3 - di4 ci3 = di3 + di4 ch ( i - 1 , 1 , k ) = cc ( i - 1 , k , 1 ) + cr2 + cr3 ch ( i , 1 , k ) = cc ( i , k , 1 ) + ci2 + ci3 tr2 = cc ( i - 1 , k , 1 ) + tr11 * cr2 + tr12 * cr3 ti2 = cc ( i , k , 1 ) + tr11 * ci2 + tr12 * ci3 tr3 = cc ( i - 1 , k , 1 ) + tr12 * cr2 + tr11 * cr3 ti3 = cc ( i , k , 1 ) + tr12 * ci2 + tr11 * ci3 tr5 = ti11 * cr5 + ti12 * cr4 ti5 = ti11 * ci5 + ti12 * ci4 tr4 = ti12 * cr5 - ti11 * cr4 ti4 = ti12 * ci5 - ti11 * ci4 ch ( i - 1 , 3 , k ) = tr2 + tr5 ch ( ic - 1 , 2 , k ) = tr2 - tr5 ch ( i , 3 , k ) = ti2 + ti5 ch ( ic , 2 , k ) = ti5 - ti2 ch ( i - 1 , 5 , k ) = tr3 + tr4 ch ( ic - 1 , 4 , k ) = tr3 - tr4 ch ( i , 5 , k ) = ti3 + ti4 ch ( ic , 4 , k ) = ti4 - ti3 105 continue 106 continue end subroutine radfg ( ido , ip , l1 , idl1 , cc , c1 , c2 , ch , ch2 , wa ) implicit none integer , intent ( in ) :: ido , ip , l1 , idl1 real , intent ( in ) :: wa ( * ) real , intent ( inout ) :: ch ( ido , l1 , * ), cc ( ido , ip , * ), c1 ( ido , l1 , * ),& & c2 ( idl1 , * ), ch2 ( idl1 , * ) real :: tpi , arg , dcp , dsp , ar1h , ar2h , ai1 , ai2 , ar1 , ar2 , dc2 , ds2 integer :: ipph , ipp2 , idp2 , nbd , is , ik , j , j2 , jc , i , ic , idij , k ,& & l , lc !***First executable statement  radfg tpi = 8. * atan ( 1. ) arg = tpi / ip dcp = cos ( arg ) dsp = sin ( arg ) ipph = ( ip + 1 ) / 2 ipp2 = ip + 2 idp2 = ido + 2 nbd = ( ido - 1 ) / 2 if ( ido . eq . 1 ) go to 119 do 101 ik = 1 , idl1 ch2 ( ik , 1 ) = c2 ( ik , 1 ) 101 continue do 103 j = 2 , ip do 102 k = 1 , l1 ch ( 1 , k , j ) = c1 ( 1 , k , j ) 102 continue 103 continue if ( nbd . gt . l1 ) go to 107 is = - ido do 106 j = 2 , ip is = is + ido idij = is do 105 i = 3 , ido , 2 idij = idij + 2 do 104 k = 1 , l1 ch ( i - 1 , k , j ) = wa ( idij - 1 ) * c1 ( i - 1 , k , j ) + wa ( idij ) * c1 ( i , k , j ) ch ( i , k , j ) = wa ( idij - 1 ) * c1 ( i , k , j ) - wa ( idij ) * c1 ( i - 1 , k , j ) 104 continue 105 continue 106 continue go to 111 107 is = - ido do 110 j = 2 , ip is = is + ido do 109 k = 1 , l1 idij = is !dir$ ivdep do 108 i = 3 , ido , 2 idij = idij + 2 ch ( i - 1 , k , j ) = wa ( idij - 1 ) * c1 ( i - 1 , k , j ) + wa ( idij ) * c1 ( i , k , j ) ch ( i , k , j ) = wa ( idij - 1 ) * c1 ( i , k , j ) - wa ( idij ) * c1 ( i - 1 , k , j ) 108 continue 109 continue 110 continue 111 if ( nbd . lt . l1 ) go to 115 do 114 j = 2 , ipph jc = ipp2 - j do 113 k = 1 , l1 !dir$ ivdep do 112 i = 3 , ido , 2 c1 ( i - 1 , k , j ) = ch ( i - 1 , k , j ) + ch ( i - 1 , k , jc ) c1 ( i - 1 , k , jc ) = ch ( i , k , j ) - ch ( i , k , jc ) c1 ( i , k , j ) = ch ( i , k , j ) + ch ( i , k , jc ) c1 ( i , k , jc ) = ch ( i - 1 , k , jc ) - ch ( i - 1 , k , j ) 112 continue 113 continue 114 continue go to 121 115 do 118 j = 2 , ipph jc = ipp2 - j do 117 i = 3 , ido , 2 do 116 k = 1 , l1 c1 ( i - 1 , k , j ) = ch ( i - 1 , k , j ) + ch ( i - 1 , k , jc ) c1 ( i - 1 , k , jc ) = ch ( i , k , j ) - ch ( i , k , jc ) c1 ( i , k , j ) = ch ( i , k , j ) + ch ( i , k , jc ) c1 ( i , k , jc ) = ch ( i - 1 , k , jc ) - ch ( i - 1 , k , j ) 116 continue 117 continue 118 continue go to 121 119 do 120 ik = 1 , idl1 c2 ( ik , 1 ) = ch2 ( ik , 1 ) 120 continue 121 do 123 j = 2 , ipph jc = ipp2 - j do 122 k = 1 , l1 c1 ( 1 , k , j ) = ch ( 1 , k , j ) + ch ( 1 , k , jc ) c1 ( 1 , k , jc ) = ch ( 1 , k , jc ) - ch ( 1 , k , j ) 122 continue 123 continue ! ar1 = 1. ai1 = 0. do 127 l = 2 , ipph lc = ipp2 - l ar1h = dcp * ar1 - dsp * ai1 ai1 = dcp * ai1 + dsp * ar1 ar1 = ar1h do 124 ik = 1 , idl1 ch2 ( ik , l ) = c2 ( ik , 1 ) + ar1 * c2 ( ik , 2 ) ch2 ( ik , lc ) = ai1 * c2 ( ik , ip ) 124 continue dc2 = ar1 ds2 = ai1 ar2 = ar1 ai2 = ai1 do 126 j = 3 , ipph jc = ipp2 - j ar2h = dc2 * ar2 - ds2 * ai2 ai2 = dc2 * ai2 + ds2 * ar2 ar2 = ar2h do 125 ik = 1 , idl1 ch2 ( ik , l ) = ch2 ( ik , l ) + ar2 * c2 ( ik , j ) ch2 ( ik , lc ) = ch2 ( ik , lc ) + ai2 * c2 ( ik , jc ) 125 continue 126 continue 127 continue do 129 j = 2 , ipph do 128 ik = 1 , idl1 ch2 ( ik , 1 ) = ch2 ( ik , 1 ) + c2 ( ik , j ) 128 continue 129 continue ! if ( ido . lt . l1 ) go to 132 do 131 k = 1 , l1 do 130 i = 1 , ido cc ( i , 1 , k ) = ch ( i , k , 1 ) 130 continue 131 continue go to 135 132 do 134 i = 1 , ido do 133 k = 1 , l1 cc ( i , 1 , k ) = ch ( i , k , 1 ) 133 continue 134 continue 135 do 137 j = 2 , ipph jc = ipp2 - j j2 = j + j do 136 k = 1 , l1 cc ( ido , j2 - 2 , k ) = ch ( 1 , k , j ) cc ( 1 , j2 - 1 , k ) = ch ( 1 , k , jc ) 136 continue 137 continue if ( ido . eq . 1 ) return if ( nbd . lt . l1 ) go to 141 do 140 j = 2 , ipph jc = ipp2 - j j2 = j + j do 139 k = 1 , l1 !dir$ ivdep do 138 i = 3 , ido , 2 ic = idp2 - i cc ( i - 1 , j2 - 1 , k ) = ch ( i - 1 , k , j ) + ch ( i - 1 , k , jc ) cc ( ic - 1 , j2 - 2 , k ) = ch ( i - 1 , k , j ) - ch ( i - 1 , k , jc ) cc ( i , j2 - 1 , k ) = ch ( i , k , j ) + ch ( i , k , jc ) cc ( ic , j2 - 2 , k ) = ch ( i , k , jc ) - ch ( i , k , j ) 138 continue 139 continue 140 continue return 141 do 144 j = 2 , ipph jc = ipp2 - j j2 = j + j do 143 i = 3 , ido , 2 ic = idp2 - i do 142 k = 1 , l1 cc ( i - 1 , j2 - 1 , k ) = ch ( i - 1 , k , j ) + ch ( i - 1 , k , jc ) cc ( ic - 1 , j2 - 2 , k ) = ch ( i - 1 , k , j ) - ch ( i - 1 , k , jc ) cc ( i , j2 - 1 , k ) = ch ( i , k , j ) + ch ( i , k , jc ) cc ( ic , j2 - 2 , k ) = ch ( i , k , jc ) - ch ( i , k , j ) 142 continue 143 continue 144 continue return end","tags":"","loc":"sourcefile/fftpack.f90.html"},{"title":"forcing.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~forcing.f90~~EfferentGraph sourcefile~forcing.f90 forcing.f90 sourcefile~date.f90 date.f90 sourcefile~forcing.f90->sourcefile~date.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~forcing.f90->sourcefile~land_model.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~forcing.f90->sourcefile~surface_fluxes.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~forcing.f90->sourcefile~physical_constants.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~forcing.f90->sourcefile~boundaries.f90 sourcefile~horizontal_diffusion.f90 horizontal_diffusion.f90 sourcefile~forcing.f90->sourcefile~horizontal_diffusion.f90 sourcefile~mod_radcon.f90 mod_radcon.f90 sourcefile~forcing.f90->sourcefile~mod_radcon.f90 sourcefile~longwave_radiation.f90 longwave_radiation.f90 sourcefile~forcing.f90->sourcefile~longwave_radiation.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~forcing.f90->sourcefile~sea_model.f90 sourcefile~humidity.f90 humidity.f90 sourcefile~forcing.f90->sourcefile~humidity.f90 sourcefile~params.f90 params.f90 sourcefile~forcing.f90->sourcefile~params.f90 sourcefile~shortwave_radiation.f90 shortwave_radiation.f90 sourcefile~forcing.f90->sourcefile~shortwave_radiation.f90 sourcefile~dynamical_constants.f90 dynamical_constants.f90 sourcefile~forcing.f90->sourcefile~dynamical_constants.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~forcing.f90->sourcefile~spectral.f90 sourcefile~date.f90->sourcefile~params.f90 sourcefile~land_model.f90->sourcefile~date.f90 sourcefile~land_model.f90->sourcefile~boundaries.f90 sourcefile~land_model.f90->sourcefile~params.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~land_model.f90->sourcefile~input_output.f90 sourcefile~auxiliaries.f90 auxiliaries.f90 sourcefile~land_model.f90->sourcefile~auxiliaries.f90 sourcefile~interpolation.f90 interpolation.f90 sourcefile~land_model.f90->sourcefile~interpolation.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 sourcefile~surface_fluxes.f90->sourcefile~physical_constants.f90 sourcefile~surface_fluxes.f90->sourcefile~mod_radcon.f90 sourcefile~surface_fluxes.f90->sourcefile~humidity.f90 sourcefile~surface_fluxes.f90->sourcefile~params.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~surface_fluxes.f90->sourcefile~geometry.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 sourcefile~boundaries.f90->sourcefile~physical_constants.f90 sourcefile~boundaries.f90->sourcefile~params.f90 sourcefile~boundaries.f90->sourcefile~spectral.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~horizontal_diffusion.f90->sourcefile~physical_constants.f90 sourcefile~horizontal_diffusion.f90->sourcefile~params.f90 sourcefile~horizontal_diffusion.f90->sourcefile~dynamical_constants.f90 sourcefile~horizontal_diffusion.f90->sourcefile~geometry.f90 sourcefile~mod_radcon.f90->sourcefile~params.f90 sourcefile~longwave_radiation.f90->sourcefile~physical_constants.f90 sourcefile~longwave_radiation.f90->sourcefile~mod_radcon.f90 sourcefile~longwave_radiation.f90->sourcefile~params.f90 sourcefile~longwave_radiation.f90->sourcefile~geometry.f90 sourcefile~sea_model.f90->sourcefile~date.f90 sourcefile~sea_model.f90->sourcefile~physical_constants.f90 sourcefile~sea_model.f90->sourcefile~boundaries.f90 sourcefile~sea_model.f90->sourcefile~mod_radcon.f90 sourcefile~sea_model.f90->sourcefile~params.f90 sourcefile~sea_model.f90->sourcefile~input_output.f90 sourcefile~sea_model.f90->sourcefile~auxiliaries.f90 sourcefile~sea_model.f90->sourcefile~interpolation.f90 sourcefile~sea_model.f90->sourcefile~geometry.f90 sourcefile~humidity.f90->sourcefile~params.f90 sourcefile~shortwave_radiation.f90->sourcefile~mod_radcon.f90 sourcefile~shortwave_radiation.f90->sourcefile~params.f90 sourcefile~shortwave_radiation.f90->sourcefile~geometry.f90 sourcefile~spectral.f90->sourcefile~physical_constants.f90 sourcefile~spectral.f90->sourcefile~params.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~input_output.f90->sourcefile~date.f90 sourcefile~input_output.f90->sourcefile~physical_constants.f90 sourcefile~input_output.f90->sourcefile~params.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~input_output.f90->sourcefile~geometry.f90 sourcefile~auxiliaries.f90->sourcefile~params.f90 sourcefile~interpolation.f90->sourcefile~date.f90 sourcefile~interpolation.f90->sourcefile~params.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90->sourcefile~params.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~fourier.f90->sourcefile~params.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 var pansourcefileforcingf90EfferentGraph = svgPanZoom('#sourcefileforcingf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~forcing.f90~~AfferentGraph sourcefile~forcing.f90 forcing.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules forcing Source Code forcing.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !  date: 01/05/2019 !  For setting all time-dependent forcing fields. module forcing implicit none private public set_forcing contains !> Compute forcing fields for the current date and correction terms for !  horizontal diffusion subroutine set_forcing ( imode ) use dynamical_constants , only : refrh1 use params use horizontal_diffusion , only : tcorh , qcorh use physical_constants , only : rd use boundaries , only : phis0 , alb0 use surface_fluxes , only : set_orog_land_sfc_drag use date , only : model_datetime , tyear use land_model , only : stl_am , snowd_am , fmask_l , sd2sc use sea_model , only : fmask_s , sst_am , sice_am use mod_radcon , only : ablco2_ref , albsea , albice , snowc , albsn , alb_l , alb_s , albsfc use shortwave_radiation , only : get_zonal_average_fields , ablco2 , increase_co2 use longwave_radiation , only : radset use humidity , only : get_qsat use spectral , only : grid_to_spec integer , intent ( in ) :: imode !! Mode -> 0 = initialization step, 1 = daily update real , dimension ( ix , il ) :: corh , tsfc , tref , psfc , qsfc , qref real :: gamlat ( il ) real :: del_co2 , pexp integer :: i , j , iyear_ref ! time variables for interpolation are set by newdate ! 1. time-independent parts of physical parametrizations if ( imode == 0 ) then call radset call set_orog_land_sfc_drag ( phis0 ) ablco2_ref = ablco2 end if ! 2. daily-mean radiative forcing ! incoming solar radiation call get_zonal_average_fields ( tyear ) ! total surface albedo do i = 1 , ix do j = 1 , il snowc ( i , j ) = min ( 1.0 , snowd_am ( i , j ) / sd2sc ) alb_l ( i , j ) = alb0 ( i , j ) + snowc ( i , j ) * ( albsn - alb0 ( i , j )) alb_s ( i , j ) = albsea + sice_am ( i , j ) * ( albice - albsea ) albsfc ( i , j ) = alb_s ( i , j ) + fmask_l ( i , j ) * ( alb_l ( i , j ) - alb_s ( i , j )) end do end do ! linear trend of co2 absorptivity (del_co2: rate of change per year) iyear_ref = 1950 del_co2 = 0.005 ! del_co2   = 0.0033 if ( increase_co2 ) then ablco2 = ablco2_ref * exp ( del_co2 * ( model_datetime % year + tyear - iyear_ref )) end if ! 3. temperature correction term for horizontal diffusion call setgam ( gamlat ) do j = 1 , il do i = 1 , ix corh ( i , j ) = gamlat ( j ) * phis0 ( i , j ) end do end do tcorh = grid_to_spec ( corh ) ! 4. humidity correction term for horizontal diffusion do j = 1 , il pexp = 1. / ( rd * gamlat ( j )) do i = 1 , ix tsfc ( i , j ) = fmask_l ( i , j ) * stl_am ( i , j ) + fmask_s ( i , j ) * sst_am ( i , j ) tref ( i , j ) = tsfc ( i , j ) + corh ( i , j ) psfc ( i , j ) = ( tsfc ( i , j ) / tref ( i , j )) ** pexp end do end do qref = get_qsat ( tref , psfc / psfc , - 1.0 ) qsfc = get_qsat ( tsfc , psfc , 1.0 ) corh = refrh1 * ( qref - qsfc ) qcorh = grid_to_spec ( corh ) end subroutine !> Compute reference lapse rate as a function of latitude and date subroutine setgam ( gamlat ) use dynamical_constants , only : gamma use params use physical_constants , only : grav real , intent ( inout ) :: gamlat ( il ) !! The reference lapse rate integer :: j gamlat ( 1 ) = gamma / ( 100 0. * grav ) do j = 2 , il gamlat ( j ) = gamlat ( 1 ) end do end subroutine end module","tags":"","loc":"sourcefile/forcing.f90.html"},{"title":"implicit.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~implicit.f90~~EfferentGraph sourcefile~implicit.f90 implicit.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~implicit.f90->sourcefile~physical_constants.f90 sourcefile~matrix_inversion.f90 matrix_inversion.f90 sourcefile~implicit.f90->sourcefile~matrix_inversion.f90 sourcefile~horizontal_diffusion.f90 horizontal_diffusion.f90 sourcefile~implicit.f90->sourcefile~horizontal_diffusion.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~implicit.f90->sourcefile~geometry.f90 sourcefile~params.f90 params.f90 sourcefile~implicit.f90->sourcefile~params.f90 sourcefile~dynamical_constants.f90 dynamical_constants.f90 sourcefile~implicit.f90->sourcefile~dynamical_constants.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 sourcefile~horizontal_diffusion.f90->sourcefile~physical_constants.f90 sourcefile~horizontal_diffusion.f90->sourcefile~geometry.f90 sourcefile~horizontal_diffusion.f90->sourcefile~params.f90 sourcefile~horizontal_diffusion.f90->sourcefile~dynamical_constants.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 var pansourcefileimplicitf90EfferentGraph = svgPanZoom('#sourcefileimplicitf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~implicit.f90~~AfferentGraph sourcefile~implicit.f90 implicit.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~implicit.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~time_stepping.f90->sourcefile~implicit.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules implicit Source Code implicit.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !  date: 08/05/2019 !  For initializing and performing implicit computations. module implicit use params implicit none private public initialize_implicit , implicit_terms public tref , tref2 , tref3 real , dimension ( kx ) :: tref ! Temperature profile for semi-implicit scheme real , dimension ( kx ) :: tref1 ! Gas constant * tref real , dimension ( kx ) :: tref2 ! akap * tref real , dimension ( kx ) :: tref3 ! Full sigma-levels * tref real , dimension ( kx , kx ) :: xa , xb , xc , xd , xe real , dimension ( kx , kx , mx + nx + 1 ) :: xf , xj real :: dhsx ( kx ), elz ( mx , nx ) contains !> Initialize constants for implicit computation of horizontal diffusion and !  gravity waves. ! !  Initialize_implicit initializes constants for the implicit gravity wave computation. !  It is assumed that that all implicit steps are of length 2*delt and use !  the forward/backward parameter alph. initialize_implicit has to be re-called !  whenever either of these two parameters is changed. initialize_implicit should !  be called even if the explicit option is chosen for the gravity wave !  terms (the reference state temperature tref is subtracted from some !  terms anyway to reduce roundoff error; also the constants needed for !  the biharmonic diffusion, which is assumed always to be backwards !  implicit, are defined in initialize_implicit). subroutine initialize_implicit ( dt ) use dynamical_constants , only : gamma use physical_constants , only : akap , rgas , grav , rearth use geometry , only : hsg , dhs , fsg , fsgr use horizontal_diffusion , only : dmp , dmpd , dmps , dmp1 , dmp1d , dmp1s use matrix_inversion , only : inv real , intent ( in ) :: dt !! Time step real :: dsum ( kx ), ya ( kx , kx ) integer :: indx ( kx ), m , n , k , k1 , k2 , l real :: rgam , xi , xxi , xxx ! 1. Constants for backwards implicit biharmonic diffusion do m = 1 , mx do n = 1 , nx dmp1 ( m , n ) = 1. / ( 1. + dmp ( m , n ) * dt ) dmp1d ( m , n ) = 1. / ( 1. + dmpd ( m , n ) * dt ) dmp1s ( m , n ) = 1. / ( 1. + dmps ( m , n ) * dt ) end do end do ! 1. Constants for implicit gravity wave computation ! reference atmosphere, function of sigma only rgam = rgas * gamma / ( 100 0. * grav ) do k = 1 , kx tref ( k ) = 28 8. * max ( 0.2 , fsg ( k )) ** rgam tref1 ( k ) = rgas * tref ( k ) tref2 ( k ) = akap * tref ( k ) tref3 ( k ) = fsgr ( k ) * tref ( k ) end do ! Other constants xi = dt * alph xxi = xi / ( rearth * rearth ) dhsx = xi * dhs do n = 1 , nx do m = 1 , mx elz ( m , n ) = float ( m + n - 2 ) * float ( m + n - 1 ) * xxi end do end do !T(K) = TEX(K)+YA(K,K')*D(K') + XA(K,K')*SIG(K') xa (: kx ,: kx - 1 ) = 0.0 do k = 1 , kx do k1 = 1 , kx ya ( k , k1 ) =- akap * tref ( k ) * dhs ( k1 ) end do end do do k = 2 , kx xa ( k , k - 1 ) = 0.5 * ( akap * tref ( k ) / fsg ( k ) - ( tref ( k ) - tref ( k - 1 )) / dhs ( k )) end do do k = 1 , kx - 1 xa ( k , k ) = 0.5 * ( akap * tref ( k ) / fsg ( k ) - ( tref ( k + 1 ) - tref ( k )) / dhs ( k )) end do !sig(k)=xb(k,k')*d(k') dsum ( 1 ) = dhs ( 1 ) do k = 2 , kx dsum ( k ) = dsum ( k - 1 ) + dhs ( k ) end do do k = 1 , kx - 1 do k1 = 1 , kx xb ( k , k1 ) = dhs ( k1 ) * dsum ( k ) if ( k1 . le . k ) xb ( k , k1 ) = xb ( k , k1 ) - dhs ( k1 ) end do end do !t(k)=tex(k)+xc(k,k')*d(k') do k = 1 , kx do k1 = 1 , kx xc ( k , k1 ) = ya ( k , k1 ) do k2 = 1 , kx - 1 xc ( k , k1 ) = xc ( k , k1 ) + xa ( k , k2 ) * xb ( k2 , k1 ) end do end do end do !P(K)=XD(K,K')*T(K') xd = 0.0 do k = 1 , kx do k1 = k + 1 , kx xd ( k , k1 ) = rgas * log ( hsg ( k1 + 1 ) / hsg ( k1 )) end do end do do k = 1 , kx xd ( k , k ) = rgas * log ( hsg ( k + 1 ) / fsg ( k )) end do !P(K)=YE(K)+XE(K,K')*D(K') do k = 1 , kx do k1 = 1 , kx xe ( k , k1 ) = 0. do k2 = 1 , kx xe ( k , k1 ) = xe ( k , k1 ) + xd ( k , k2 ) * xc ( k2 , k1 ) end do end do end do do l = 1 , mx + nx + 1 xxx = ( float ( l ) * float ( l + 1 )) / ( rearth * rearth ) do k = 1 , kx do k1 = 1 , kx xf ( k , k1 , l ) = xi * xi * xxx * ( rgas * tref ( k ) * dhs ( k1 ) - xe ( k , k1 )) end do end do do k = 1 , kx xf ( k , k , l ) = xf ( k , k , l ) + 1. end do end do do l = 1 , mx + nx + 1 call inv ( xf ( 1 , 1 , l ), xj ( 1 , 1 , l ), indx , kx ) end do do k = 1 , kx do k1 = 1 , kx xc ( k , k1 ) = xc ( k , k1 ) * xi end do end do end subroutine !> Correct tendencies for implicit gravity wave model subroutine implicit_terms ( divdt , tdt , psdt ) complex , intent ( inout ) :: divdt ( mx , nx , kx ) !! Divergence tendency complex , intent ( inout ) :: tdt ( mx , nx , kx ) !! Temperature tendency complex , intent ( inout ) :: psdt ( mx , nx ) !! log(surface pressure) tendency complex :: ye ( mx , nx , kx ), yf ( mx , nx , kx ) integer :: k1 , k , m , n ye (:,:,:) = ( 0.0 , 0.0 ) do k1 = 1 , kx do k = 1 , kx ye (:,:, k ) = ye (:,:, k ) + xd ( k , k1 ) * tdt (:,:, k1 ) end do end do do k = 1 , kx ye (:,:, k ) = ye (:,:, k ) + tref1 ( k ) * psdt end do do k = 1 , kx do m = 1 , mx do n = 1 , nx yf ( m , n , k ) = divdt ( m , n , k ) + elz ( m , n ) * ye ( m , n , k ) end do end do end do divdt (:,:,:) = ( 0.0 , 0.0 ) do n = 1 , nx do m = 1 , mx if (( m + n - 2 ) /= 0 ) then do k1 = 1 , kx divdt ( m , n ,:) = divdt ( m , n ,:) + xj (:, k1 , m + n - 2 ) * yf ( m , n , k1 ) end do endif end do end do do k = 1 , kx psdt = psdt - divdt (:,:, k ) * dhsx ( k ) end do do k = 1 , kx do k1 = 1 , kx tdt (:,:, k ) = tdt (:,:, k ) + xc ( k , k1 ) * divdt (:,:, k1 ) end do end do end end module","tags":"","loc":"sourcefile/implicit.f90.html"},{"title":"boundaries.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~boundaries.f90~~EfferentGraph sourcefile~boundaries.f90 boundaries.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~params.f90 params.f90 sourcefile~boundaries.f90->sourcefile~params.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~boundaries.f90->sourcefile~spectral.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~boundaries.f90->sourcefile~physical_constants.f90 sourcefile~input_output.f90->sourcefile~params.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~input_output.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~input_output.f90->sourcefile~geometry.f90 sourcefile~date.f90 date.f90 sourcefile~input_output.f90->sourcefile~date.f90 sourcefile~spectral.f90->sourcefile~params.f90 sourcefile~spectral.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 sourcefile~legendre.f90->sourcefile~params.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~date.f90->sourcefile~params.f90 sourcefile~fourier.f90->sourcefile~params.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 var pansourcefileboundariesf90EfferentGraph = svgPanZoom('#sourcefileboundariesf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~boundaries.f90~~AfferentGraph sourcefile~boundaries.f90 boundaries.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~land_model.f90->sourcefile~boundaries.f90 sourcefile~prognostics.f90 prognostics.f90 sourcefile~prognostics.f90->sourcefile~boundaries.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~forcing.f90->sourcefile~boundaries.f90 sourcefile~forcing.f90->sourcefile~land_model.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~forcing.f90->sourcefile~sea_model.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~forcing.f90->sourcefile~surface_fluxes.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~initialization.f90->sourcefile~boundaries.f90 sourcefile~initialization.f90->sourcefile~prognostics.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~physics.f90 physics.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~initialization.f90->sourcefile~sea_model.f90 sourcefile~coupler.f90 coupler.f90 sourcefile~initialization.f90->sourcefile~coupler.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~physics.f90->sourcefile~boundaries.f90 sourcefile~physics.f90->sourcefile~land_model.f90 sourcefile~physics.f90->sourcefile~sea_model.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~sea_model.f90->sourcefile~boundaries.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~prognostics.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~speedy.f90->sourcefile~coupler.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 sourcefile~coupler.f90->sourcefile~land_model.f90 sourcefile~coupler.f90->sourcefile~sea_model.f90 sourcefile~time_stepping.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 sourcefile~tendencies.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 var pansourcefileboundariesf90AfferentGraph = svgPanZoom('#sourcefileboundariesf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules boundaries Source Code boundaries.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !  date: 29/04/2019 !  For reading and storing boundary conditions. ! !  This module handles the reading and storing of the land-sea mask, the !  surface geopotential (i.e. the orography), the filtered surface geopotential !  (i.e. the smoothed orography) and the bare-land annual-mean albedo. module boundaries use params implicit none private public initialize_boundaries , fillsf , forchk public fmask , phi0 , phis0 , alb0 real :: fmask ( ix , il ) !! Original (fractional) land-sea mask ! Time invariant surface fields real :: phi0 ( ix , il ) !! Unfiltered surface geopotential real :: phis0 ( ix , il ) !! Spectrally-filtered surface geopotential real :: alb0 ( ix , il ) !! Bare-land annual-mean albedo contains !> Initialize boundary conditions (land-sea mask, surface geopotential !  and surface albedo). subroutine initialize_boundaries use physical_constants , only : grav use input_output , only : load_boundary_file ! Read surface geopotential (i.e. orography) phi0 = grav * load_boundary_file ( \"surface.nc\" , \"orog\" ) ! Also store spectrally truncated surface geopotential call spectral_truncation ( phi0 , phis0 ) ! Read land-sea mask fmask = load_boundary_file ( \"surface.nc\" , \"lsm\" ) ! Annual-mean surface albedo alb0 = load_boundary_file ( \"surface.nc\" , \"alb\" ) end subroutine !> Check consistency of surface fields with land-sea mask and set undefined !  values to a constant (to avoid over/underflow). subroutine forchk ( fmask , nf , fmin , fmax , fset , field ) real , intent ( in ) :: fmask ( ix , il ) !! The fractional land-sea mask integer , intent ( in ) :: nf !! The number of input 2D fields real , intent ( in ) :: fmin !! The minimum allowable value real , intent ( in ) :: fmax !! The maximum allowable value real , intent ( in ) :: fset !! Replacement for undefined values real , intent ( inout ) :: field ( ix , il , nf ) !! The output field integer :: i , j , jf , nfault do jf = 1 , nf nfault = 0 do i = 1 , ix do j = 1 , il if ( fmask ( i , j ) > 0.0 ) then if ( field ( i , j , jf ) < fmin . or . field ( i , j , jf ) > fmax ) then nfault = nfault + 1 end if else field ( i , j , jf ) = fset end if end do end do end do end subroutine !> Compute a spectrally-filtered grid-point field. subroutine spectral_truncation ( fg1 , fg2 ) use spectral , only : grid_to_spec , spec_to_grid real , intent ( inout ) :: fg1 ( ix , il ) !! Original grid-point field real , intent ( inout ) :: fg2 ( ix , il ) !! Filtered grid-point field complex :: fsp ( mx , nx ) integer :: n , m , total_wavenumber fsp = grid_to_spec ( fg1 ) do n = 1 , nx do m = 1 , mx total_wavenumber = m + n - 2 if ( total_wavenumber > trunc ) fsp ( m , n ) = ( 0.0 , 0.0 ) end do end do fg2 = spec_to_grid ( fsp , 1 ) end subroutine !> Replace missing values in surface fields. !  @note It is assumed that non-missing values exist near the Equator. subroutine fillsf ( sf , fmis ) real , intent ( inout ) :: sf ( ix , il ) !! Field to replace missing values in real , intent ( in ) :: fmis !! Replacement for missing values real :: sf2 ( 0 : ix + 1 ) integer :: hemisphere , j , j1 , j2 , j3 , i , nmis real :: fmean do hemisphere = 1 , 2 if ( hemisphere == 1 ) then j1 = il / 2 j2 = 1 j3 = - 1 else j1 = j1 + 1 j2 = il j3 = 1 end if do j = j1 , j2 , j3 sf2 ( 1 : ix ) = sf (:, j ) nmis = 0 do i = 1 , ix if ( sf ( i , j ) < fmis ) then nmis = nmis + 1 sf2 ( i ) = 0.0 end if end do if ( nmis < ix ) fmean = sum ( sf2 ( 1 : ix )) / float ( ix - nmis ) do i = 1 , ix if ( sf ( i , j ) < fmis ) sf2 ( i ) = fmean end do sf2 ( 0 ) = sf2 ( ix ) sf2 ( ix + 1 ) = sf2 ( 1 ) do i = 1 , ix if ( sf ( i , j ) < fmis ) sf ( i , j ) = 0.5 * ( sf2 ( i - 1 ) + sf2 ( i + 1 )) end do end do end do end subroutine end module","tags":"","loc":"sourcefile/boundaries.f90.html"},{"title":"coupler.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~coupler.f90~~EfferentGraph sourcefile~coupler.f90 coupler.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~coupler.f90->sourcefile~land_model.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~coupler.f90->sourcefile~sea_model.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~land_model.f90->sourcefile~input_output.f90 sourcefile~auxiliaries.f90 auxiliaries.f90 sourcefile~land_model.f90->sourcefile~auxiliaries.f90 sourcefile~interpolation.f90 interpolation.f90 sourcefile~land_model.f90->sourcefile~interpolation.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~land_model.f90->sourcefile~boundaries.f90 sourcefile~params.f90 params.f90 sourcefile~land_model.f90->sourcefile~params.f90 sourcefile~date.f90 date.f90 sourcefile~land_model.f90->sourcefile~date.f90 sourcefile~sea_model.f90->sourcefile~input_output.f90 sourcefile~sea_model.f90->sourcefile~auxiliaries.f90 sourcefile~sea_model.f90->sourcefile~interpolation.f90 sourcefile~sea_model.f90->sourcefile~boundaries.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~sea_model.f90->sourcefile~physical_constants.f90 sourcefile~mod_radcon.f90 mod_radcon.f90 sourcefile~sea_model.f90->sourcefile~mod_radcon.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~sea_model.f90->sourcefile~geometry.f90 sourcefile~sea_model.f90->sourcefile~params.f90 sourcefile~sea_model.f90->sourcefile~date.f90 sourcefile~input_output.f90->sourcefile~physical_constants.f90 sourcefile~input_output.f90->sourcefile~geometry.f90 sourcefile~input_output.f90->sourcefile~params.f90 sourcefile~input_output.f90->sourcefile~date.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~auxiliaries.f90->sourcefile~params.f90 sourcefile~interpolation.f90->sourcefile~params.f90 sourcefile~interpolation.f90->sourcefile~date.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~boundaries.f90->sourcefile~physical_constants.f90 sourcefile~boundaries.f90->sourcefile~params.f90 sourcefile~boundaries.f90->sourcefile~spectral.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 sourcefile~mod_radcon.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~date.f90->sourcefile~params.f90 sourcefile~spectral.f90->sourcefile~physical_constants.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~spectral.f90->sourcefile~params.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~legendre.f90->sourcefile~params.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 sourcefile~fourier.f90->sourcefile~params.f90 var pansourcefilecouplerf90EfferentGraph = svgPanZoom('#sourcefilecouplerf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~coupler.f90~~AfferentGraph sourcefile~coupler.f90 coupler.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~coupler.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~initialization.f90->sourcefile~coupler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules coupler Source Code coupler.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !  date: 29/04/2019 !  Highest level interface to land and sea models. module coupler implicit none private public initialize_coupler , couple_sea_land contains !> Initialize both land and sea models. subroutine initialize_coupler use land_model , only : land_model_init , couple_land_atm use sea_model , only : sea_model_init , couple_sea_atm ! Initialize land model constants call land_model_init ! Initialize land model variables call couple_land_atm ( 0 ) ! Initialize sea and ice model constants call sea_model_init ! Initialize sea and ice model variables call couple_sea_atm ( 0 ) end subroutine !> Exchange fluxes between atmosphere and land/sea. subroutine couple_sea_land ( day ) use land_model , only : couple_land_atm use sea_model , only : couple_sea_atm integer , intent ( in ) :: day !! The current day of the model integration (starting from 0) call couple_land_atm ( day ) call couple_sea_atm ( day ) end subroutine end module","tags":"","loc":"sourcefile/coupler.f90.html"},{"title":"diagnostics.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~diagnostics.f90~~EfferentGraph sourcefile~diagnostics.f90 diagnostics.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~diagnostics.f90->sourcefile~spectral.f90 sourcefile~params.f90 params.f90 sourcefile~diagnostics.f90->sourcefile~params.f90 sourcefile~spectral.f90->sourcefile~params.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~spectral.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90->sourcefile~params.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~fourier.f90->sourcefile~params.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 var pansourcefilediagnosticsf90EfferentGraph = svgPanZoom('#sourcefilediagnosticsf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~diagnostics.f90~~AfferentGraph sourcefile~diagnostics.f90 diagnostics.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~diagnostics.f90 sourcefile~prognostics.f90 prognostics.f90 sourcefile~speedy.f90->sourcefile~prognostics.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~prognostics.f90->sourcefile~diagnostics.f90 sourcefile~initialization.f90->sourcefile~prognostics.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~prognostics.f90 sourcefile~time_stepping.f90->sourcefile~prognostics.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 var pansourcefilediagnosticsf90AfferentGraph = svgPanZoom('#sourcefilediagnosticsf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules diagnostics Source Code diagnostics.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !  date: 01/05/2019 !  For checking model diagnostics in case of numerical instability. module diagnostics implicit none private public check_diagnostics contains !> Prints global means of eddy kinetic energy and temperature. !  Also stops the integration if the computed diagnostics are outside of !  allowable ranges. subroutine check_diagnostics ( vor , div , t , istep ) use params use spectral , only : inverse_laplacian complex , dimension ( mx , nx , kx ), intent ( in ) :: vor !! Spectral vorticity complex , dimension ( mx , nx , kx ), intent ( in ) :: div !! Spectral divergence complex , dimension ( mx , nx , kx ), intent ( in ) :: t !! Spectral temperature integer , intent ( in ) :: istep !! Current time step integer :: k , m , n , kk complex :: temp ( mx , nx ) real :: diag ( kx , 3 ) ! 1. Get global-mean temperature and compute eddy kinetic energy do k = 1 , kx diag ( k , 1 ) = 0.0 diag ( k , 2 ) = 0.0 diag ( k , 3 ) = sqrt ( 0.5 ) * real ( t ( 1 , 1 , k )) temp = inverse_laplacian ( vor (:,:, k )) do m = 2 , mx do n = 1 , nx diag ( k , 1 ) = diag ( k , 1 ) - real ( temp ( m , n ) * conjg ( vor ( m , n , k ))) end do end do temp = inverse_laplacian ( div (:,:, k )) do m = 2 , mx do n = 1 , nx diag ( k , 2 ) = diag ( k , 2 ) - real ( temp ( m , n ) * conjg ( div ( m , n , k ))) end do end do end do ! 2. Print results to screen if ( mod ( istep , nstdia ) == 0 ) then print 2001 , istep , ( diag ( k , 1 ), k = 1 , kx ) print 2002 , ( diag ( k , 2 ), k = 1 , kx ) print 2003 , ( diag ( k , 3 ), k = 1 , kx ) end if ! 3. Stop integration if model variables are out of range do k = 1 , kx if ( diag ( k , 1 ) > 50 0.0 . or . diag ( k , 2 ) > 50 0.0 . or . diag ( k , 3 ) < 18 0.0 . or . & & diag ( k , 3 ) > 32 0.0 ) then print 2001 , istep , ( diag ( kk , 1 ), kk = 1 , kx ) print 2002 , ( diag ( kk , 2 ), kk = 1 , kx ) print 2003 , ( diag ( kk , 3 ), kk = 1 , kx ) stop 'Model variables out of accepted range' end if end do 2001 format ( ' step =' , i6 , ' reke =' , ( 10 f8 . 2 )) 2002 format ( 13 x , ' deke =' , ( 10 f8 . 2 )) 2003 format ( 13 x , ' temp =' , ( 10 f8 . 2 )) end subroutine end module","tags":"","loc":"sourcefile/diagnostics.f90.html"},{"title":"prognostics.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~prognostics.f90~~EfferentGraph sourcefile~prognostics.f90 prognostics.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~prognostics.f90->sourcefile~input_output.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~prognostics.f90->sourcefile~physical_constants.f90 sourcefile~diagnostics.f90 diagnostics.f90 sourcefile~prognostics.f90->sourcefile~diagnostics.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~prognostics.f90->sourcefile~geometry.f90 sourcefile~params.f90 params.f90 sourcefile~prognostics.f90->sourcefile~params.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~prognostics.f90->sourcefile~boundaries.f90 sourcefile~dynamical_constants.f90 dynamical_constants.f90 sourcefile~prognostics.f90->sourcefile~dynamical_constants.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~prognostics.f90->sourcefile~spectral.f90 sourcefile~input_output.f90->sourcefile~physical_constants.f90 sourcefile~input_output.f90->sourcefile~geometry.f90 sourcefile~input_output.f90->sourcefile~params.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~date.f90 date.f90 sourcefile~input_output.f90->sourcefile~date.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 sourcefile~diagnostics.f90->sourcefile~params.f90 sourcefile~diagnostics.f90->sourcefile~spectral.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~boundaries.f90->sourcefile~physical_constants.f90 sourcefile~boundaries.f90->sourcefile~params.f90 sourcefile~boundaries.f90->sourcefile~spectral.f90 sourcefile~spectral.f90->sourcefile~physical_constants.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~spectral.f90->sourcefile~params.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~legendre.f90->sourcefile~params.f90 sourcefile~date.f90->sourcefile~params.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 sourcefile~fourier.f90->sourcefile~params.f90 var pansourcefileprognosticsf90EfferentGraph = svgPanZoom('#sourcefileprognosticsf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~prognostics.f90~~AfferentGraph sourcefile~prognostics.f90 prognostics.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~prognostics.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~initialization.f90->sourcefile~prognostics.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~prognostics.f90 sourcefile~time_stepping.f90->sourcefile~prognostics.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules prognostics Source Code prognostics.f90 Source Code ! Prognostic spectral variables for model dynamics, and geopotential. module prognostics use params implicit none private public vor , div , t , ps , tr public phi , phis public initialize_prognostics ! Prognostic spectral variables (updated in step) complex :: vor ( mx , nx , kx , 2 ) ! Vorticity complex :: div ( mx , nx , kx , 2 ) ! Divergence complex :: t ( mx , nx , kx , 2 ) ! Absolute temperature complex :: ps ( mx , nx , 2 ) ! Log of (normalised) surface pressure (p_s/p0) complex :: tr ( mx , nx , kx , 2 , ntr ) ! Tracers (tr(1): specific humidity in g/kg) ! Geopotential (updated in geop) complex :: phi ( mx , nx , kx ) ! Atmospheric geopotential complex :: phis ( mx , nx ) ! Surface geopotential contains ! Initialize all spectral variables starting from either a reference ! atmosphere or a restart file subroutine initialize_prognostics call initialize_from_rest_state end subroutine subroutine initialize_from_rest_state use dynamical_constants , only : gamma , hscale , hshum , refrh1 use physical_constants , only : grav , rgas use geometry , only : fsg use boundaries , only : phis0 use diagnostics , only : check_diagnostics use spectral , only : grid_to_spec , trunct use input_output , only : output complex :: surfs ( mx , nx ) real :: surfg ( ix , il ) real :: gam1 , esref , gam2 , qexp , qref , rgam , rgamr , rlog0 , tref , ttop integer :: i , j , k gam1 = gamma / ( 100 0.0 * grav ) ! 1. Compute spectral surface geopotential phis = grid_to_spec ( phis0 ) ! 2. Start from reference atmosphere (at rest) write ( * , '(A)' ) 'Starting from rest' ! 2.1 Set vorticity, divergence and tracers to zero vor (:,:,:, 1 ) = ( 0.0 , 0.0 ) div (:,:,:, 1 ) = ( 0.0 , 0.0 ) tr (:,:,:, 1 ,:) = ( 0.0 , 0.0 ) ! 2.2 Set reference temperature : !     tropos:  T = 288 degK at z = 0, constant lapse rate !     stratos: T = 216 degK, lapse rate = 0 tref = 28 8.0 ttop = 21 6.0 gam2 = gam1 / tref rgam = rgas * gam1 rgamr = 1.0 / rgam ! Surface and stratospheric air temperature t (:,:, 1 , 1 ) = ( 0.0 , 0.0 ) t (:,:, 2 , 1 ) = ( 0.0 , 0.0 ) surfs = - gam1 * phis t ( 1 , 1 , 1 , 1 ) = sqrt ( 2.0 ) * ( 1.0 , 0.0 ) * ttop t ( 1 , 1 , 2 , 1 ) = sqrt ( 2.0 ) * ( 1.0 , 0.0 ) * ttop surfs ( 1 , 1 ) = sqrt ( 2.0 ) * ( 1.0 , 0.0 ) * tref - gam1 * phis ( 1 , 1 ) ! Temperature at tropospheric levels do k = 3 , kx t (:,:, k , 1 ) = surfs * fsg ( k ) ** rgam end do ! 2.3 Set log(ps) consistent with temperature profile !     p_ref = 1013 hPa at z = 0 rlog0 = log ( 1.013 ) do j = 1 , il do i = 1 , ix surfg ( i , j ) = rlog0 + rgamr * log ( 1.0 - gam2 * phis0 ( i , j )) end do end do ps (:,:, 1 ) = grid_to_spec ( surfg ) if ( ix == iy * 4 ) call trunct ( ps ) ! 2.4 Set tropospheric specific humidity in g/kg !     Qref = RHref * Qsat(288K, 1013hPa) esref = 1 7.0 qref = refrh1 * 0.622 * esref qexp = hscale / hshum ! Specific humidity at the surface do j = 1 , il do i = 1 , ix surfg ( i , j ) = qref * exp ( qexp * surfg ( i , j )) end do end do surfs = grid_to_spec ( surfg ) if ( ix == iy * 4 ) call trunct ( surfs ) ! Specific humidity at tropospheric levels do k = 3 , kx tr (:,:, k , 1 , 1 ) = surfs * fsg ( k ) ** qexp end do ! Print diagnostics from initial conditions call check_diagnostics ( vor (:,:,:, 1 ), div (:,:,:, 1 ), t (:,:,:, 1 ), 0 ) ! Write initial data call output ( 0 , vor , div , t , ps , tr , phi ) end subroutine end module","tags":"","loc":"sourcefile/prognostics.f90.html"},{"title":"params.f90 – SPEEDY.f90","text":"Files dependent on this one sourcefile~~params.f90~~AfferentGraph sourcefile~params.f90 params.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~input_output.f90->sourcefile~params.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~input_output.f90->sourcefile~geometry.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~date.f90 date.f90 sourcefile~input_output.f90->sourcefile~date.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~input_output.f90->sourcefile~physical_constants.f90 sourcefile~large_scale_condensation.f90 large_scale_condensation.f90 sourcefile~large_scale_condensation.f90->sourcefile~params.f90 sourcefile~large_scale_condensation.f90->sourcefile~geometry.f90 sourcefile~large_scale_condensation.f90->sourcefile~physical_constants.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~surface_fluxes.f90->sourcefile~params.f90 sourcefile~mod_radcon.f90 mod_radcon.f90 sourcefile~surface_fluxes.f90->sourcefile~mod_radcon.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 sourcefile~surface_fluxes.f90->sourcefile~geometry.f90 sourcefile~surface_fluxes.f90->sourcefile~physical_constants.f90 sourcefile~humidity.f90 humidity.f90 sourcefile~surface_fluxes.f90->sourcefile~humidity.f90 sourcefile~geopotential.f90 geopotential.f90 sourcefile~geopotential.f90->sourcefile~params.f90 sourcefile~geopotential.f90->sourcefile~geometry.f90 sourcefile~geopotential.f90->sourcefile~physical_constants.f90 sourcefile~implicit.f90 implicit.f90 sourcefile~implicit.f90->sourcefile~params.f90 sourcefile~implicit.f90->sourcefile~geometry.f90 sourcefile~horizontal_diffusion.f90 horizontal_diffusion.f90 sourcefile~implicit.f90->sourcefile~horizontal_diffusion.f90 sourcefile~implicit.f90->sourcefile~physical_constants.f90 sourcefile~mod_radcon.f90->sourcefile~params.f90 sourcefile~sppt.f90 sppt.f90 sourcefile~sppt.f90->sourcefile~params.f90 sourcefile~sppt.f90->sourcefile~spectral.f90 sourcefile~sppt.f90->sourcefile~physical_constants.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~initialization.f90->sourcefile~params.f90 sourcefile~initialization.f90->sourcefile~input_output.f90 sourcefile~initialization.f90->sourcefile~geopotential.f90 sourcefile~physics.f90 physics.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~prognostics.f90 prognostics.f90 sourcefile~initialization.f90->sourcefile~prognostics.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~initialization.f90->sourcefile~geometry.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~initialization.f90->sourcefile~boundaries.f90 sourcefile~initialization.f90->sourcefile~spectral.f90 sourcefile~initialization.f90->sourcefile~date.f90 sourcefile~initialization.f90->sourcefile~horizontal_diffusion.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~initialization.f90->sourcefile~sea_model.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~coupler.f90 coupler.f90 sourcefile~initialization.f90->sourcefile~coupler.f90 sourcefile~physics.f90->sourcefile~params.f90 sourcefile~physics.f90->sourcefile~large_scale_condensation.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~physics.f90->sourcefile~sppt.f90 sourcefile~physics.f90->sourcefile~land_model.f90 sourcefile~physics.f90->sourcefile~geometry.f90 sourcefile~physics.f90->sourcefile~boundaries.f90 sourcefile~vertical_diffusion.f90 vertical_diffusion.f90 sourcefile~physics.f90->sourcefile~vertical_diffusion.f90 sourcefile~physics.f90->sourcefile~spectral.f90 sourcefile~physics.f90->sourcefile~sea_model.f90 sourcefile~physics.f90->sourcefile~physical_constants.f90 sourcefile~auxiliaries.f90 auxiliaries.f90 sourcefile~physics.f90->sourcefile~auxiliaries.f90 sourcefile~longwave_radiation.f90 longwave_radiation.f90 sourcefile~physics.f90->sourcefile~longwave_radiation.f90 sourcefile~physics.f90->sourcefile~humidity.f90 sourcefile~shortwave_radiation.f90 shortwave_radiation.f90 sourcefile~physics.f90->sourcefile~shortwave_radiation.f90 sourcefile~convection.f90 convection.f90 sourcefile~physics.f90->sourcefile~convection.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~params.f90 sourcefile~speedy.f90->sourcefile~input_output.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~speedy.f90->sourcefile~prognostics.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~speedy.f90->sourcefile~date.f90 sourcefile~diagnostics.f90 diagnostics.f90 sourcefile~speedy.f90->sourcefile~diagnostics.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~speedy.f90->sourcefile~shortwave_radiation.f90 sourcefile~speedy.f90->sourcefile~coupler.f90 sourcefile~land_model.f90->sourcefile~params.f90 sourcefile~land_model.f90->sourcefile~input_output.f90 sourcefile~land_model.f90->sourcefile~boundaries.f90 sourcefile~land_model.f90->sourcefile~date.f90 sourcefile~land_model.f90->sourcefile~auxiliaries.f90 sourcefile~interpolation.f90 interpolation.f90 sourcefile~land_model.f90->sourcefile~interpolation.f90 sourcefile~prognostics.f90->sourcefile~params.f90 sourcefile~prognostics.f90->sourcefile~input_output.f90 sourcefile~prognostics.f90->sourcefile~geometry.f90 sourcefile~prognostics.f90->sourcefile~boundaries.f90 sourcefile~prognostics.f90->sourcefile~spectral.f90 sourcefile~prognostics.f90->sourcefile~diagnostics.f90 sourcefile~prognostics.f90->sourcefile~physical_constants.f90 sourcefile~time_stepping.f90->sourcefile~params.f90 sourcefile~time_stepping.f90->sourcefile~implicit.f90 sourcefile~time_stepping.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 sourcefile~time_stepping.f90->sourcefile~spectral.f90 sourcefile~time_stepping.f90->sourcefile~horizontal_diffusion.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~tendencies.f90->sourcefile~params.f90 sourcefile~tendencies.f90->sourcefile~geopotential.f90 sourcefile~tendencies.f90->sourcefile~implicit.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~tendencies.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90->sourcefile~geometry.f90 sourcefile~tendencies.f90->sourcefile~spectral.f90 sourcefile~tendencies.f90->sourcefile~physical_constants.f90 sourcefile~boundaries.f90->sourcefile~params.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~boundaries.f90->sourcefile~spectral.f90 sourcefile~boundaries.f90->sourcefile~physical_constants.f90 sourcefile~vertical_diffusion.f90->sourcefile~params.f90 sourcefile~vertical_diffusion.f90->sourcefile~geometry.f90 sourcefile~vertical_diffusion.f90->sourcefile~physical_constants.f90 sourcefile~spectral.f90->sourcefile~params.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~spectral.f90->sourcefile~physical_constants.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~date.f90->sourcefile~params.f90 sourcefile~legendre.f90->sourcefile~params.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~diagnostics.f90->sourcefile~params.f90 sourcefile~diagnostics.f90->sourcefile~spectral.f90 sourcefile~horizontal_diffusion.f90->sourcefile~params.f90 sourcefile~horizontal_diffusion.f90->sourcefile~geometry.f90 sourcefile~horizontal_diffusion.f90->sourcefile~physical_constants.f90 sourcefile~sea_model.f90->sourcefile~params.f90 sourcefile~sea_model.f90->sourcefile~input_output.f90 sourcefile~sea_model.f90->sourcefile~mod_radcon.f90 sourcefile~sea_model.f90->sourcefile~geometry.f90 sourcefile~sea_model.f90->sourcefile~boundaries.f90 sourcefile~sea_model.f90->sourcefile~date.f90 sourcefile~sea_model.f90->sourcefile~physical_constants.f90 sourcefile~sea_model.f90->sourcefile~auxiliaries.f90 sourcefile~sea_model.f90->sourcefile~interpolation.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 sourcefile~auxiliaries.f90->sourcefile~params.f90 sourcefile~interpolation.f90->sourcefile~params.f90 sourcefile~interpolation.f90->sourcefile~date.f90 sourcefile~longwave_radiation.f90->sourcefile~params.f90 sourcefile~longwave_radiation.f90->sourcefile~mod_radcon.f90 sourcefile~longwave_radiation.f90->sourcefile~geometry.f90 sourcefile~longwave_radiation.f90->sourcefile~physical_constants.f90 sourcefile~fourier.f90->sourcefile~params.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 sourcefile~forcing.f90->sourcefile~params.f90 sourcefile~forcing.f90->sourcefile~surface_fluxes.f90 sourcefile~forcing.f90->sourcefile~mod_radcon.f90 sourcefile~forcing.f90->sourcefile~land_model.f90 sourcefile~forcing.f90->sourcefile~boundaries.f90 sourcefile~forcing.f90->sourcefile~spectral.f90 sourcefile~forcing.f90->sourcefile~date.f90 sourcefile~forcing.f90->sourcefile~horizontal_diffusion.f90 sourcefile~forcing.f90->sourcefile~sea_model.f90 sourcefile~forcing.f90->sourcefile~physical_constants.f90 sourcefile~forcing.f90->sourcefile~longwave_radiation.f90 sourcefile~forcing.f90->sourcefile~humidity.f90 sourcefile~forcing.f90->sourcefile~shortwave_radiation.f90 sourcefile~humidity.f90->sourcefile~params.f90 sourcefile~shortwave_radiation.f90->sourcefile~params.f90 sourcefile~shortwave_radiation.f90->sourcefile~mod_radcon.f90 sourcefile~shortwave_radiation.f90->sourcefile~geometry.f90 sourcefile~convection.f90->sourcefile~params.f90 sourcefile~convection.f90->sourcefile~geometry.f90 sourcefile~convection.f90->sourcefile~physical_constants.f90 sourcefile~coupler.f90->sourcefile~land_model.f90 sourcefile~coupler.f90->sourcefile~sea_model.f90 var pansourcefileparamsf90AfferentGraph = svgPanZoom('#sourcefileparamsf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules params Source Code params.f90 Source Code module params implicit none private public trunc , ix , iy , il , kx , nx , mx , ntr public nsteps , nstdia , nsteps_out , iseasc , nstrad , sppt_on , issty0 , delt , rob , wil , alph public initialize_params ! ========================================================================= ! Constant parameters ! ========================================================================= ! Model geometry parameters integer , parameter :: trunc = 30 ! Spectral truncation integer , parameter :: ix = 96 ! Number of longitudes integer , parameter :: iy = 24 , il = 2 * iy ! Number of latitudes in hemisphere and full sphere integer , parameter :: kx = 8 ! Number of vertical levels integer , parameter :: nx = trunc + 2 ! Number of total wavenumbers integer , parameter :: mx = trunc + 1 ! Number of zonal wavenumbers integer , parameter :: ntr = 1 ! Number of tracers ! Time stepping parameters integer , parameter :: nsteps = 36 ! Number of time steps in one day real , parameter :: delt = 8640 0.0 / nsteps ! Time step in seconds real , parameter :: rob = 0.05 ! Damping factor in Robert time filter real , parameter :: wil = 0.53 ! Parameter of Williams filter real , parameter :: alph = 0.5 ! Coefficient for semi-implicit computations ! 0 -> forward step for gravity wave terms, ! 1 -> backward implicit, 0.5 -> centered implicit ! Physics parameters integer , parameter :: iseasc = 1 ! Seasonal cycle flag (0=no, 1=yes) integer , parameter :: nstrad = 3 ! Period (number of steps) for shortwave radiation logical , parameter :: sppt_on = . false . ! Turn on SPPT? integer , parameter :: issty0 = 1979 ! Starting year for SST anomaly file ! ========================================================================= ! User-specified parameters (through the namelist file) ! ========================================================================= integer :: nstdia ! Period (number of steps) for diagnostic print-out integer :: nsteps_out ! Number of time steps between outputs contains !> Initializes user-defined parameters from namelist file. subroutine initialize_params namelist / params / nsteps_out , nstdia logical :: namelist_file_exists ! Set default values nsteps_out = 1 nstdia = 36 * 5 ! Read namelist file, if it exists inquire ( file = \"namelist.nml\" , exist = namelist_file_exists ) if ( namelist_file_exists ) then open ( 10 , file = \"namelist.nml\" ) read ( 10 , nml = params ) close ( 10 ) end if ! Print values to screen write ( * , '(A,I5)' ) 'nsteps_out (frequency of output)  = ' , nsteps_out write ( * , '(A,I5)' ) 'nstdia (frequency of diagnostics) = ' , nstdia end subroutine end module","tags":"","loc":"sourcefile/params.f90.html"},{"title":"spectral.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~spectral.f90~~EfferentGraph sourcefile~spectral.f90 spectral.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~spectral.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~params.f90 params.f90 sourcefile~spectral.f90->sourcefile~params.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~legendre.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 sourcefile~fourier.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~spectral.f90~~AfferentGraph sourcefile~spectral.f90 spectral.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~prognostics.f90 prognostics.f90 sourcefile~prognostics.f90->sourcefile~spectral.f90 sourcefile~prognostics.f90->sourcefile~input_output.f90 sourcefile~diagnostics.f90 diagnostics.f90 sourcefile~prognostics.f90->sourcefile~diagnostics.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~prognostics.f90->sourcefile~boundaries.f90 sourcefile~diagnostics.f90->sourcefile~spectral.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~time_stepping.f90->sourcefile~spectral.f90 sourcefile~time_stepping.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~forcing.f90->sourcefile~spectral.f90 sourcefile~forcing.f90->sourcefile~boundaries.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~forcing.f90->sourcefile~land_model.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~forcing.f90->sourcefile~sea_model.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~forcing.f90->sourcefile~surface_fluxes.f90 sourcefile~sppt.f90 sppt.f90 sourcefile~sppt.f90->sourcefile~spectral.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~initialization.f90->sourcefile~spectral.f90 sourcefile~initialization.f90->sourcefile~input_output.f90 sourcefile~initialization.f90->sourcefile~prognostics.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~physics.f90 physics.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~initialization.f90->sourcefile~boundaries.f90 sourcefile~initialization.f90->sourcefile~sea_model.f90 sourcefile~coupler.f90 coupler.f90 sourcefile~initialization.f90->sourcefile~coupler.f90 sourcefile~physics.f90->sourcefile~spectral.f90 sourcefile~physics.f90->sourcefile~sppt.f90 sourcefile~physics.f90->sourcefile~boundaries.f90 sourcefile~physics.f90->sourcefile~land_model.f90 sourcefile~physics.f90->sourcefile~sea_model.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~tendencies.f90->sourcefile~spectral.f90 sourcefile~tendencies.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~boundaries.f90->sourcefile~spectral.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~input_output.f90 sourcefile~speedy.f90->sourcefile~prognostics.f90 sourcefile~speedy.f90->sourcefile~diagnostics.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~speedy.f90->sourcefile~coupler.f90 sourcefile~land_model.f90->sourcefile~input_output.f90 sourcefile~land_model.f90->sourcefile~boundaries.f90 sourcefile~sea_model.f90->sourcefile~input_output.f90 sourcefile~sea_model.f90->sourcefile~boundaries.f90 sourcefile~coupler.f90->sourcefile~land_model.f90 sourcefile~coupler.f90->sourcefile~sea_model.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 var pansourcefilespectralf90AfferentGraph = svgPanZoom('#sourcefilespectralf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules spectral Source Code spectral.f90 Source Code module spectral use params implicit none private public el2 public initialize_spectral public laplacian , inverse_laplacian , spec_to_grid , grid_to_spec public grad , vds , uvspec , vdspec , trunct real , dimension ( mx , nx ) :: el2 , elm2 , el4 , trfilt real :: gradx ( mx ), gradym ( mx , nx ), gradyp ( mx , nx ) real , dimension ( mx , nx ) :: uvdx , uvdym , uvdyp real , dimension ( mx , nx ) :: vddym , vddyp contains ! Initialize spectral transforms subroutine initialize_spectral use physical_constants , only : rearth use fourier , only : initialize_fourier use legendre , only : initialize_legendre , epsi real :: el1 integer :: m , m1 , m2 , n , wavenum_tot ( mx , nx ), mm ( mx ) ! Initialize Fourier transforms call initialize_fourier ! Initialize Legendre transforms call initialize_legendre !  MM = zonal wavenumber = m !  wavenum_tot = total wavenumber of spherical harmonic = l !  L2 = l*(l+1) !  EL2 = l*(l+1)/(a**2) !  EL4 = EL2*EL2 ; for biharmonic diffusion !  ELM2 = 1./EL2 !  TRFILT used to filter out \"non-triangular\" part of rhomboidal truncation do n = 1 , nx do m = 1 , mx mm ( m ) = m - 1 wavenum_tot ( m , n ) = mm ( m ) + n - 1 el2 ( m , n ) = float ( wavenum_tot ( m , n ) * ( wavenum_tot ( m , n ) + 1 )) / ( rearth ** 2.0 ) el4 ( m , n ) = el2 ( m , n ) ** 2.0 if ( wavenum_tot ( m , n ) <= trunc ) then trfilt ( m , n ) = 1.0 else trfilt ( m , n ) = 0.0 end if end do end do elm2 ( 1 , 1 ) = 0.0 elm2 ( 2 : mx ,:) = 1.0 / el2 ( 2 : mx ,:) elm2 ( 1 , 2 : nx ) = 1.0 / el2 ( 1 , 2 : nx ) ! quantities required by subroutines GRAD, UVSPEC, and VDS ! saved in spectral do m = 1 , mx do n = 1 , nx m1 = mm ( m ) m2 = m1 + 1 el1 = float ( wavenum_tot ( m , n )) if ( n == 1 ) then gradx ( m ) = float ( m1 ) / rearth uvdx ( m , 1 ) = - rearth / float ( m1 + 1 ) uvdym ( m , 1 ) = 0.0 vddym ( m , 1 ) = 0.0 else uvdx ( m , n ) = - rearth * float ( m1 ) / ( el1 * ( el1 + 1 )) gradym ( m , n ) = ( el1 - 1.0 ) * epsi ( m2 , n ) / rearth uvdym ( m , n ) = - rearth * epsi ( m2 , n ) / el1 vddym ( m , n ) = ( el1 + 1 ) * epsi ( m2 , n ) / rearth end if gradyp ( m , n ) = ( el1 + 2.0 ) * epsi ( m2 , n + 1 ) / rearth uvdyp ( m , n ) = - rearth * epsi ( m2 , n + 1 ) / ( el1 + 1.0 ) vddyp ( m , n ) = el1 * epsi ( m2 , n + 1 ) / rearth end do end do end function laplacian ( input ) result ( output ) complex , intent ( in ) :: input ( mx , nx ) complex :: output ( mx , nx ) output = - input * el2 end function function inverse_laplacian ( input ) result ( output ) complex , intent ( in ) :: input ( mx , nx ) complex :: output ( mx , nx ) output = - input * elm2 end function function spec_to_grid ( vorm , kcos ) result ( vorg ) use legendre , only : legendre_inv use fourier , only : fourier_inv complex , intent ( in ) :: vorm ( mx , nx ) integer , intent ( in ) :: kcos real :: vorg ( ix , il ) real :: vorm_r ( 2 * mx , nx ) vorm_r = reshape ( transfer ( vorm , vorm_r ), ( / 2 * mx , nx / )) vorg = fourier_inv ( legendre_inv ( vorm_r ), kcos ) end function function grid_to_spec ( vorg ) result ( vorm ) use legendre , only : legendre_dir use fourier , only : fourier_dir real , intent ( in ) :: vorg ( ix , il ) complex :: vorm ( mx , nx ) real :: vorm_r ( 2 * mx , nx ) vorm_r = legendre_dir ( fourier_dir ( vorg )) vorm = reshape ( transfer ( vorm_r , vorm ), ( / mx , nx / )) end function subroutine grad ( psi , psdx , psdy ) complex , dimension ( mx , nx ), intent ( inout ) :: psi complex , dimension ( mx , nx ), intent ( inout ) :: psdx , psdy integer :: n , m do n = 1 , nx psdx (:, n ) = gradx * psi (:, n ) * ( 0.0 , 1.0 ) end do do m = 1 , mx psdy ( m , 1 ) = gradyp ( m , 1 ) * psi ( m , 2 ) psdy ( m , nx ) = - gradym ( m , nx ) * psi ( m , trunc + 1 ) end do do n = 2 , trunc + 1 do m = 1 , mx psdy ( m , n ) = - gradym ( m , n ) * psi ( m , n - 1 ) + gradyp ( m , n ) * psi ( m , n + 1 ) end do end do end subroutine vds ( ucosm , vcosm , vorm , divm ) complex , dimension ( mx , nx ) :: ucosm , vcosm complex , dimension ( mx , nx ), intent ( inout ) :: vorm , divm complex , dimension ( mx , nx ) :: zc , zp integer :: n , m do n = 1 , nx zp (:, n ) = gradx * ucosm (:, n ) * ( 0.0 , 1.0 ) zc (:, n ) = gradx * vcosm (:, n ) * ( 0.0 , 1.0 ) end do do m = 1 , mx vorm ( m , 1 ) = zc ( m , 1 ) - vddyp ( m , 1 ) * ucosm ( m , 2 ) vorm ( m , nx ) = vddym ( m , nx ) * ucosm ( m , trunc + 1 ) divm ( m , 1 ) = zp ( m , 1 ) + vddyp ( m , 1 ) * vcosm ( m , 2 ) divm ( m , nx ) = - vddym ( m , nx ) * vcosm ( m , trunc + 1 ) end do do n = 2 , trunc + 1 do m = 1 , mx vorm ( m , n ) = vddym ( m , n ) * ucosm ( m , n - 1 ) - vddyp ( m , n ) * ucosm ( m , n + 1 ) + zc ( m , n ) divm ( m , n ) = - vddym ( m , n ) * vcosm ( m , n - 1 ) + vddyp ( m , n ) * vcosm ( m , n + 1 ) + zp ( m , n ) end do end do end subroutine uvspec ( vorm , divm , ucosm , vcosm ) complex , dimension ( mx , nx ), intent ( in ) :: vorm , divm complex , dimension ( mx , nx ), intent ( inout ) :: ucosm , vcosm complex , dimension ( mx , nx ) :: zc , zp integer :: n , m zp = uvdx * vorm * ( 0.0 , 1.0 ) zc = uvdx * divm * ( 0.0 , 1.0 ) do m = 1 , mx ucosm ( m , 1 ) = zc ( m , 1 ) - uvdyp ( m , 1 ) * vorm ( m , 2 ) ucosm ( m , nx ) = uvdym ( m , nx ) * vorm ( m , trunc + 1 ) vcosm ( m , 1 ) = zp ( m , 1 ) + uvdyp ( m , 1 ) * divm ( m , 2 ) vcosm ( m , nx ) = - uvdym ( m , nx ) * divm ( m , trunc + 1 ) end do do n = 2 , trunc + 1 do m = 1 , mx vcosm ( m , n ) = - uvdym ( m , n ) * divm ( m , n - 1 ) + uvdyp ( m , n ) * divm ( m , n + 1 ) + zp ( m , n ) ucosm ( m , n ) = uvdym ( m , n ) * vorm ( m , n - 1 ) - uvdyp ( m , n ) * vorm ( m , n + 1 ) + zc ( m , n ) end do end do end subroutine vdspec ( ug , vg , vorm , divm , kcos ) use geometry , only : cosgr , cosgr2 real , intent ( in ) :: ug ( ix , il ), vg ( ix , il ) complex , intent ( out ) :: vorm ( mx , nx ), divm ( mx , nx ) integer , intent ( in ) :: kcos integer :: i , j real :: ug1 ( ix , il ), vg1 ( ix , il ) complex :: specu ( mx , nx ), specv ( mx , nx ) if ( kcos . eq . 2 ) then do j = 1 , il do i = 1 , ix ug1 ( i , j ) = ug ( i , j ) * cosgr ( j ) vg1 ( i , j ) = vg ( i , j ) * cosgr ( j ) end do end do else do j = 1 , il do i = 1 , ix ug1 ( i , j ) = ug ( i , j ) * cosgr2 ( j ) vg1 ( i , j ) = vg ( i , j ) * cosgr2 ( j ) end do end do end if specu = grid_to_spec ( ug1 ) specv = grid_to_spec ( vg1 ) call vds ( specu , specv , vorm , divm ) end subroutine trunct ( vor ) complex , intent ( inout ) :: vor ( mx , nx ) vor = vor * trfilt end end module","tags":"","loc":"sourcefile/spectral.f90.html"},{"title":"humidity.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~humidity.f90~~EfferentGraph sourcefile~humidity.f90 humidity.f90 sourcefile~params.f90 params.f90 sourcefile~humidity.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~humidity.f90~~AfferentGraph sourcefile~humidity.f90 humidity.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~forcing.f90->sourcefile~humidity.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~forcing.f90->sourcefile~surface_fluxes.f90 sourcefile~physics.f90 physics.f90 sourcefile~physics.f90->sourcefile~humidity.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~surface_fluxes.f90->sourcefile~humidity.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 var pansourcefilehumidityf90AfferentGraph = svgPanZoom('#sourcefilehumidityf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules humidity Source Code humidity.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !  date: 07/05/2019 !  For converting between specific and relative humidity, and computing the !  saturation specific humidity. module humidity use params , only : ix , il implicit none private public spec_hum_to_rel_hum , rel_hum_to_spec_hum , get_qsat contains !> Converts specific humidity to relative humidity, and also returns !  saturation specific humidity. subroutine spec_hum_to_rel_hum ( ta , ps , sig , qa , rh , qsat ) real , intent ( in ) :: ta ( ix , il ) !! Absolute temperature real , intent ( in ) :: ps ( ix , il ) !! Normalized pressure (p/1000 hPa) real , intent ( in ) :: sig !! Sigma level real , intent ( in ) :: qa ( ix , il ) !! Specific humidity real , intent ( inout ) :: rh ( ix , il ) !! Relative humidity real , intent ( inout ) :: qsat ( ix , il ) !! Saturation specific humidity qsat = get_qsat ( ta , ps , sig ) rh = qa / qsat end subroutine !> Converts relative humidity to specific humidity, and also returns !  saturation specific humidity. subroutine rel_hum_to_spec_hum ( ta , ps , sig , rh , qa , qsat ) real , intent ( in ) :: ta ( ix , il ) !! Absolute temperature real , intent ( in ) :: ps ( ix , il ) !! Normalized pressure (p/1000 hPa) real , intent ( in ) :: sig !! Sigma level real , intent ( in ) :: rh ( ix , il ) !! Relative humidity real , intent ( inout ) :: qa ( ix , il ) !! Specific humidity real , intent ( inout ) :: qsat ( ix , il ) !! Saturation specific humidity qsat = get_qsat ( ta , ps , sig ) qa = rh * qsat end subroutine !> Computes saturation specific humidity. function get_qsat ( ta , ps , sig ) result ( qsat ) real , intent ( in ) :: ta ( ix , il ) !! Absolute temperature real , intent ( in ) :: ps ( ix , il ) !! Normalized pressure (p/1000 hPa) real , intent ( in ) :: sig !! Sigma level real :: qsat ( ix , il ) !! Saturation specific humidity in g/kg real :: e0 , c1 , c2 , t0 , t1 , t2 integer :: i , j ! 1. Compute Qsat (g/kg) from T (degK) and normalized pres. P (= p/1000_hPa) ! If sig > 0, P = Ps * sigma, otherwise P = Ps(1) = const. e0 = 6.108d-3 c1 = 1 7.269 c2 = 2 1.875 t0 = 27 3.16 t1 = 3 5.86 t2 = 7.66 do i = 1 , ix do j = 1 , il if ( ta ( i , j ) >= t0 ) then qsat ( i , j ) = e0 * exp ( c1 * ( ta ( i , j ) - t0 ) / ( ta ( i , j ) - t1 )) else qsat ( i , j ) = e0 * exp ( c2 * ( ta ( i , j ) - t0 ) / ( ta ( i , j ) - t2 )) end if end do end do if ( sig <= 0.0 ) then qsat = 62 2.0 * qsat / ( ps ( 1 , 1 ) - 0.378 * qsat ) else qsat = 62 2.0 * qsat / ( sig * ps - 0.378 * qsat ) end if end function end module","tags":"","loc":"sourcefile/humidity.f90.html"},{"title":"vertical_diffusion.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~vertical_diffusion.f90~~EfferentGraph sourcefile~vertical_diffusion.f90 vertical_diffusion.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~vertical_diffusion.f90->sourcefile~geometry.f90 sourcefile~params.f90 params.f90 sourcefile~vertical_diffusion.f90->sourcefile~params.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~vertical_diffusion.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~vertical_diffusion.f90~~AfferentGraph sourcefile~vertical_diffusion.f90 vertical_diffusion.f90 sourcefile~physics.f90 physics.f90 sourcefile~physics.f90->sourcefile~vertical_diffusion.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 var pansourcefilevertical_diffusionf90AfferentGraph = svgPanZoom('#sourcefilevertical_diffusionf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules vertical_diffusion Source Code vertical_diffusion.f90 Source Code !> Parametrization of vertical diffusion ! ! Three different processes are modelled by the vertical diffusion scheme: ! 1) Shallow convection - A redistribution of moisture and dry static energy !    between the lowest two layers where there is conditional instability ! 2) A slow diffusion of moisture in stable conditions ! 3) A fast redistribution of dry static energy where the lapse rate is close to !    the dry adiabatic limit module vertical_diffusion use params implicit none private public get_vertical_diffusion_tend ! Constants for vertical diffusion and shallow convection. real , parameter :: trshc = 6.0 !! Relaxation time (in hours) for shallow convection real , parameter :: trvdi = 2 4.0 !! Relaxation time (in hours) for moisture diffusion real , parameter :: trvds = 6.0 !! Relaxation time (in hours) for super-adiabatic conditions real , parameter :: redshc = 0.5 !! Reduction factor of shallow convection in areas of deep !! convection real , parameter :: rhgrad = 0.5 !! Maximum gradient of relative humidity (d_RH/d_sigma) real , parameter :: segrad = 0.1 !! Minimum gradient of dry static energy (d_DSE/d_phi) contains !> Compute tendencies of momentum, energy and moisture due to vertical diffusion !  and shallow convection subroutine get_vertical_diffusion_tend ( se , rh , qa , qsat , phi , icnv , utenvd , vtenvd , & & ttenvd , qtenvd ) use physical_constants , only : cp , alhc , sigh use geometry , only : fsg , dhs real , intent ( in ) :: se ( ix , il , kx ) !! Dry static energy real , intent ( in ) :: rh ( ix , il , kx ) !! Relative humidity real , intent ( in ) :: qa ( ix , il , kx ) !! Specific humidity [g/kg] real , intent ( in ) :: qsat ( ix , il , kx ) !! Saturated specific humidity [g/kg] real , intent ( in ) :: phi ( ix , il , kx ) !! Geopotential integer , intent ( in ) :: icnv ( ix , il ) !! Sigma-level index of deep convection real , intent ( out ) :: utenvd ( ix , il , kx ) !! u-wind tendency real , intent ( out ) :: vtenvd ( ix , il , kx ) !! v-wind tendency real , intent ( out ) :: ttenvd ( ix , il , kx ) !! Temperature tendency real , intent ( out ) :: qtenvd ( ix , il , kx ) !! Specific humidity tendency integer :: nl1 , i , j , k , k1 real :: cshc , cvdi , fshcq , fshcse , fvdiq , fvdise , drh0 , fvdiq2 , dmse , drh real :: fluxse , fluxq , fcnv , se0 real , dimension ( kx ) :: rsig , rsig1 ! 1. Initalization ! N.B. In this routine, fluxes of dry static energy and humidity !      are scaled in such a way that: !      d_T/dt = d_F'(SE)/d_sigma,  d_Q/dt = d_F'(Q)/d_sigma nl1 = kx - 1 cshc = dhs ( kx ) / 360 0.0 cvdi = ( sigh ( nl1 ) - sigh ( 1 )) / (( nl1 - 1 ) * 360 0.0 ) fshcq = cshc / trshc fshcse = cshc / ( trshc * cp ) fvdiq = cvdi / trvdi fvdise = cvdi / ( trvds * cp ) do k = 1 , nl1 rsig ( k ) = 1.0 / dhs ( k ) rsig1 ( k ) = 1.0 / ( 1.0 - sigh ( k )) end do rsig ( kx ) = 1.0 / dhs ( kx ) utenvd = 0.0 vtenvd = 0.0 ttenvd = 0.0 qtenvd = 0.0 ! 2. Shallow convection drh0 = rhgrad * ( fsg ( kx ) - fsg ( nl1 )) fvdiq2 = fvdiq * sigh ( nl1 ) do i = 1 , ix do j = 1 , il dmse = se ( i , j , kx ) - se ( i , j , nl1 ) + alhc * ( qa ( i , j , kx ) - qsat ( i , j , nl1 )) drh = rh ( i , j , kx ) - rh ( i , j , nl1 ) fcnv = 1.0 if ( dmse >= 0.0 ) then if ( icnv ( i , j ) > 0 ) fcnv = redshc fluxse = fcnv * fshcse * dmse ttenvd ( i , j , nl1 ) = fluxse * rsig ( nl1 ) ttenvd ( i , j , kx ) = - fluxse * rsig ( kx ) if ( drh >= 0.0 ) then fluxq = fcnv * fshcq * qsat ( i , j , kx ) * drh qtenvd ( i , j , nl1 ) = fluxq * rsig ( nl1 ) qtenvd ( i , j , kx ) = - fluxq * rsig ( kx ) end if else if ( drh > drh0 ) then fluxq = fvdiq2 * qsat ( i , j , nl1 ) * drh qtenvd ( i , j , nl1 ) = fluxq * rsig ( nl1 ) qtenvd ( i , j , kx ) = - fluxq * rsig ( kx ) end if end do end do ! 3. Vertical diffusion of moisture above the PBL do k = 3 , kx - 2 if ( sigh ( k ) > 0.5 ) then drh0 = rhgrad * ( fsg ( k + 1 ) - fsg ( k )) fvdiq2 = fvdiq * sigh ( k ) do i = 1 , ix do j = 1 , il drh = rh ( i , j , k + 1 ) - rh ( i , j , k ) if ( drh >= drh0 ) then fluxq = fvdiq2 * qsat ( i , j , k ) * drh qtenvd ( i , j , k ) = qtenvd ( i , j , k ) + fluxq * rsig ( k ) qtenvd ( i , j , k + 1 ) = qtenvd ( i , j , k + 1 ) - fluxq * rsig ( k + 1 ) end if end do end do end if end do ! 4. Damping of super-adiabatic lapse rate do k = 1 , nl1 do i = 1 , ix do j = 1 , il se0 = se ( i , j , k + 1 ) + segrad * ( phi ( i , j , k ) - phi ( i , j , k + 1 )) if ( se ( i , j , k ) < se0 ) then fluxse = fvdise * ( se0 - se ( i , j , k )) ttenvd ( i , j , k ) = ttenvd ( i , j , k ) + fluxse * rsig ( k ) do k1 = k + 1 , kx ttenvd ( i , j , k1 ) = ttenvd ( i , j , k1 ) - fluxse * rsig1 ( k ) end do end if end do end do end do end end module","tags":"","loc":"sourcefile/vertical_diffusion.f90.html"},{"title":"horizontal_diffusion.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~horizontal_diffusion.f90~~EfferentGraph sourcefile~horizontal_diffusion.f90 horizontal_diffusion.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~horizontal_diffusion.f90->sourcefile~geometry.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~horizontal_diffusion.f90->sourcefile~physical_constants.f90 sourcefile~params.f90 params.f90 sourcefile~horizontal_diffusion.f90->sourcefile~params.f90 sourcefile~dynamical_constants.f90 dynamical_constants.f90 sourcefile~horizontal_diffusion.f90->sourcefile~dynamical_constants.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~horizontal_diffusion.f90~~AfferentGraph sourcefile~horizontal_diffusion.f90 horizontal_diffusion.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~forcing.f90->sourcefile~horizontal_diffusion.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~initialization.f90->sourcefile~horizontal_diffusion.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~implicit.f90 implicit.f90 sourcefile~implicit.f90->sourcefile~horizontal_diffusion.f90 sourcefile~time_stepping.f90->sourcefile~horizontal_diffusion.f90 sourcefile~time_stepping.f90->sourcefile~implicit.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~tendencies.f90->sourcefile~implicit.f90 var pansourcefilehorizontal_diffusionf90AfferentGraph = svgPanZoom('#sourcefilehorizontal_diffusionf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules horizontal_diffusion Source Code horizontal_diffusion.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !  date: 07/05/2019 !  For performing horizontal diffusion. module horizontal_diffusion use params implicit none private public initialize_horizontal_diffusion , do_horizontal_diffusion public dmp , dmpd , dmps , dmp1 , dmp1d , dmp1s , tcorv , qcorv , tcorh , qcorh interface do_horizontal_diffusion module procedure do_horizontal_diffusion_2d module procedure do_horizontal_diffusion_3d end interface real :: dmp ( mx , nx ) !! Damping coefficient for temperature and vorticity (explicit) real :: dmpd ( mx , nx ) !! Damping coefficient for divergence (explicit) real :: dmps ( mx , nx ) !! Damping coefficient for extra diffusion in the stratosphere (explicit) real :: dmp1 ( mx , nx ) !! Damping coefficient for temperature and vorticity (implicit) real :: dmp1d ( mx , nx ) !! Damping coefficient for divergence (implicit) real :: dmp1s ( mx , nx ) !! Damping coefficient for extra diffusion in the stratosphere (implicit) real :: tcorv ( kx ) !! Vertical component of orographic correction for temperature real :: qcorv ( kx ) !! Vertical component of orographic correction for humidity complex :: tcorh ( mx , nx ) !! Horizontal component of orographic correction for temperature complex :: qcorh ( mx , nx ) !! Horizontal component of orographic correction for humidity contains !> Initializes the arrays used for horizontal diffusion. subroutine initialize_horizontal_diffusion use dynamical_constants , only : thd , thdd , thds , gamma , hscale , hshum use physical_constants , only : grav , rgas use geometry , only : fsg integer :: j , k , npowhd real :: elap , elapn , hdifd , hdiff , hdifs , qexp , rgam , rlap , twn ! 1. Definition of constants if ( mod ( nsteps , 2 ) /= 0 ) stop ' Invalid no. of time steps' ! Power of Laplacian in horizontal diffusion npowhd = 4 ! Coefficients for horizontal diffusion ! Spectral damping coefficients hdiff = 1. / ( thd * 360 0. ) hdifd = 1. / ( thdd * 360 0. ) hdifs = 1. / ( thds * 360 0. ) rlap = 1. / float ( trunc * ( trunc + 1 )) do j = 1 , nx do k = 1 , mx twn = float ( k + j - 2 ) elap = ( twn * ( twn + 1. ) * rlap ) elapn = elap ** npowhd dmp ( k , j ) = hdiff * elapn dmpd ( k , j ) = hdifd * elapn dmps ( k , j ) = hdifs * elap end do ! dmps(1,j)=0. end do ! 5.2 Orographic correction terms for temperature and humidity !     (vertical component) rgam = rgas * gamma / ( 100 0. * grav ) qexp = hscale / hshum tcorv ( 1 ) = 0. qcorv ( 1 ) = 0. qcorv ( 2 ) = 0. do k = 2 , kx tcorv ( k ) = fsg ( k ) ** rgam if ( k . gt . 2 ) qcorv ( k ) = fsg ( k ) ** qexp end do end subroutine !> Adds horizontal diffusion tendency of field to spectral tendency fdt !  using damping coefficients dmp and dmp1. function do_horizontal_diffusion_2d ( field , fdt_in , dmp , dmp1 ) result ( fdt_out ) complex , intent ( in ) :: field ( mx , nx ), fdt_in ( mx , nx ) complex :: fdt_out ( mx , nx ) real , intent ( in ) :: dmp ( mx , nx ), dmp1 ( mx , nx ) fdt_out = ( fdt_in - dmp * field ) * dmp1 end function !> Adds horizontal diffusion tendency of field to spectral tendency fdt !  at all model levels using damping coefficients dmp and dmp1. function do_horizontal_diffusion_3d ( field , fdt_in , dmp , dmp1 ) result ( fdt_out ) complex , intent ( in ) :: field ( mx , nx , kx ), fdt_in ( mx , nx , kx ) complex :: fdt_out ( mx , nx , kx ) real , intent ( in ) :: dmp ( mx , nx ), dmp1 ( mx , nx ) integer :: k do k = 1 , kx fdt_out (:,:, k ) = do_horizontal_diffusion_2d ( field (:,:, k ), fdt_in (:,:, k ), dmp , dmp1 ) end do end function end module","tags":"","loc":"sourcefile/horizontal_diffusion.f90.html"},{"title":"initialization.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~initialization.f90~~EfferentGraph sourcefile~initialization.f90 initialization.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~initialization.f90->sourcefile~input_output.f90 sourcefile~prognostics.f90 prognostics.f90 sourcefile~initialization.f90->sourcefile~prognostics.f90 sourcefile~date.f90 date.f90 sourcefile~initialization.f90->sourcefile~date.f90 sourcefile~geopotential.f90 geopotential.f90 sourcefile~initialization.f90->sourcefile~geopotential.f90 sourcefile~coupler.f90 coupler.f90 sourcefile~initialization.f90->sourcefile~coupler.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~horizontal_diffusion.f90 horizontal_diffusion.f90 sourcefile~initialization.f90->sourcefile~horizontal_diffusion.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~initialization.f90->sourcefile~geometry.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~physics.f90 physics.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~initialization.f90->sourcefile~sea_model.f90 sourcefile~params.f90 params.f90 sourcefile~initialization.f90->sourcefile~params.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~initialization.f90->sourcefile~boundaries.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~initialization.f90->sourcefile~spectral.f90 sourcefile~input_output.f90->sourcefile~date.f90 sourcefile~input_output.f90->sourcefile~geometry.f90 sourcefile~input_output.f90->sourcefile~params.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~input_output.f90->sourcefile~physical_constants.f90 sourcefile~prognostics.f90->sourcefile~input_output.f90 sourcefile~prognostics.f90->sourcefile~geometry.f90 sourcefile~prognostics.f90->sourcefile~params.f90 sourcefile~prognostics.f90->sourcefile~boundaries.f90 sourcefile~prognostics.f90->sourcefile~spectral.f90 sourcefile~prognostics.f90->sourcefile~physical_constants.f90 sourcefile~diagnostics.f90 diagnostics.f90 sourcefile~prognostics.f90->sourcefile~diagnostics.f90 sourcefile~dynamical_constants.f90 dynamical_constants.f90 sourcefile~prognostics.f90->sourcefile~dynamical_constants.f90 sourcefile~date.f90->sourcefile~params.f90 sourcefile~geopotential.f90->sourcefile~geometry.f90 sourcefile~geopotential.f90->sourcefile~params.f90 sourcefile~geopotential.f90->sourcefile~physical_constants.f90 sourcefile~coupler.f90->sourcefile~sea_model.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~coupler.f90->sourcefile~land_model.f90 sourcefile~time_stepping.f90->sourcefile~prognostics.f90 sourcefile~time_stepping.f90->sourcefile~horizontal_diffusion.f90 sourcefile~time_stepping.f90->sourcefile~params.f90 sourcefile~time_stepping.f90->sourcefile~spectral.f90 sourcefile~implicit.f90 implicit.f90 sourcefile~time_stepping.f90->sourcefile~implicit.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 sourcefile~time_stepping.f90->sourcefile~dynamical_constants.f90 sourcefile~horizontal_diffusion.f90->sourcefile~geometry.f90 sourcefile~horizontal_diffusion.f90->sourcefile~params.f90 sourcefile~horizontal_diffusion.f90->sourcefile~physical_constants.f90 sourcefile~horizontal_diffusion.f90->sourcefile~dynamical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~forcing.f90->sourcefile~date.f90 sourcefile~forcing.f90->sourcefile~horizontal_diffusion.f90 sourcefile~forcing.f90->sourcefile~sea_model.f90 sourcefile~forcing.f90->sourcefile~params.f90 sourcefile~forcing.f90->sourcefile~boundaries.f90 sourcefile~forcing.f90->sourcefile~spectral.f90 sourcefile~forcing.f90->sourcefile~land_model.f90 sourcefile~forcing.f90->sourcefile~physical_constants.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~forcing.f90->sourcefile~surface_fluxes.f90 sourcefile~mod_radcon.f90 mod_radcon.f90 sourcefile~forcing.f90->sourcefile~mod_radcon.f90 sourcefile~longwave_radiation.f90 longwave_radiation.f90 sourcefile~forcing.f90->sourcefile~longwave_radiation.f90 sourcefile~humidity.f90 humidity.f90 sourcefile~forcing.f90->sourcefile~humidity.f90 sourcefile~forcing.f90->sourcefile~dynamical_constants.f90 sourcefile~shortwave_radiation.f90 shortwave_radiation.f90 sourcefile~forcing.f90->sourcefile~shortwave_radiation.f90 sourcefile~physics.f90->sourcefile~geometry.f90 sourcefile~physics.f90->sourcefile~sea_model.f90 sourcefile~physics.f90->sourcefile~params.f90 sourcefile~physics.f90->sourcefile~boundaries.f90 sourcefile~physics.f90->sourcefile~spectral.f90 sourcefile~physics.f90->sourcefile~land_model.f90 sourcefile~large_scale_condensation.f90 large_scale_condensation.f90 sourcefile~physics.f90->sourcefile~large_scale_condensation.f90 sourcefile~physics.f90->sourcefile~physical_constants.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~auxiliaries.f90 auxiliaries.f90 sourcefile~physics.f90->sourcefile~auxiliaries.f90 sourcefile~physics.f90->sourcefile~longwave_radiation.f90 sourcefile~sppt.f90 sppt.f90 sourcefile~physics.f90->sourcefile~sppt.f90 sourcefile~physics.f90->sourcefile~humidity.f90 sourcefile~physics.f90->sourcefile~shortwave_radiation.f90 sourcefile~vertical_diffusion.f90 vertical_diffusion.f90 sourcefile~physics.f90->sourcefile~vertical_diffusion.f90 sourcefile~convection.f90 convection.f90 sourcefile~physics.f90->sourcefile~convection.f90 sourcefile~sea_model.f90->sourcefile~input_output.f90 sourcefile~sea_model.f90->sourcefile~date.f90 sourcefile~sea_model.f90->sourcefile~geometry.f90 sourcefile~sea_model.f90->sourcefile~params.f90 sourcefile~sea_model.f90->sourcefile~boundaries.f90 sourcefile~sea_model.f90->sourcefile~physical_constants.f90 sourcefile~sea_model.f90->sourcefile~auxiliaries.f90 sourcefile~interpolation.f90 interpolation.f90 sourcefile~sea_model.f90->sourcefile~interpolation.f90 sourcefile~sea_model.f90->sourcefile~mod_radcon.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~boundaries.f90->sourcefile~params.f90 sourcefile~boundaries.f90->sourcefile~spectral.f90 sourcefile~boundaries.f90->sourcefile~physical_constants.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~spectral.f90->sourcefile~params.f90 sourcefile~spectral.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~land_model.f90->sourcefile~input_output.f90 sourcefile~land_model.f90->sourcefile~date.f90 sourcefile~land_model.f90->sourcefile~params.f90 sourcefile~land_model.f90->sourcefile~boundaries.f90 sourcefile~land_model.f90->sourcefile~auxiliaries.f90 sourcefile~land_model.f90->sourcefile~interpolation.f90 sourcefile~large_scale_condensation.f90->sourcefile~geometry.f90 sourcefile~large_scale_condensation.f90->sourcefile~params.f90 sourcefile~large_scale_condensation.f90->sourcefile~physical_constants.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 sourcefile~diagnostics.f90->sourcefile~params.f90 sourcefile~diagnostics.f90->sourcefile~spectral.f90 sourcefile~surface_fluxes.f90->sourcefile~geometry.f90 sourcefile~surface_fluxes.f90->sourcefile~params.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 sourcefile~surface_fluxes.f90->sourcefile~physical_constants.f90 sourcefile~surface_fluxes.f90->sourcefile~mod_radcon.f90 sourcefile~surface_fluxes.f90->sourcefile~humidity.f90 sourcefile~auxiliaries.f90->sourcefile~params.f90 sourcefile~interpolation.f90->sourcefile~date.f90 sourcefile~interpolation.f90->sourcefile~params.f90 sourcefile~implicit.f90->sourcefile~horizontal_diffusion.f90 sourcefile~implicit.f90->sourcefile~geometry.f90 sourcefile~implicit.f90->sourcefile~params.f90 sourcefile~implicit.f90->sourcefile~physical_constants.f90 sourcefile~implicit.f90->sourcefile~dynamical_constants.f90 sourcefile~matrix_inversion.f90 matrix_inversion.f90 sourcefile~implicit.f90->sourcefile~matrix_inversion.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~legendre.f90->sourcefile~params.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~mod_radcon.f90->sourcefile~params.f90 sourcefile~longwave_radiation.f90->sourcefile~geometry.f90 sourcefile~longwave_radiation.f90->sourcefile~params.f90 sourcefile~longwave_radiation.f90->sourcefile~physical_constants.f90 sourcefile~longwave_radiation.f90->sourcefile~mod_radcon.f90 sourcefile~sppt.f90->sourcefile~params.f90 sourcefile~sppt.f90->sourcefile~spectral.f90 sourcefile~sppt.f90->sourcefile~physical_constants.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 sourcefile~fourier.f90->sourcefile~params.f90 sourcefile~tendencies.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90->sourcefile~geopotential.f90 sourcefile~tendencies.f90->sourcefile~geometry.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~tendencies.f90->sourcefile~params.f90 sourcefile~tendencies.f90->sourcefile~spectral.f90 sourcefile~tendencies.f90->sourcefile~physical_constants.f90 sourcefile~tendencies.f90->sourcefile~implicit.f90 sourcefile~humidity.f90->sourcefile~params.f90 sourcefile~shortwave_radiation.f90->sourcefile~geometry.f90 sourcefile~shortwave_radiation.f90->sourcefile~params.f90 sourcefile~shortwave_radiation.f90->sourcefile~mod_radcon.f90 sourcefile~vertical_diffusion.f90->sourcefile~geometry.f90 sourcefile~vertical_diffusion.f90->sourcefile~params.f90 sourcefile~vertical_diffusion.f90->sourcefile~physical_constants.f90 sourcefile~convection.f90->sourcefile~geometry.f90 sourcefile~convection.f90->sourcefile~params.f90 sourcefile~convection.f90->sourcefile~physical_constants.f90 var pansourcefileinitializationf90EfferentGraph = svgPanZoom('#sourcefileinitializationf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~initialization.f90~~AfferentGraph sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules initialization Source Code initialization.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !  date: 08/05/2019 !  The master initialization module. module initialization implicit none private public initialize contains !> Initializes everything. subroutine initialize use params , only : issty0 , initialize_params use date , only : isst0 , initialize_date , start_datetime use coupler , only : initialize_coupler use sea_model , only : sea_coupling_flag , sst_anomaly_coupling_flag use geometry , only : initialize_geometry use spectral , only : initialize_spectral use geopotential , only : initialize_geopotential use horizontal_diffusion , only : initialize_horizontal_diffusion use physics , only : initialize_physics use input_output , only : output use time_stepping , only : first_step use boundaries , only : initialize_boundaries use prognostics , only : initialize_prognostics use forcing , only : set_forcing call print_speedy_title ! Initialize model parameters call initialize_params ! Initialize date call initialize_date ! Initialize month index for reading SST anomaly file isst0 = ( start_datetime % year - issty0 ) * 12 + start_datetime % month ! Check consistency of coupling and prescribed SST anomaly flags if ( sea_coupling_flag >= 4 ) sst_anomaly_coupling_flag = 1 ! ========================================================================= ! Initialization of atmospheric model constants and variables ! ========================================================================= ! Initialize model geometry call initialize_geometry ! Initialize spectral transforms call initialize_spectral ! Initialize geopotential calculations call initialize_geopotential ! Initialize horizontal diffusion call initialize_horizontal_diffusion ! Initialize constants for physical parametrization call initialize_physics ! Initialize boundary conditions (land-sea mask, sea ice etc.) call initialize_boundaries ! Initialize model variables call initialize_prognostics ! ========================================================================= ! Initialization of coupled modules (land, sea, ice) ! ========================================================================= call initialize_coupler ! ========================================================================= ! Initialization of first time step ! ========================================================================= ! Set up the forcing fields for the first time step call set_forcing ( 0 ) ! Do the initial (2nd-order) time step, initialize the semi-implicit scheme call first_step end subroutine !> Prints SPEEDY.f90 banner. subroutine print_speedy_title write ( * , '(A)' ) '' write ( * , '(A)' ) '  _____ ______  _____  _____ ______ __   __     __  _____  _____' write ( * , '(A)' ) ' /  ___|| ___ \\|  ___||  ___||  _  \\\\ \\ / /    / _||  _  ||  _  |' write ( * , '(A)' ) ' \\ `--. | |_/ /| |__  | |__  | | | | \\ V /    | |_ | |_| || |/  |' write ( * , '(A)' ) '  `--. \\|  __/ |  __| |  __| | | | |  \\ /     |  _|\\____ ||  /| |' write ( * , '(A)' ) ' /\\__/ /| |    | |___ | |___ | |/ /   | |   _ | |  .___/ /\\ |_/ /' write ( * , '(A)' ) ' \\____/ \\_|    \\____/ \\____/ |___/    \\_/  (_)|_|  \\____/  \\___/' write ( * , '(A)' ) '' end subroutine end module","tags":"","loc":"sourcefile/initialization.f90.html"},{"title":"land_model.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~land_model.f90~~EfferentGraph sourcefile~land_model.f90 land_model.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~land_model.f90->sourcefile~input_output.f90 sourcefile~auxiliaries.f90 auxiliaries.f90 sourcefile~land_model.f90->sourcefile~auxiliaries.f90 sourcefile~interpolation.f90 interpolation.f90 sourcefile~land_model.f90->sourcefile~interpolation.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~land_model.f90->sourcefile~boundaries.f90 sourcefile~params.f90 params.f90 sourcefile~land_model.f90->sourcefile~params.f90 sourcefile~date.f90 date.f90 sourcefile~land_model.f90->sourcefile~date.f90 sourcefile~input_output.f90->sourcefile~params.f90 sourcefile~input_output.f90->sourcefile~date.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~input_output.f90->sourcefile~geometry.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~input_output.f90->sourcefile~physical_constants.f90 sourcefile~auxiliaries.f90->sourcefile~params.f90 sourcefile~interpolation.f90->sourcefile~params.f90 sourcefile~interpolation.f90->sourcefile~date.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~boundaries.f90->sourcefile~params.f90 sourcefile~boundaries.f90->sourcefile~spectral.f90 sourcefile~boundaries.f90->sourcefile~physical_constants.f90 sourcefile~date.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~spectral.f90->sourcefile~params.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~spectral.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 sourcefile~legendre.f90->sourcefile~params.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~fourier.f90->sourcefile~params.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 var pansourcefileland_modelf90EfferentGraph = svgPanZoom('#sourcefileland_modelf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~land_model.f90~~AfferentGraph sourcefile~land_model.f90 land_model.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~forcing.f90->sourcefile~land_model.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~forcing.f90->sourcefile~surface_fluxes.f90 sourcefile~physics.f90 physics.f90 sourcefile~physics.f90->sourcefile~land_model.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~coupler.f90 coupler.f90 sourcefile~coupler.f90->sourcefile~land_model.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~speedy.f90->sourcefile~coupler.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~initialization.f90->sourcefile~coupler.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 var pansourcefileland_modelf90AfferentGraph = svgPanZoom('#sourcefileland_modelf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules land_model Source Code land_model.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !  date: 09/05/2019 !  For running the land-surface model. module land_model use params implicit none private public stl_am , snowd_am , soilw_am public land_model_init , couple_land_atm public fmask_l public land_coupling_flag public sd2sc real :: rhcapl ( ix , il ) !! 1/heat capacity (land) real :: cdland ( ix , il ) !! 1/dissipation time (land) ! Daily observed climatological fields over land real :: stlcl_ob ( ix , il ) !! Climatological land surface temperature real :: snowdcl_ob ( ix , il ) !! Climatological snow depth (water equivalent) real :: soilwcl_ob ( ix , il ) !! Climatological soil water availability ! Land surface fields used by atmospheric model real :: stl_am ( ix , il ) !! Land surface temperature real :: snowd_am ( ix , il ) !! Snow depth (water equivalent) real :: soilw_am ( ix , il ) !! Soil water availability ! Land surface fields from land model real :: stl_lm ( ix , il ) !! Land-model surface temperature ! Land masks real :: fmask_l ( ix , il ) !! Fraction of land real :: bmask_l ( ix , il ) !! Binary land mask real :: stl12 ( ix , il , 12 ) !! Land surface temperature monthly-mean climatology real :: snowd12 ( ix , il , 12 ) !! Snow depth (water equivalent) monthly-mean climatology real :: soilw12 ( ix , il , 12 ) !! Soil water availability monthly-mean climatology integer :: land_coupling_flag = 1 !! Flag for land-coupling (0: off, 1: on) real , parameter :: sd2sc = 6 0.0 !! Snow depth (mm water) corresponding to snow cover = 1 contains !> Initializes land model. subroutine land_model_init use input_output , only : load_boundary_file use boundaries , only : forchk , fmask , alb0 , fillsf ! Auxiliary variables integer :: i , j , month real :: dmask ( ix , il ) ! domain mask real :: depth_soil , depth_lice , tdland , hcapl , hcapli , flandmin ! Soil moisture parameters ! Soil wetness at field capacity (volume fraction) real :: swcap = 0.30 ! Soil wetness at wilting point  (volume fraction) real :: swwil = 0.17 ! Threshold for land-sea mask definition (i.e. minimum fraction of ! either land or sea) real :: thrsh = 0.1 real :: rsw , sdep1 , sdep2 , swroot , swwil2 real , dimension ( ix , il ) :: veg_low , veg_high , veg , swl1 , swl2 integer :: idep2 ! ========================================================================= ! Initialize land-surface boundary conditions ! ========================================================================= ! Fractional and binary land masks fmask_l = fmask do j = 1 , il do i = 1 , ix if ( fmask_l ( i , j ) >= thrsh ) then bmask_l ( i , j ) = 1.0 if ( fmask ( i , j ) > ( 1.0 - thrsh )) fmask_l ( i , j ) = 1.0 else bmask_l ( i , j ) = 0.0 fmask_l ( i , j ) = 0.0 end if end do end do ! Land-surface temperature do month = 1 , 12 stl12 (:,:, month ) = load_boundary_file ( \"land.nc\" , \"stl\" , month ) call fillsf ( stl12 (:,:, month ), 0.0 ) end do call forchk ( bmask_l , 12 , 0.0 , 40 0.0 , 27 3.0 , stl12 ) ! Snow depth do month = 1 , 12 snowd12 (:,:, month ) = load_boundary_file ( \"snow.nc\" , \"snowd\" , month ) end do call forchk ( bmask_l , 12 , 0.0 , 2000 0.0 , 0.0 , snowd12 ) ! Read soil moisture and compute soil water availability using vegetation fraction ! Read vegetation fraction veg_high = load_boundary_file ( \"surface.nc\" , \"vegh\" ) veg_low = load_boundary_file ( \"surface.nc\" , \"vegl\" ) ! Combine high and low vegetation fractions veg = max ( 0.0 , veg_high + 0.8 * veg_low ) ! Read soil moisture sdep1 = 7 0.0 idep2 = 3 sdep2 = idep2 * sdep1 swwil2 = idep2 * swwil rsw = 1.0 / ( swcap + idep2 * ( swcap - swwil )) do month = 1 , 12 ! Combine soil water content from two top layers swl1 = load_boundary_file ( \"soil.nc\" , \"swl1\" , month ) swl2 = load_boundary_file ( \"soil.nc\" , \"swl2\" , month ) do j = 1 , il do i = 1 , ix swroot = idep2 * swl2 ( i , j ) soilw12 ( i , j , month ) = min ( 1.0 , rsw * ( swl1 ( i , j ) + veg ( i , j ) & & * max ( 0.0 , swroot - swwil2 ))) end do end do end do call forchk ( bmask_l , 12 , 0.0 , 1 0.0 , 0.0 , soilw12 ) ! ========================================================================= ! Set heat capacities and dissipation times for soil and ice-sheet layers ! ========================================================================= ! Model parameters (default values) ! Soil layer depth (m) depth_soil = 1.0 ! Land-ice depth (m) depth_lice = 5.0 ! Dissipation time (days) for land-surface temp. anomalies tdland = 4 0. ! Minimum fraction of land for the definition of anomalies flandmin = 1. / 3. ! Heat capacities per m&#94;2 (depth*heat_cap/m&#94;3) hcapl = depth_soil * 2.50e+6 hcapli = depth_lice * 1.93e+6 ! 2. Compute constant fields ! Set domain mask (blank out sea points) dmask (:,:) = 1. do j = 1 , il do i = 1 , ix if ( fmask_l ( i , j ). lt . flandmin ) dmask ( i , j ) = 0 end do end do ! Set time_step/heat_capacity and dissipation fields do j = 1 , il do i = 1 , ix if ( alb0 ( i , j ). lt . 0.4 ) then rhcapl ( i , j ) = delt / hcapl else rhcapl ( i , j ) = delt / hcapli endif end do end do cdland (:,:) = dmask (:,:) * tdland / ( 1. + dmask (:,:) * tdland ) end subroutine !> Exchanges fluxes between land and atmosphere. subroutine couple_land_atm ( day ) use date , only : imont1 use interpolation , only : forin5 , forint integer , intent ( in ) :: day !! The day (starting at 0 for the first time step) ! Interpolate climatological fields to actual date ! Climatological land surface temperature call forin5 ( imont1 , stl12 , stlcl_ob ) ! Climatological snow depth call forint ( imont1 , snowd12 , snowdcl_ob ) ! Climatological soil water availability call forint ( imont1 , soilw12 , soilwcl_ob ) ! If it's the first day then initialise the land surface ! temperature from climatology if ( day == 0 ) then stl_lm = stlcl_ob stl_am = stlcl_ob else ! Run the land model if the land model flags is switched on if ( land_coupling_flag == 1 ) then call run_land_model stl_am = stl_lm ! Otherwise get the land surface from climatology else stl_am = stlcl_ob end if end if ! Always get snow depth and soil water availability from climatology snowd_am = snowdcl_ob soilw_am = soilwcl_ob end subroutine !> Integrates slab land-surface model for one day. subroutine run_land_model use auxiliaries , only : hfluxn ! Surface temperature anomaly real :: tanom ( ix , il ) ! Land-surface (soil/ice-sheet) layer ! Anomaly w.r.t. final-time climatological temperature tanom = stl_lm - stlcl_ob print * , stl_lm ( 1 , 1 : 4 ) - stlcl_ob ( 1 , 1 : 4 ) ! Time evolution of temperature anomaly tanom = cdland * ( tanom + rhcapl * hfluxn (:,:, 1 )) ! Full surface temperature at final time stl_lm = tanom + stlcl_ob end subroutine end module","tags":"","loc":"sourcefile/land_model.f90.html"},{"title":"matrix_inversion.f90 – SPEEDY.f90","text":"Files dependent on this one sourcefile~~matrix_inversion.f90~~AfferentGraph sourcefile~matrix_inversion.f90 matrix_inversion.f90 sourcefile~implicit.f90 implicit.f90 sourcefile~implicit.f90->sourcefile~matrix_inversion.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~implicit.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~time_stepping.f90->sourcefile~implicit.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 var pansourcefilematrix_inversionf90AfferentGraph = svgPanZoom('#sourcefilematrix_inversionf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules matrix_inversion Source Code matrix_inversion.f90 Source Code module matrix_inversion implicit none private public inv contains subroutine ludcmp ( a , n , np , indx , d ) real , intent ( inout ) :: a ( np , np ), d integer , intent ( inout ) :: indx ( n ) integer , intent ( in ) :: n , np integer , parameter :: nmax = 100 real , parameter :: tiny = 1.0e-20 integer :: i , j , k , imax real :: vv ( nmax ), aamax , dum , sum d = 1.0 do i = 1 , n aamax = 0. do j = 1 , n if ( abs ( a ( i , j )). gt . aamax ) aamax = abs ( a ( i , j )) end do if ( aamax . eq . 0. ) stop 'singular' vv ( i ) = 1. / aamax end do do j = 1 , n if ( j . gt . 1 ) then do i = 1 , j - 1 sum = a ( i , j ) if ( i . gt . 1 ) then do k = 1 , i - 1 sum = sum - a ( i , k ) * a ( k , j ) end do a ( i , j ) = sum end if end do end if aamax = 0. do i = j , n sum = a ( i , j ) if ( j . gt . 1 ) then do k = 1 , j - 1 sum = sum - a ( i , k ) * a ( k , j ) end do a ( i , j ) = sum end if dum = vv ( i ) * abs ( sum ) if ( dum . ge . aamax ) then imax = i aamax = dum end if end do if ( j . ne . imax ) then do k = 1 , n dum = a ( imax , k ) a ( imax , k ) = a ( j , k ) a ( j , k ) = dum end do d =- d vv ( imax ) = vv ( j ) end if indx ( j ) = imax if ( j . ne . n ) then if ( a ( j , j ). eq . 0 ) a ( j , j ) = tiny dum = 1. / a ( j , j ) do i = j + 1 , n a ( i , j ) = a ( i , j ) * dum end do end if end do if ( a ( n , n ). eq . 0. ) a ( n , n ) = tiny end subroutine lubksb ( a , n , np , indx , b ) real , intent ( inout ) :: a ( np , np ), b ( n ) integer , intent ( in ) :: n , np , indx ( n ) integer :: ii , i , ll , j real :: sum ii = 0 do i = 1 , n ll = indx ( i ) sum = b ( ll ) b ( ll ) = b ( i ) if ( ii . ne . 0 ) then do j = ii , i - 1 sum = sum - a ( i , j ) * b ( j ) end do else if ( sum . ne . 0 ) then ii = i end if b ( i ) = sum end do do i = n , 1 , - 1 sum = b ( i ) if ( i . lt . n ) then do j = i + 1 , n sum = sum - a ( i , j ) * b ( j ) end do end if b ( i ) = sum / a ( i , i ) end do end subroutine inv ( a , y , indx , n ) real , intent ( inout ) :: a ( n , n ), y ( n , n ) integer , intent ( inout ) :: indx ( n ) integer , intent ( in ) :: n integer :: i real :: d y = 0.0 do i = 1 , n y ( i , i ) = 1. end do call ludcmp ( a , n , n , indx , d ) do i = 1 , n call lubksb ( a , n , n , indx , y ( 1 , i )) end do end end module","tags":"","loc":"sourcefile/matrix_inversion.f90.html"},{"title":"sea_model.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~sea_model.f90~~EfferentGraph sourcefile~sea_model.f90 sea_model.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~sea_model.f90->sourcefile~input_output.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~sea_model.f90->sourcefile~physical_constants.f90 sourcefile~interpolation.f90 interpolation.f90 sourcefile~sea_model.f90->sourcefile~interpolation.f90 sourcefile~auxiliaries.f90 auxiliaries.f90 sourcefile~sea_model.f90->sourcefile~auxiliaries.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~sea_model.f90->sourcefile~boundaries.f90 sourcefile~mod_radcon.f90 mod_radcon.f90 sourcefile~sea_model.f90->sourcefile~mod_radcon.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~sea_model.f90->sourcefile~geometry.f90 sourcefile~params.f90 params.f90 sourcefile~sea_model.f90->sourcefile~params.f90 sourcefile~date.f90 date.f90 sourcefile~sea_model.f90->sourcefile~date.f90 sourcefile~input_output.f90->sourcefile~physical_constants.f90 sourcefile~input_output.f90->sourcefile~geometry.f90 sourcefile~input_output.f90->sourcefile~params.f90 sourcefile~input_output.f90->sourcefile~date.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 sourcefile~interpolation.f90->sourcefile~params.f90 sourcefile~interpolation.f90->sourcefile~date.f90 sourcefile~auxiliaries.f90->sourcefile~params.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~boundaries.f90->sourcefile~physical_constants.f90 sourcefile~boundaries.f90->sourcefile~params.f90 sourcefile~boundaries.f90->sourcefile~spectral.f90 sourcefile~mod_radcon.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~date.f90->sourcefile~params.f90 sourcefile~spectral.f90->sourcefile~physical_constants.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~spectral.f90->sourcefile~params.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~legendre.f90->sourcefile~params.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 sourcefile~fourier.f90->sourcefile~params.f90 var pansourcefilesea_modelf90EfferentGraph = svgPanZoom('#sourcefilesea_modelf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~sea_model.f90~~AfferentGraph sourcefile~sea_model.f90 sea_model.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~forcing.f90->sourcefile~sea_model.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~initialization.f90->sourcefile~sea_model.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~physics.f90 physics.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~coupler.f90 coupler.f90 sourcefile~initialization.f90->sourcefile~coupler.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~physics.f90->sourcefile~sea_model.f90 sourcefile~coupler.f90->sourcefile~sea_model.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~speedy.f90->sourcefile~coupler.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 var pansourcefilesea_modelf90AfferentGraph = svgPanZoom('#sourcefilesea_modelf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules sea_model Source Code sea_model.f90 Source Code module sea_model use params implicit none private public sea_model_init , couple_sea_atm public fmask_s public sstcl_ob , sst_am , sice_am , tice_am , ssti_om public sea_coupling_flag , sst_anomaly_coupling_flag ! Constant parameters and fields in sea/ice model real :: rhcaps ( ix , il ) ! 1./heat_capacity (sea) real :: rhcapi ( ix , il ) ! 1./heat_capacity (ice) real :: cdsea ( ix , il ) ! 1./dissip_time (sea) real :: cdice ( ix , il ) ! 1./dissip_time (ice) real :: beta = 1.0 ! Heat flux coef. at sea/ice int. ! Sea masks real :: fmask_s ( ix , il ) ! Fraction of sea real :: bmask_s ( ix , il ) ! Binary sea mask real :: deglat_s ( il ) ! Grid latitudes ! Monthly-mean climatological fields over sea real :: sst12 ( ix , il , 12 ) ! Sea/ice surface temperature real :: sice12 ( ix , il , 12 ) ! Sea ice fraction ! SST anomaly fields real :: sstan3 ( ix , il , 3 ) ! SST anomaly in 3 consecutive months ! Climatological fields from model output real :: hfseacl ( ix , il ) ! Annual-mean heat flux into sea sfc. real :: sstom12 ( ix , il , 12 ) ! Ocean model SST climatology ! Daily observed climatological fields over sea real :: sstcl_ob ( ix , il ) ! Observed clim. SST real :: sicecl_ob ( ix , il ) ! Clim. sea ice fraction real :: ticecl_ob ( ix , il ) ! Clim. sea ice temperature real :: sstan_ob ( ix , il ) ! Daily observed SST anomaly ! Daily climatological fields from ocean model real :: sstcl_om ( ix , il ) ! Ocean model clim. SST ! Sea sfc. fields used by atmospheric model real :: sst_am ( ix , il ) ! SST (full-field) real :: sstan_am ( ix , il ) ! SST anomaly real :: sice_am ( ix , il ) ! Sea ice fraction real :: tice_am ( ix , il ) ! Sea ice temperature ! Sea sfc. fields from ocean/sea-ice model real :: sst_om ( ix , il ) ! Ocean model SST real :: sice_om ( ix , il ) ! Model sea ice fraction real :: tice_om ( ix , il ) ! Model sea ice temperature real :: ssti_om ( ix , il ) ! Model SST + sea ice temp. ! Weight for obs. SST anomaly in coupled runs real :: wsst_ob ( ix , il ) ! Flag for sea-surface temperature coupling ! 0 = precribed SST, no coupling ! 1 = precribed SST, ocean model forced by atmosphere ! 2 = full (uncorrected) SST from coupled ocean model ! 3 = SST anomaly from coupled ocean model + observed SST climatology ! 4 = as 3 with prescribed SST anomaly in ElNino region integer :: sea_coupling_flag = 0 ! Flag for sea-ice coupling integer :: ice_coupling_flag = 1 ! Flag for observed SST anomaly ! 0 = climatological SST ! 1 = observed anomaly ! (active if sea_coupling_flag = 0, 1; set to 1 if sea_coupling_flag = 4) integer :: sst_anomaly_coupling_flag = 1 contains ! Initialization of sea model subroutine sea_model_init use boundaries , only : fmask , fillsf , forchk use date , only : isst0 use geometry , only : radang use input_output , only : load_boundary_file ! Domain mask real :: dmask ( ix , il ) ! Domain flags logical :: l_globe , l_northe , l_natlan , l_npacif , l_tropic , l_indian ! Heat capacities of mixed-layer and sea-ice real :: hcaps ( il ) real :: hcapi ( il ) integer :: i , j , month real :: coslat , crad ! 1. Set geographical domain, heat capacities and dissipation times !    for sea (mixed layer) and sea-ice ! Model parameters (default values) ! ocean mixed layer depth: d + (d0-d)*(cos_lat)&#94;3 real :: depth_ml = 6 0. ! High-latitude depth real :: dept0_ml = 4 0. ! Minimum depth (tropics) ! sea-ice depth : d + (d0-d)*(cos_lat)&#94;2 real :: depth_ice = 2.5 ! High-latitude depth real :: dept0_ice = 1.5 ! Minimum depth ! Dissipation time (days) for sea-surface temp. anomalies real :: tdsst = 9 0. ! Minimum fraction of sea for the definition of anomalies real :: fseamin = 1. / 3. ! Dissipation time (days) for sea-ice temp. anomalies real :: tdice = 3 0.0 ! Threshold for land-sea mask definition (i.e. minimum fraction of ! either land or sea) real :: thrsh = 0.1 ! Geographical domain ! note : more than one regional domain may be set .true. l_globe = . true . ! global domain l_northe = . false . ! Northern hem. oceans (lat > 20N) l_natlan = . false . ! N. Atlantic (lat 20-80N, lon 100W-45E) l_npacif = . false . ! N. Pacific  (lat 20-80N, lon 100E-100W) l_tropic = . false . ! Tropics (lat 30S-30N) l_indian = . false . ! Indian Ocean (lat 30S-30N, lon 30-120E) ! ========================================================================= ! Initialize sea-surface boundary conditions ! ========================================================================= ! Fractional and binary sea masks do j = 1 , il do i = 1 , ix fmask_s ( i , j ) = 1.0 - fmask ( i , j ) if ( fmask_s ( i , j ) >= thrsh ) then bmask_s ( i , j ) = 1.0 if ( fmask_s ( i , j ) > ( 1.0 - thrsh )) fmask_s ( i , j ) = 1.0 else bmask_s ( i , j ) = 0.0 fmask_s ( i , j ) = 0.0 end if end do end do ! Grid latitudes for sea-surface variables deglat_s = radang * 9 0.0 / asin ( 1.0 ) ! SST do month = 1 , 12 sst12 (:,:, month ) = load_boundary_file ( \"sea_surface_temperature.nc\" , \"sst\" , month ) call fillsf ( sst12 (:,:, month ), 0.0 ) end do call forchk ( bmask_s , 12 , 10 0.0 , 40 0.0 , 27 3.0 , sst12 ) ! Sea ice concentration do month = 1 , 12 sice12 (:,:, month ) = max ( load_boundary_file ( \"sea_ice.nc\" , \"icec\" , month ), 0.0 ) end do call forchk ( bmask_s , 12 , 0.0 , 1.0 , 0.0 , sice12 ) ! SST anomalies for initial and preceding/following months if ( sst_anomaly_coupling_flag > 0 ) then write ( * , '(A,I0.2)' ) 'SST anomalies are read starting from month ' , isst0 do month = 1 , 3 if (( isst0 <= 1 . and . month /= 2 ) . or . isst0 > 1 ) then sstan3 (:,:, month ) = load_boundary_file ( \"sea_surface_temperature_anomaly.nc\" , & & \"ssta\" , isst0 - 2 + month , 420 ) end if end do call forchk ( bmask_s , 3 , - 5 0.0 , 5 0.0 , 0.0 , sstan3 ) end if ! Climatological fields for the ocean model (TO BE RECODED) ! Annual-mean heat flux into sea-surface hfseacl = 0.0 if ( sea_coupling_flag >= 1 ) then stop \"Model behaviour when sea_coupling_flag >= 1 not implemented yet\" end if ! Ocean model SST climatology: ! defined by adding SST model bias to observed climatology ! (bias may be defined in a different period from climatology) if ( sea_coupling_flag >= 3 ) then stop \"Model behaviour when sea_coupling_flag >= 3 not implemented yet\" end if ! ========================================================================= ! Compute heat capacities ! ========================================================================= ! Heat flux coefficient at sea/ice interface [(W/m&#94;2)/deg] beta = 1. ! Heat capacities per m&#94;2 (depth*heat_cap/m&#94;3) crad = asin ( 1. ) / 9 0. do j = 1 , il coslat = cos ( crad * deglat_s ( j )) hcaps ( j ) = 4.18e+6 * ( depth_ml + ( dept0_ml - depth_ml ) * coslat ** 3 ) hcapi ( j ) = 1.93e+6 * ( depth_ice + ( dept0_ice - depth_ice ) * coslat ** 2 ) end do ! ========================================================================= ! Compute constant parameters and fields ! ========================================================================= ! Set domain mask if ( l_globe ) then dmask (:,:) = 1. else dmask (:,:) = 0. if ( l_northe ) call sea_domain ( 'northe' , dmask ) if ( l_natlan ) call sea_domain ( 'natlan' , dmask ) if ( l_npacif ) call sea_domain ( 'npacif' , dmask ) if ( l_tropic ) call sea_domain ( 'tropic' , dmask ) if ( l_indian ) call sea_domain ( 'indian' , dmask ) end if ! Smooth latitudinal boundaries and blank out land points do j = 2 , il - 1 rhcaps (:, j ) = 0.25 * ( dmask (:, j - 1 ) + 2 * dmask (:, j ) + dmask (:, j + 1 )) end do dmask (:, 2 : il - 1 ) = rhcaps (:, 2 : il - 1 ) do j = 1 , il do i = 1 , ix if ( fmask_s ( i , j ). lt . fseamin ) dmask ( i , j ) = 0 end do end do ! Set heat capacity and dissipation time over selected domain do j = 1 , il rhcaps (:, j ) = delt / hcaps ( j ) rhcapi (:, j ) = delt / hcapi ( j ) end do cdsea = dmask * tdsst / ( 1. + dmask * tdsst ) cdice = dmask * tdice / ( 1. + dmask * tdice ) end subroutine couple_sea_atm ( day ) use date , only : model_datetime , imont1 use interpolation , only : forin5 , forint integer , intent ( in ) :: day integer :: i , j real :: sstcl0 , sstfr ! 1. Interpolate climatological fields and obs. SST anomaly !    to actual date ! Climatological SST call forin5 ( imont1 , sst12 , sstcl_ob ) ! Climatological sea ice fraction call forint ( imont1 , sice12 , sicecl_ob ) ! SST anomaly if ( sst_anomaly_coupling_flag . gt . 0 ) then if ( model_datetime % day . eq . 1. and . day . gt . 0 ) call obs_ssta call forint ( 2 , sstan3 , sstan_ob ) end if ! Ocean model climatological SST if ( sea_coupling_flag . ge . 3 ) then call forin5 ( imont1 , sstom12 , sstcl_om ) end if ! Adjust climatological fields over sea ice ! SST at freezing point sstfr = 27 3.2 - 1.8 do i = 1 , ix do j = 1 , il sstcl0 = sstcl_ob ( i , j ) if ( sstcl_ob ( i , j ) > sstfr ) then sicecl_ob ( i , j ) = min ( 0.5 , sicecl_ob ( i , j )) ticecl_ob ( i , j ) = sstfr if ( sicecl_ob ( i , j ) . gt . 0.0 ) then sstcl_ob ( i , j ) = sstfr + ( sstcl_ob ( i , j ) - sstfr ) / ( 1.0 - sicecl_ob ( i , j )) end if else sicecl_ob ( i , j ) = max ( 0.5 , sicecl_ob ( i , j )) ticecl_ob ( i , j ) = sstfr + ( sstcl_ob ( i , j ) - sstfr ) / sicecl_ob ( i , j ) sstcl_ob ( i , j ) = sstfr end if if ( sea_coupling_flag >= 3 ) sstcl_om ( i , j ) = sstcl_om ( i , j ) + ( sstcl_ob ( i , j ) - sstcl0 ) end do end do if ( day == 0 ) then ! 2. Initialize prognostic variables of ocean/ice model !    in case of no restart or no coupling sst_om = sstcl_ob ! SST tice_om = ticecl_ob ! sea ice temperature sice_om = sicecl_ob ! sea ice fraction if ( sea_coupling_flag <= 0 ) sst_om = 0.0 ! 3. Compute additional sea/ice variables wsst_ob = 0. if ( sea_coupling_flag >= 4 ) call sea_domain ( 'elnino' , wsst_ob ) else if ( sea_coupling_flag > 0 . or . ice_coupling_flag > 0 ) then ! 1. Run ocean mixed layer or !    call message-passing routines to receive data from ocean model call run_sea_model end if end if ! 3. Compute sea-sfc. anomalies and full fields for atm. model ! 3.1 SST sstan_am = 0.0 if ( sea_coupling_flag <= 1 ) then if ( sst_anomaly_coupling_flag > 0 ) sstan_am = sstan_ob ! Use observed SST (climatological or full field) sst_am = sstcl_ob + sstan_am else if ( sea_coupling_flag . eq . 2 ) then ! Use full ocean model SST sst_am = sst_om else if ( sea_coupling_flag >= 3 ) then ! Define SST anomaly from ocean model ouput and climatology sstan_am = sst_om - sstcl_om ! Merge with observed SST anomaly in selected area if ( sea_coupling_flag >= 4 ) then sstan_am = sstan_am + wsst_ob * ( sstan_ob - sstan_am ) end if ! Add observed SST climatology to model SST anomaly sst_am = sstcl_ob + sstan_am end if ! 3.2 Sea ice fraction and temperature if ( ice_coupling_flag > 0 ) then sice_am = sice_om tice_am = tice_om else sice_am = sicecl_ob tice_am = ticecl_ob end if sst_am = sst_am + sice_am * ( tice_am - sst_am ) ssti_om = sst_om + sice_am * ( tice_am - sst_om ) end subroutine ! Update observed SST anomaly array subroutine obs_ssta use date , only : model_datetime , start_datetime use input_output , only : load_boundary_file use boundaries , only : forchk integer :: next_month sstan3 (:,:, 1 ) = sstan3 (:,:, 2 ) sstan3 (:,:, 2 ) = sstan3 (:,:, 3 ) ! Compute next month given initial SST year next_month = ( start_datetime % year - issty0 ) * 12 + model_datetime % month ! Read next month SST anomalies sstan3 (:,:, 3 ) = load_boundary_file ( \"sea_surface_temperature_anomaly.nc\" , \"ssta\" , & & next_month , 420 ) call forchk ( bmask_s , 1 , - 5 0.0 , 5 0.0 , 0.0 , sstan3 (:,:, 3 )) end ! Purpose : Integrate slab ocean and sea-ice models for one day subroutine run_sea_model use auxiliaries , only : hfluxn , shf , evap , ssrd use mod_radcon , only : albsea , albice , emisfc use physical_constants , only : alhc , sbc real :: hflux ( ix , il ) ! net sfc. heat flux real :: tanom ( ix , il ) ! sfc. temperature anomaly real :: cdis ( ix , il ) ! dissipation ceofficient real :: difice ( ix , il ) ! Difference in net (downw.) heat flux between ice and sea surface real :: hflux_i ( ix , il ) ! Net heat flux into sea-ice surface real :: anom0 , sstfr sstfr = 27 3.2 - 1.8 ! SST at freezing point ! 1. Ocean mixed layer ! Difference in heat flux between ice and sea surface difice = ( albsea - albice ) * ssrd + emisfc * sbc * ( sstfr ** 4.0 - tice_am ** 4.0 ) + shf (:,:, 2 ) + & & evap (:,:, 2 ) * alhc ! Net heat flux into sea-ice surface hflux_i = hfluxn (:,:, 2 ) + difice * ( 1.0 - sice_am ) ! Net heat flux hflux = hfluxn (:,:, 2 ) - hfseacl - sicecl_ob * ( hflux_i + beta * ( sstfr - tice_om )) ! Anomaly at t0 minus climatological temp. tendency tanom = sst_om - sstcl_ob ! Time evoloution of temp. anomaly tanom = cdsea * ( tanom + rhcaps * hflux ) ! Full SST at final time sst_om = tanom + sstcl_ob ! 2. Sea-ice slab model ! Net heat flux hflux = hflux_i + beta * ( sstfr - tice_om ) ! Anomaly w.r.t final-time climatological temp. tanom = tice_om - ticecl_ob ! Definition of non-linear damping coefficient anom0 = 2 0. cdis = cdice * ( anom0 / ( anom0 + abs ( tanom ))) !cdis(:,:) = cdice(:,:) ! Time evolution of temp. anomaly tanom = cdis * ( tanom + rhcapi * hflux ) ! Full ice temperature at final time tice_om = tanom + ticecl_ob ! Persistence of sea ice fraction sice_om = sicecl_ob end ! Definition of ocean domains subroutine sea_domain ( cdomain , dmask ) character ( len = 6 ), intent ( in ) :: cdomain ! domain name ! Output variables (initialized by calling routine) real , intent ( inout ) :: dmask ( ix , il ) ! domain mask integer :: i , j real :: arlat , dlon , rlon , rlonw , wlat print * , 'sea domain : ' , cdomain dlon = 36 0. / float ( ix ) if ( cdomain . eq . 'northe' ) then do j = 1 , il if ( deglat_s ( j ). gt . 2 0.0 ) dmask (:, j ) = 1. end do end if if ( cdomain . eq . 'natlan' ) then do j = 1 , il if ( deglat_s ( j ). gt . 2 0.0 . and . deglat_s ( j ). lt . 8 0.0 ) then do i = 1 , ix rlon = ( i - 1 ) * dlon if ( rlon . lt . 4 5.0 . or . rlon . gt . 26 0.0 ) dmask ( i , j ) = 1. end do end if end do end if if ( cdomain . eq . 'npacif' ) then do j = 1 , il if ( deglat_s ( j ). gt . 2 0.0 . and . deglat_s ( j ). lt . 6 5.0 ) then do i = 1 , ix rlon = ( i - 1 ) * dlon if ( rlon . gt . 12 0.0 . and . rlon . lt . 26 0.0 ) dmask ( i , j ) = 1. end do end if end do end if if ( cdomain . eq . 'tropic' ) then do j = 1 , il if ( deglat_s ( j ). gt . - 3 0.0 . and . deglat_s ( j ). lt . 3 0.0 ) dmask (:, j ) = 1. end do end if if ( cdomain . eq . 'indian' ) then do j = 1 , il if ( deglat_s ( j ). gt . - 3 0.0 . and . deglat_s ( j ). lt . 3 0.0 ) then do i = 1 , ix rlon = ( i - 1 ) * dlon if ( rlon . gt . 3 0.0 . and . rlon . lt . 12 0.0 ) dmask ( i , j ) = 1. end do end if end do end if if ( cdomain . eq . 'elnino' ) then do j = 1 , il arlat = abs ( deglat_s ( j )) if ( arlat . lt . 2 5.0 ) then wlat = 1. if ( arlat . gt . 1 5.0 ) wlat = ( 0.1 * ( 2 5. - arlat )) ** 2 rlonw = 30 0. - 2 * max ( deglat_s ( j ), 0. ) do i = 1 , ix rlon = ( i - 1 ) * dlon if ( rlon . gt . 16 5.0 . and . rlon . lt . rlonw ) then dmask ( i , j ) = wlat else if ( rlon . gt . 15 5.0 . and . rlon . lt . 16 5.0 ) then dmask ( i , j ) = wlat * 0.1 * ( rlon - 15 5. ) end if end do end if end do end if end end module","tags":"","loc":"sourcefile/sea_model.f90.html"},{"title":"speedy.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~speedy.f90~~EfferentGraph sourcefile~speedy.f90 speedy.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~speedy.f90->sourcefile~input_output.f90 sourcefile~prognostics.f90 prognostics.f90 sourcefile~speedy.f90->sourcefile~prognostics.f90 sourcefile~date.f90 date.f90 sourcefile~speedy.f90->sourcefile~date.f90 sourcefile~diagnostics.f90 diagnostics.f90 sourcefile~speedy.f90->sourcefile~diagnostics.f90 sourcefile~coupler.f90 coupler.f90 sourcefile~speedy.f90->sourcefile~coupler.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~params.f90 params.f90 sourcefile~speedy.f90->sourcefile~params.f90 sourcefile~shortwave_radiation.f90 shortwave_radiation.f90 sourcefile~speedy.f90->sourcefile~shortwave_radiation.f90 sourcefile~input_output.f90->sourcefile~date.f90 sourcefile~input_output.f90->sourcefile~params.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~input_output.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~input_output.f90->sourcefile~geometry.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~prognostics.f90->sourcefile~input_output.f90 sourcefile~prognostics.f90->sourcefile~diagnostics.f90 sourcefile~prognostics.f90->sourcefile~params.f90 sourcefile~prognostics.f90->sourcefile~physical_constants.f90 sourcefile~prognostics.f90->sourcefile~geometry.f90 sourcefile~dynamical_constants.f90 dynamical_constants.f90 sourcefile~prognostics.f90->sourcefile~dynamical_constants.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~prognostics.f90->sourcefile~boundaries.f90 sourcefile~prognostics.f90->sourcefile~spectral.f90 sourcefile~date.f90->sourcefile~params.f90 sourcefile~diagnostics.f90->sourcefile~params.f90 sourcefile~diagnostics.f90->sourcefile~spectral.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~coupler.f90->sourcefile~land_model.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~coupler.f90->sourcefile~sea_model.f90 sourcefile~time_stepping.f90->sourcefile~prognostics.f90 sourcefile~time_stepping.f90->sourcefile~params.f90 sourcefile~implicit.f90 implicit.f90 sourcefile~time_stepping.f90->sourcefile~implicit.f90 sourcefile~horizontal_diffusion.f90 horizontal_diffusion.f90 sourcefile~time_stepping.f90->sourcefile~horizontal_diffusion.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 sourcefile~time_stepping.f90->sourcefile~dynamical_constants.f90 sourcefile~time_stepping.f90->sourcefile~spectral.f90 sourcefile~forcing.f90->sourcefile~date.f90 sourcefile~forcing.f90->sourcefile~params.f90 sourcefile~forcing.f90->sourcefile~shortwave_radiation.f90 sourcefile~forcing.f90->sourcefile~land_model.f90 sourcefile~forcing.f90->sourcefile~physical_constants.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~forcing.f90->sourcefile~surface_fluxes.f90 sourcefile~forcing.f90->sourcefile~horizontal_diffusion.f90 sourcefile~mod_radcon.f90 mod_radcon.f90 sourcefile~forcing.f90->sourcefile~mod_radcon.f90 sourcefile~longwave_radiation.f90 longwave_radiation.f90 sourcefile~forcing.f90->sourcefile~longwave_radiation.f90 sourcefile~forcing.f90->sourcefile~sea_model.f90 sourcefile~humidity.f90 humidity.f90 sourcefile~forcing.f90->sourcefile~humidity.f90 sourcefile~forcing.f90->sourcefile~dynamical_constants.f90 sourcefile~forcing.f90->sourcefile~boundaries.f90 sourcefile~forcing.f90->sourcefile~spectral.f90 sourcefile~initialization.f90->sourcefile~input_output.f90 sourcefile~initialization.f90->sourcefile~prognostics.f90 sourcefile~initialization.f90->sourcefile~date.f90 sourcefile~initialization.f90->sourcefile~coupler.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~initialization.f90->sourcefile~params.f90 sourcefile~geopotential.f90 geopotential.f90 sourcefile~initialization.f90->sourcefile~geopotential.f90 sourcefile~initialization.f90->sourcefile~horizontal_diffusion.f90 sourcefile~initialization.f90->sourcefile~geometry.f90 sourcefile~initialization.f90->sourcefile~sea_model.f90 sourcefile~physics.f90 physics.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~initialization.f90->sourcefile~boundaries.f90 sourcefile~initialization.f90->sourcefile~spectral.f90 sourcefile~shortwave_radiation.f90->sourcefile~params.f90 sourcefile~shortwave_radiation.f90->sourcefile~geometry.f90 sourcefile~shortwave_radiation.f90->sourcefile~mod_radcon.f90 sourcefile~land_model.f90->sourcefile~input_output.f90 sourcefile~land_model.f90->sourcefile~date.f90 sourcefile~land_model.f90->sourcefile~params.f90 sourcefile~land_model.f90->sourcefile~boundaries.f90 sourcefile~auxiliaries.f90 auxiliaries.f90 sourcefile~land_model.f90->sourcefile~auxiliaries.f90 sourcefile~interpolation.f90 interpolation.f90 sourcefile~land_model.f90->sourcefile~interpolation.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 sourcefile~surface_fluxes.f90->sourcefile~params.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 sourcefile~surface_fluxes.f90->sourcefile~physical_constants.f90 sourcefile~surface_fluxes.f90->sourcefile~geometry.f90 sourcefile~surface_fluxes.f90->sourcefile~mod_radcon.f90 sourcefile~surface_fluxes.f90->sourcefile~humidity.f90 sourcefile~geopotential.f90->sourcefile~params.f90 sourcefile~geopotential.f90->sourcefile~physical_constants.f90 sourcefile~geopotential.f90->sourcefile~geometry.f90 sourcefile~implicit.f90->sourcefile~params.f90 sourcefile~implicit.f90->sourcefile~physical_constants.f90 sourcefile~implicit.f90->sourcefile~horizontal_diffusion.f90 sourcefile~implicit.f90->sourcefile~geometry.f90 sourcefile~implicit.f90->sourcefile~dynamical_constants.f90 sourcefile~matrix_inversion.f90 matrix_inversion.f90 sourcefile~implicit.f90->sourcefile~matrix_inversion.f90 sourcefile~horizontal_diffusion.f90->sourcefile~params.f90 sourcefile~horizontal_diffusion.f90->sourcefile~physical_constants.f90 sourcefile~horizontal_diffusion.f90->sourcefile~geometry.f90 sourcefile~horizontal_diffusion.f90->sourcefile~dynamical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~mod_radcon.f90->sourcefile~params.f90 sourcefile~longwave_radiation.f90->sourcefile~params.f90 sourcefile~longwave_radiation.f90->sourcefile~physical_constants.f90 sourcefile~longwave_radiation.f90->sourcefile~geometry.f90 sourcefile~longwave_radiation.f90->sourcefile~mod_radcon.f90 sourcefile~tendencies.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90->sourcefile~params.f90 sourcefile~tendencies.f90->sourcefile~physical_constants.f90 sourcefile~tendencies.f90->sourcefile~geopotential.f90 sourcefile~tendencies.f90->sourcefile~implicit.f90 sourcefile~tendencies.f90->sourcefile~geometry.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~tendencies.f90->sourcefile~spectral.f90 sourcefile~sea_model.f90->sourcefile~input_output.f90 sourcefile~sea_model.f90->sourcefile~date.f90 sourcefile~sea_model.f90->sourcefile~params.f90 sourcefile~sea_model.f90->sourcefile~physical_constants.f90 sourcefile~sea_model.f90->sourcefile~geometry.f90 sourcefile~sea_model.f90->sourcefile~mod_radcon.f90 sourcefile~sea_model.f90->sourcefile~boundaries.f90 sourcefile~sea_model.f90->sourcefile~auxiliaries.f90 sourcefile~sea_model.f90->sourcefile~interpolation.f90 sourcefile~humidity.f90->sourcefile~params.f90 sourcefile~physics.f90->sourcefile~params.f90 sourcefile~physics.f90->sourcefile~shortwave_radiation.f90 sourcefile~physics.f90->sourcefile~land_model.f90 sourcefile~physics.f90->sourcefile~physical_constants.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~physics.f90->sourcefile~geometry.f90 sourcefile~physics.f90->sourcefile~longwave_radiation.f90 sourcefile~physics.f90->sourcefile~sea_model.f90 sourcefile~physics.f90->sourcefile~humidity.f90 sourcefile~physics.f90->sourcefile~boundaries.f90 sourcefile~physics.f90->sourcefile~spectral.f90 sourcefile~large_scale_condensation.f90 large_scale_condensation.f90 sourcefile~physics.f90->sourcefile~large_scale_condensation.f90 sourcefile~physics.f90->sourcefile~auxiliaries.f90 sourcefile~sppt.f90 sppt.f90 sourcefile~physics.f90->sourcefile~sppt.f90 sourcefile~vertical_diffusion.f90 vertical_diffusion.f90 sourcefile~physics.f90->sourcefile~vertical_diffusion.f90 sourcefile~convection.f90 convection.f90 sourcefile~physics.f90->sourcefile~convection.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~boundaries.f90->sourcefile~params.f90 sourcefile~boundaries.f90->sourcefile~physical_constants.f90 sourcefile~boundaries.f90->sourcefile~spectral.f90 sourcefile~spectral.f90->sourcefile~params.f90 sourcefile~spectral.f90->sourcefile~physical_constants.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~large_scale_condensation.f90->sourcefile~params.f90 sourcefile~large_scale_condensation.f90->sourcefile~physical_constants.f90 sourcefile~large_scale_condensation.f90->sourcefile~geometry.f90 sourcefile~auxiliaries.f90->sourcefile~params.f90 sourcefile~interpolation.f90->sourcefile~date.f90 sourcefile~interpolation.f90->sourcefile~params.f90 sourcefile~legendre.f90->sourcefile~params.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~sppt.f90->sourcefile~params.f90 sourcefile~sppt.f90->sourcefile~physical_constants.f90 sourcefile~sppt.f90->sourcefile~spectral.f90 sourcefile~fourier.f90->sourcefile~params.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 sourcefile~vertical_diffusion.f90->sourcefile~params.f90 sourcefile~vertical_diffusion.f90->sourcefile~physical_constants.f90 sourcefile~vertical_diffusion.f90->sourcefile~geometry.f90 sourcefile~convection.f90->sourcefile~params.f90 sourcefile~convection.f90->sourcefile~physical_constants.f90 sourcefile~convection.f90->sourcefile~geometry.f90 var pansourcefilespeedyf90EfferentGraph = svgPanZoom('#sourcefilespeedyf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs speedy Source Code speedy.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !> date: 29/04/2019 !> The top-level program. Here we initialize the model and run the main loop !> until the (continually updated) model datetime (`model_datetime`) equals the !> final datetime (`end_datetime`). program speedy use params , only : nsteps , delt , nsteps_out , nstrad use date , only : model_datetime , end_datetime , newdate , datetime_equal use shortwave_radiation , only : compute_shortwave use input_output , only : output use coupler , only : couple_sea_land use initialization , only : initialize use time_stepping , only : step use diagnostics , only : check_diagnostics use prognostics , only : vor , div , t , ps , tr , phi use forcing , only : set_forcing implicit none ! Time step counter integer :: model_step = 1 ! Initialization call initialize ! Model main loop do while (. not . datetime_equal ( model_datetime , end_datetime )) ! Daily tasks if ( mod ( model_step - 1 , nsteps ) == 0 ) then ! Set forcing terms according to date call set_forcing ( 1 ) end if ! Determine whether to compute shortwave radiation on this time step compute_shortwave = mod ( model_step , nstrad ) == 1 ! Perform one leapfrog time step call step ( 2 , 2 , 2 * delt ) ! Check model diagnostics call check_diagnostics ( vor (:,:,:, 2 ), div (:,:,:, 2 ), t (:,:,:, 2 ), model_step ) ! Increment time step counter model_step = model_step + 1 ! Increment model datetime call newdate ! Output if ( mod ( model_step - 1 , nsteps_out ) == 0 ) call output ( model_step - 1 , vor , div , t , ps , tr , phi ) ! Exchange data with coupler call couple_sea_land ( 1 + model_step / nsteps ) end do end","tags":"","loc":"sourcefile/speedy.f90.html"},{"title":"time_stepping.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~time_stepping.f90~~EfferentGraph sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~prognostics.f90 prognostics.f90 sourcefile~time_stepping.f90->sourcefile~prognostics.f90 sourcefile~implicit.f90 implicit.f90 sourcefile~time_stepping.f90->sourcefile~implicit.f90 sourcefile~horizontal_diffusion.f90 horizontal_diffusion.f90 sourcefile~time_stepping.f90->sourcefile~horizontal_diffusion.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 sourcefile~params.f90 params.f90 sourcefile~time_stepping.f90->sourcefile~params.f90 sourcefile~dynamical_constants.f90 dynamical_constants.f90 sourcefile~time_stepping.f90->sourcefile~dynamical_constants.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~time_stepping.f90->sourcefile~spectral.f90 sourcefile~prognostics.f90->sourcefile~params.f90 sourcefile~prognostics.f90->sourcefile~dynamical_constants.f90 sourcefile~prognostics.f90->sourcefile~spectral.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~prognostics.f90->sourcefile~input_output.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~prognostics.f90->sourcefile~physical_constants.f90 sourcefile~diagnostics.f90 diagnostics.f90 sourcefile~prognostics.f90->sourcefile~diagnostics.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~prognostics.f90->sourcefile~geometry.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~prognostics.f90->sourcefile~boundaries.f90 sourcefile~implicit.f90->sourcefile~horizontal_diffusion.f90 sourcefile~implicit.f90->sourcefile~params.f90 sourcefile~implicit.f90->sourcefile~dynamical_constants.f90 sourcefile~implicit.f90->sourcefile~physical_constants.f90 sourcefile~matrix_inversion.f90 matrix_inversion.f90 sourcefile~implicit.f90->sourcefile~matrix_inversion.f90 sourcefile~implicit.f90->sourcefile~geometry.f90 sourcefile~horizontal_diffusion.f90->sourcefile~params.f90 sourcefile~horizontal_diffusion.f90->sourcefile~dynamical_constants.f90 sourcefile~horizontal_diffusion.f90->sourcefile~physical_constants.f90 sourcefile~horizontal_diffusion.f90->sourcefile~geometry.f90 sourcefile~tendencies.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90->sourcefile~implicit.f90 sourcefile~tendencies.f90->sourcefile~params.f90 sourcefile~tendencies.f90->sourcefile~spectral.f90 sourcefile~tendencies.f90->sourcefile~physical_constants.f90 sourcefile~geopotential.f90 geopotential.f90 sourcefile~tendencies.f90->sourcefile~geopotential.f90 sourcefile~tendencies.f90->sourcefile~geometry.f90 sourcefile~physics.f90 physics.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~spectral.f90->sourcefile~params.f90 sourcefile~spectral.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~input_output.f90->sourcefile~params.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~input_output.f90->sourcefile~physical_constants.f90 sourcefile~input_output.f90->sourcefile~geometry.f90 sourcefile~date.f90 date.f90 sourcefile~input_output.f90->sourcefile~date.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 sourcefile~diagnostics.f90->sourcefile~params.f90 sourcefile~diagnostics.f90->sourcefile~spectral.f90 sourcefile~legendre.f90->sourcefile~params.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~geopotential.f90->sourcefile~params.f90 sourcefile~geopotential.f90->sourcefile~physical_constants.f90 sourcefile~geopotential.f90->sourcefile~geometry.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~fourier.f90->sourcefile~params.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 sourcefile~physics.f90->sourcefile~params.f90 sourcefile~physics.f90->sourcefile~spectral.f90 sourcefile~physics.f90->sourcefile~physical_constants.f90 sourcefile~physics.f90->sourcefile~geometry.f90 sourcefile~physics.f90->sourcefile~boundaries.f90 sourcefile~shortwave_radiation.f90 shortwave_radiation.f90 sourcefile~physics.f90->sourcefile~shortwave_radiation.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~physics.f90->sourcefile~land_model.f90 sourcefile~large_scale_condensation.f90 large_scale_condensation.f90 sourcefile~physics.f90->sourcefile~large_scale_condensation.f90 sourcefile~auxiliaries.f90 auxiliaries.f90 sourcefile~physics.f90->sourcefile~auxiliaries.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~longwave_radiation.f90 longwave_radiation.f90 sourcefile~physics.f90->sourcefile~longwave_radiation.f90 sourcefile~sppt.f90 sppt.f90 sourcefile~physics.f90->sourcefile~sppt.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~physics.f90->sourcefile~sea_model.f90 sourcefile~humidity.f90 humidity.f90 sourcefile~physics.f90->sourcefile~humidity.f90 sourcefile~vertical_diffusion.f90 vertical_diffusion.f90 sourcefile~physics.f90->sourcefile~vertical_diffusion.f90 sourcefile~convection.f90 convection.f90 sourcefile~physics.f90->sourcefile~convection.f90 sourcefile~boundaries.f90->sourcefile~params.f90 sourcefile~boundaries.f90->sourcefile~spectral.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~boundaries.f90->sourcefile~physical_constants.f90 sourcefile~shortwave_radiation.f90->sourcefile~params.f90 sourcefile~shortwave_radiation.f90->sourcefile~geometry.f90 sourcefile~mod_radcon.f90 mod_radcon.f90 sourcefile~shortwave_radiation.f90->sourcefile~mod_radcon.f90 sourcefile~land_model.f90->sourcefile~params.f90 sourcefile~land_model.f90->sourcefile~input_output.f90 sourcefile~land_model.f90->sourcefile~boundaries.f90 sourcefile~land_model.f90->sourcefile~auxiliaries.f90 sourcefile~land_model.f90->sourcefile~date.f90 sourcefile~interpolation.f90 interpolation.f90 sourcefile~land_model.f90->sourcefile~interpolation.f90 sourcefile~large_scale_condensation.f90->sourcefile~params.f90 sourcefile~large_scale_condensation.f90->sourcefile~physical_constants.f90 sourcefile~large_scale_condensation.f90->sourcefile~geometry.f90 sourcefile~auxiliaries.f90->sourcefile~params.f90 sourcefile~surface_fluxes.f90->sourcefile~params.f90 sourcefile~surface_fluxes.f90->sourcefile~physical_constants.f90 sourcefile~surface_fluxes.f90->sourcefile~geometry.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 sourcefile~surface_fluxes.f90->sourcefile~humidity.f90 sourcefile~surface_fluxes.f90->sourcefile~mod_radcon.f90 sourcefile~longwave_radiation.f90->sourcefile~params.f90 sourcefile~longwave_radiation.f90->sourcefile~physical_constants.f90 sourcefile~longwave_radiation.f90->sourcefile~geometry.f90 sourcefile~longwave_radiation.f90->sourcefile~mod_radcon.f90 sourcefile~sppt.f90->sourcefile~params.f90 sourcefile~sppt.f90->sourcefile~spectral.f90 sourcefile~sppt.f90->sourcefile~physical_constants.f90 sourcefile~sea_model.f90->sourcefile~params.f90 sourcefile~sea_model.f90->sourcefile~input_output.f90 sourcefile~sea_model.f90->sourcefile~physical_constants.f90 sourcefile~sea_model.f90->sourcefile~geometry.f90 sourcefile~sea_model.f90->sourcefile~boundaries.f90 sourcefile~sea_model.f90->sourcefile~auxiliaries.f90 sourcefile~sea_model.f90->sourcefile~date.f90 sourcefile~sea_model.f90->sourcefile~mod_radcon.f90 sourcefile~sea_model.f90->sourcefile~interpolation.f90 sourcefile~humidity.f90->sourcefile~params.f90 sourcefile~date.f90->sourcefile~params.f90 sourcefile~vertical_diffusion.f90->sourcefile~params.f90 sourcefile~vertical_diffusion.f90->sourcefile~physical_constants.f90 sourcefile~vertical_diffusion.f90->sourcefile~geometry.f90 sourcefile~convection.f90->sourcefile~params.f90 sourcefile~convection.f90->sourcefile~physical_constants.f90 sourcefile~convection.f90->sourcefile~geometry.f90 sourcefile~mod_radcon.f90->sourcefile~params.f90 sourcefile~interpolation.f90->sourcefile~params.f90 sourcefile~interpolation.f90->sourcefile~date.f90 var pansourcefiletime_steppingf90EfferentGraph = svgPanZoom('#sourcefiletime_steppingf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~time_stepping.f90~~AfferentGraph sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules time_stepping Source Code time_stepping.f90 Source Code module time_stepping use params implicit none private public first_step , step contains ! Call initialization of semi-implicit scheme and perform initial time step subroutine first_step use implicit , only : initialize_implicit call initialize_implicit ( 0.5 * delt ) call step ( 1 , 1 , 0.5 * delt ) call initialize_implicit ( delt ) call step ( 1 , 2 , delt ) call initialize_implicit ( 2 * delt ) end ! Perform one time step starting from F(1) and F(2) and using the following scheme: ! Fnew = F(1) + DT * [ T_dyn(F(J2)) + T_phy(F(1)) ] ! F(1) = (1-2*eps)*F(J1) + eps*[F(1)+Fnew] ! F(2) = Fnew ! Input: ! If j1 == 1, j2 == 1 : forward time step (eps = 0) ! If j1 == 1, j2 == 2 : initial leapfrog time step (eps = 0) ! If j1 == 2, j2 == 2 : leapfrog time step with time filter (eps = ROB) ! dt = time step subroutine step ( j1 , j2 , dt ) use dynamical_constants , only : tdrs use prognostics use horizontal_diffusion , only : do_horizontal_diffusion , & & dmp , dmpd , dmps , dmp1 , dmp1d , dmp1s , tcorv , qcorv , tcorh , qcorh use tendencies , only : get_tendencies integer , intent ( in ) :: j1 , j2 real , intent ( in ) :: dt complex , dimension ( mx , nx , kx ) :: vordt , divdt , tdt complex :: psdt ( mx , nx ), trdt ( mx , nx , kx , ntr ) real :: eps , sdrag complex :: ctmp ( mx , nx , kx ) integer :: n , itr , k , m ! ========================================================================= ! Compute tendencies of prognostic variables ! ========================================================================= call get_tendencies ( vordt , divdt , tdt , psdt , trdt , j2 ) ! ========================================================================= ! Horizontal diffusion ! ========================================================================= ! Diffusion of wind and temperature vordt = do_horizontal_diffusion ( vor (:,:,:, 1 ), vordt , dmp , dmp1 ) divdt = do_horizontal_diffusion ( div (:,:,:, 1 ), divdt , dmpd , dmp1d ) do k = 1 , kx do m = 1 , mx do n = 1 , nx ctmp ( m , n , k ) = t ( m , n , k , 1 ) + tcorh ( m , n ) * tcorv ( k ) end do end do end do tdt = do_horizontal_diffusion ( ctmp , tdt , dmp , dmp1 ) ! Stratospheric diffusion and zonal wind damping sdrag = 1.0 / ( tdrs * 360 0.0 ) do n = 1 , nx vordt ( 1 , n , 1 ) = vordt ( 1 , n , 1 ) - sdrag * vor ( 1 , n , 1 , 1 ) divdt ( 1 , n , 1 ) = divdt ( 1 , n , 1 ) - sdrag * div ( 1 , n , 1 , 1 ) end do vordt = do_horizontal_diffusion ( vor (:,:,:, 1 ), vordt , dmps , dmp1s ) divdt = do_horizontal_diffusion ( div (:,:,:, 1 ), divdt , dmps , dmp1s ) tdt = do_horizontal_diffusion ( ctmp , tdt , dmps , dmp1s ) ! Diffusion of tracers do k = 1 , kx do m = 1 , mx do n = 1 , nx ctmp ( m , n , k ) = tr ( m , n , k , 1 , 1 ) + qcorh ( m , n ) * qcorv ( k ) end do end do end do trdt (:,:,:, 1 ) = do_horizontal_diffusion ( ctmp , trdt (:,:,:, 1 ), dmpd , dmp1d ) if ( ntr > 1 ) then do itr = 2 , ntr trdt (:,:,:, 1 ) = do_horizontal_diffusion ( tr (:,:,:, 1 , itr ), trdt (:,:,:, itr ), dmp , dmp1 ) enddo endif ! ========================================================================= ! Time integration with Robert filter ! ========================================================================= if ( j1 == 1 ) then eps = 0.0 else eps = rob endif ps = step_field_2d ( j1 , dt , eps , ps , psdt ) vor = step_field_3d ( j1 , dt , eps , vor , vordt ) div = step_field_3d ( j1 , dt , eps , div , divdt ) t = step_field_3d ( j1 , dt , eps , t , tdt ) do itr = 1 , ntr tr (:,:,:,:, itr ) = step_field_3d ( j1 , dt , eps , tr (:,:,:,:, itr ), trdt (:,:,:, itr )) end do end ! Perform time integration of field across all model levels using tendency fdt function step_field_3d ( j1 , dt , eps , input , fdt ) result ( output ) use spectral , only : trunct integer , intent ( in ) :: j1 real , intent ( in ) :: dt , eps complex , intent ( inout ) :: fdt ( mx , nx , kx ) complex , intent ( in ) :: input ( mx , nx , kx , 2 ) complex :: output ( mx , nx , kx , 2 ) integer :: k do k = 1 , kx output (:,:, k ,:) = step_field_2d ( j1 , dt , eps , input (:,:, k ,:), fdt (:,:, k )) end do end function step_field_2d ( j1 , dt , eps , input , fdt ) result ( output ) use spectral , only : trunct integer , intent ( in ) :: j1 real , intent ( in ) :: dt , eps complex , intent ( inout ) :: fdt ( mx , nx ) complex , intent ( in ) :: input ( mx , nx , 2 ) complex :: output ( mx , nx , 2 ) real :: eps2 complex :: fnew ( mx , nx ) output = input eps2 = 1.0 - 2.0 * eps if ( ix == iy * 4 ) then call trunct ( fdt ) end if ! The actual leap frog with the Robert filter fnew = output (:,:, 1 ) + dt * fdt output (:,:, 1 ) = output (:,:, j1 ) + wil * eps * ( output (:,:, 1 ) - 2 * output (:,:, j1 ) + fnew ) ! Williams' innovation to the filter output (:,:, 2 ) = fnew - ( 1.0 - wil ) * eps * ( output (:,:, 1 ) - 2.0 * output (:,:, j1 ) + fnew ) end end module","tags":"","loc":"sourcefile/time_stepping.f90.html"},{"title":"physics.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~physics.f90~~EfferentGraph sourcefile~physics.f90 physics.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~physics.f90->sourcefile~land_model.f90 sourcefile~large_scale_condensation.f90 large_scale_condensation.f90 sourcefile~physics.f90->sourcefile~large_scale_condensation.f90 sourcefile~auxiliaries.f90 auxiliaries.f90 sourcefile~physics.f90->sourcefile~auxiliaries.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~physics.f90->sourcefile~physical_constants.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~physics.f90->sourcefile~boundaries.f90 sourcefile~longwave_radiation.f90 longwave_radiation.f90 sourcefile~physics.f90->sourcefile~longwave_radiation.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~physics.f90->sourcefile~geometry.f90 sourcefile~sppt.f90 sppt.f90 sourcefile~physics.f90->sourcefile~sppt.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~physics.f90->sourcefile~sea_model.f90 sourcefile~humidity.f90 humidity.f90 sourcefile~physics.f90->sourcefile~humidity.f90 sourcefile~params.f90 params.f90 sourcefile~physics.f90->sourcefile~params.f90 sourcefile~shortwave_radiation.f90 shortwave_radiation.f90 sourcefile~physics.f90->sourcefile~shortwave_radiation.f90 sourcefile~vertical_diffusion.f90 vertical_diffusion.f90 sourcefile~physics.f90->sourcefile~vertical_diffusion.f90 sourcefile~convection.f90 convection.f90 sourcefile~physics.f90->sourcefile~convection.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~physics.f90->sourcefile~spectral.f90 sourcefile~land_model.f90->sourcefile~auxiliaries.f90 sourcefile~land_model.f90->sourcefile~boundaries.f90 sourcefile~land_model.f90->sourcefile~params.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~land_model.f90->sourcefile~input_output.f90 sourcefile~interpolation.f90 interpolation.f90 sourcefile~land_model.f90->sourcefile~interpolation.f90 sourcefile~date.f90 date.f90 sourcefile~land_model.f90->sourcefile~date.f90 sourcefile~large_scale_condensation.f90->sourcefile~physical_constants.f90 sourcefile~large_scale_condensation.f90->sourcefile~geometry.f90 sourcefile~large_scale_condensation.f90->sourcefile~params.f90 sourcefile~auxiliaries.f90->sourcefile~params.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 sourcefile~surface_fluxes.f90->sourcefile~physical_constants.f90 sourcefile~surface_fluxes.f90->sourcefile~geometry.f90 sourcefile~surface_fluxes.f90->sourcefile~humidity.f90 sourcefile~surface_fluxes.f90->sourcefile~params.f90 sourcefile~mod_radcon.f90 mod_radcon.f90 sourcefile~surface_fluxes.f90->sourcefile~mod_radcon.f90 sourcefile~boundaries.f90->sourcefile~physical_constants.f90 sourcefile~boundaries.f90->sourcefile~params.f90 sourcefile~boundaries.f90->sourcefile~spectral.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~longwave_radiation.f90->sourcefile~physical_constants.f90 sourcefile~longwave_radiation.f90->sourcefile~geometry.f90 sourcefile~longwave_radiation.f90->sourcefile~params.f90 sourcefile~longwave_radiation.f90->sourcefile~mod_radcon.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~sppt.f90->sourcefile~physical_constants.f90 sourcefile~sppt.f90->sourcefile~params.f90 sourcefile~sppt.f90->sourcefile~spectral.f90 sourcefile~sea_model.f90->sourcefile~auxiliaries.f90 sourcefile~sea_model.f90->sourcefile~physical_constants.f90 sourcefile~sea_model.f90->sourcefile~boundaries.f90 sourcefile~sea_model.f90->sourcefile~geometry.f90 sourcefile~sea_model.f90->sourcefile~params.f90 sourcefile~sea_model.f90->sourcefile~input_output.f90 sourcefile~sea_model.f90->sourcefile~interpolation.f90 sourcefile~sea_model.f90->sourcefile~mod_radcon.f90 sourcefile~sea_model.f90->sourcefile~date.f90 sourcefile~humidity.f90->sourcefile~params.f90 sourcefile~shortwave_radiation.f90->sourcefile~geometry.f90 sourcefile~shortwave_radiation.f90->sourcefile~params.f90 sourcefile~shortwave_radiation.f90->sourcefile~mod_radcon.f90 sourcefile~vertical_diffusion.f90->sourcefile~physical_constants.f90 sourcefile~vertical_diffusion.f90->sourcefile~geometry.f90 sourcefile~vertical_diffusion.f90->sourcefile~params.f90 sourcefile~convection.f90->sourcefile~physical_constants.f90 sourcefile~convection.f90->sourcefile~geometry.f90 sourcefile~convection.f90->sourcefile~params.f90 sourcefile~spectral.f90->sourcefile~physical_constants.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~spectral.f90->sourcefile~params.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~input_output.f90->sourcefile~physical_constants.f90 sourcefile~input_output.f90->sourcefile~geometry.f90 sourcefile~input_output.f90->sourcefile~params.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~input_output.f90->sourcefile~date.f90 sourcefile~interpolation.f90->sourcefile~params.f90 sourcefile~interpolation.f90->sourcefile~date.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~legendre.f90->sourcefile~params.f90 sourcefile~mod_radcon.f90->sourcefile~params.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 sourcefile~fourier.f90->sourcefile~params.f90 sourcefile~date.f90->sourcefile~params.f90 var pansourcefilephysicsf90EfferentGraph = svgPanZoom('#sourcefilephysicsf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~physics.f90~~AfferentGraph sourcefile~physics.f90 physics.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules physics Source Code physics.f90 Source Code module physics use params implicit none private public initialize_physics , get_physical_tendencies contains ! Initialize physical parametrization routines subroutine initialize_physics use physical_constants , only : grav , cp , p0 , sigl , sigh , grdsig , grdscp , wvi use geometry , only : hsg , fsg , dhs integer :: k ! 1.2 Functions of sigma and latitude sigh ( 0 ) = hsg ( 1 ) do k = 1 , kx sigl ( k ) = log ( fsg ( k )) sigh ( k ) = hsg ( k + 1 ) grdsig ( k ) = grav / ( dhs ( k ) * p0 ) grdscp ( k ) = grdsig ( k ) / cp end do ! Weights for vertical interpolation at half-levels(1,kx) and surface ! Note that for phys.par. half-lev(k) is between full-lev k and k+1 ! Fhalf(k) = Ffull(k)+WVI(K,2)*(Ffull(k+1)-Ffull(k)) ! Fsurf = Ffull(kx)+WVI(kx,2)*(Ffull(kx)-Ffull(kx-1)) do k = 1 , kx - 1 wvi ( k , 1 ) = 1. / ( sigl ( k + 1 ) - sigl ( k )) wvi ( k , 2 ) = ( log ( sigh ( k )) - sigl ( k )) * wvi ( k , 1 ) end do wvi ( kx , 1 ) = 0. wvi ( kx , 2 ) = ( log ( 0.99 ) - sigl ( kx )) * wvi ( kx - 1 , 1 ) end !> Compute physical parametrization tendencies for u, v, t, q and add them !  to the dynamical grid-point tendencies subroutine get_physical_tendencies ( vor , div , t , q , phi , psl , utend , vtend , ttend , qtend ) use auxiliaries , only : precnv , precls , cbmf , tsr , ssrd , ssr , slrd , slr , olr , slru , ustr , & & vstr , shf , evap , hfluxn use physical_constants , only : sigh , grdsig , grdscp , cp use geometry , only : fsg use boundaries , only : phis0 use land_model , only : fmask_l use sea_model , only : sst_am , ssti_om , sea_coupling_flag use sppt , only : mu , gen_sppt use convection , only : get_convection_tendencies use large_scale_condensation , only : get_large_scale_condensation_tendencies use shortwave_radiation , only : get_shortwave_rad_fluxes , clouds , compute_shortwave use longwave_radiation , only : & get_downward_longwave_rad_fluxes , get_upward_longwave_rad_fluxes use surface_fluxes , only : get_surface_fluxes use vertical_diffusion , only : get_vertical_diffusion_tend use humidity , only : spec_hum_to_rel_hum use spectral , only : spec_to_grid , uvspec complex , intent ( in ) :: vor ( mx , nx , kx ) !! Vorticity complex , intent ( in ) :: div ( mx , nx , kx ) !! Divergence complex , intent ( in ) :: t ( mx , nx , kx ) !! Temperature complex , intent ( in ) :: q ( mx , nx , kx ) !! Specific Humidity complex , intent ( in ) :: phi ( mx , nx , kx ) !! Geopotential complex , intent ( in ) :: psl ( mx , nx ) !! ln(Surface pressure) real , intent ( inout ) :: utend ( ix , il , kx ) !! Zonal velocity tendency real , intent ( inout ) :: vtend ( ix , il , kx ) !! Meridional velocity tendency real , intent ( inout ) :: ttend ( ix , il , kx ) !! Temperature tendency real , intent ( inout ) :: qtend ( ix , il , kx ) !! Specific humidity tendency complex , dimension ( mx , nx ) :: ucos , vcos real , dimension ( ix , il ) :: pslg , rps , gse real , dimension ( ix , il , kx ) :: ug , vg , tg , qg , phig , utend_dyn , vtend_dyn , ttend_dyn , qtend_dyn real , dimension ( ix , il , kx ) :: se , rh , qsat real , dimension ( ix , il ) :: psg , ts , tskin , u0 , v0 , t0 , cloudc , clstr , cltop , prtop real , dimension ( ix , il , kx ) :: tt_cnv , qt_cnv , tt_lsc , qt_lsc , tt_rsw , tt_rlw , ut_pbl , vt_pbl ,& & tt_pbl , qt_pbl integer :: iptop ( ix , il ), icltop ( ix , il , 2 ), icnv ( ix , il ), i , j , k real :: sppt ( ix , il , kx ) ! Keep a copy of the original (dynamics only) tendencies utend_dyn = utend vtend_dyn = vtend ttend_dyn = ttend qtend_dyn = qtend ! ========================================================================= ! Compute grid-point fields ! ========================================================================= ! Convert model spectral variables to grid-point variables do k = 1 , kx call uvspec ( vor (:,:, k ), div (:,:, k ), ucos , vcos ) ug (:,:, k ) = spec_to_grid ( ucos , 2 ) vg (:,:, k ) = spec_to_grid ( vcos , 2 ) tg (:,:, k ) = spec_to_grid ( t (:,:, k ), 1 ) qg (:,:, k ) = spec_to_grid ( q (:,:, k ), 1 ) phig (:,:, k ) = spec_to_grid ( phi (:,:, k ), 1 ) end do pslg = spec_to_grid ( psl , 1 ) ! ========================================================================= ! Compute thermodynamic variables ! ========================================================================= psg = exp ( pslg ) rps = 1.0 / psg qg = max ( qg , 0.0 ) se = cp * tg + phig do k = 1 , kx call spec_hum_to_rel_hum ( tg (:,:, k ), psg , fsg ( k ), qg (:,:, k ), rh (:,:, k ), qsat (:,:, k )) end do ! ========================================================================= ! Precipitation ! ========================================================================= ! Deep convection call get_convection_tendencies ( psg , se , qg , qsat , iptop , cbmf , precnv , tt_cnv , qt_cnv ) do k = 2 , kx tt_cnv (:,:, k ) = tt_cnv (:,:, k ) * rps * grdscp ( k ) qt_cnv (:,:, k ) = qt_cnv (:,:, k ) * rps * grdsig ( k ) end do icnv = kx - iptop ! Large-scale condensation call get_large_scale_condensation_tendencies ( psg , qg , qsat , iptop , precls , tt_lsc , qt_lsc ) ttend = ttend + tt_cnv + tt_lsc qtend = qtend + qt_cnv + qt_lsc ! ========================================================================= ! Radiation (shortwave and longwave) and surface fluxes ! ========================================================================= ! Compute shortwave tendencies and initialize lw transmissivity ! The shortwave radiation may be called at selected time steps if ( compute_shortwave ) then gse = ( se (:,:, kx - 1 ) - se (:,:, kx )) / ( phig (:,:, kx - 1 ) - phig (:,:, kx )) call clouds ( qg , rh , precnv , precls , iptop , gse , fmask_l , icltop , cloudc , clstr ) do i = 1 , ix do j = 1 , il cltop ( i , j ) = sigh ( icltop ( i , j , 1 ) - 1 ) * psg ( i , j ) prtop ( i , j ) = float ( iptop ( i , j )) end do end do call get_shortwave_rad_fluxes ( psg , qg , icltop , cloudc , clstr , ssrd , ssr , tsr , tt_rsw ) do k = 1 , kx tt_rsw (:,:, k ) = tt_rsw (:,:, k ) * rps * grdscp ( k ) end do end if ! Compute downward longwave fluxes call get_downward_longwave_rad_fluxes ( tg , slrd , tt_rlw ) ! Compute surface fluxes and land skin temperature call get_surface_fluxes ( psg , ug , vg , tg , qg , rh , phig , phis0 , fmask_l , sst_am , & & ssrd , slrd , ustr , vstr , shf , evap , slru , hfluxn , ts , tskin , u0 , v0 , t0 , . true .) ! Recompute sea fluxes in case of anomaly coupling if ( sea_coupling_flag > 0 ) then call get_surface_fluxes ( psg , ug , vg , tg , qg , rh , phig , phis0 , fmask_l , ssti_om , & & ssrd , slrd , ustr , vstr , shf , evap , slru , hfluxn , ts , tskin , u0 , v0 , t0 , . false .) end if ! Compute upward longwave fluxes, convert them to tendencies and add ! shortwave tendencies call get_upward_longwave_rad_fluxes ( tg , ts , slrd , slru (:,:, 3 ), slr , olr , tt_rlw ) do k = 1 , kx tt_rlw (:,:, k ) = tt_rlw (:,:, k ) * rps * grdscp ( k ) end do ttend = ttend + tt_rsw + tt_rlw ! ========================================================================= ! Planetary boundary later interactions with lower troposphere ! ========================================================================= ! Vertical diffusion and shallow convection call get_vertical_diffusion_tend ( se , rh , qg , qsat , phig , icnv , ut_pbl , vt_pbl , & & tt_pbl , qt_pbl ) ! Add tendencies due to surface fluxes ut_pbl (:,:, kx ) = ut_pbl (:,:, kx ) + ustr (:,:, 3 ) * rps * grdsig ( kx ) vt_pbl (:,:, kx ) = vt_pbl (:,:, kx ) + vstr (:,:, 3 ) * rps * grdsig ( kx ) tt_pbl (:,:, kx ) = tt_pbl (:,:, kx ) + shf (:,:, 3 ) * rps * grdscp ( kx ) qt_pbl (:,:, kx ) = qt_pbl (:,:, kx ) + evap (:,:, 3 ) * rps * grdsig ( kx ) utend = utend + ut_pbl vtend = vtend + vt_pbl ttend = ttend + tt_pbl qtend = qtend + qt_pbl ! Add SPPT noise if ( sppt_on ) then sppt = gen_sppt () ! The physical contribution to the tendency is *tend - *tend_dyn, where * is u, v, t, q do k = 1 , kx utend (:,:, k ) = ( 1 + sppt (:,:, k ) * mu ( k )) * ( utend (:,:, k ) - utend_dyn (:,:, k )) & & + utend_dyn (:,:, k ) vtend (:,:, k ) = ( 1 + sppt (:,:, k ) * mu ( k )) * ( vtend (:,:, k ) - vtend_dyn (:,:, k )) & & + vtend_dyn (:,:, k ) ttend (:,:, k ) = ( 1 + sppt (:,:, k ) * mu ( k )) * ( ttend (:,:, k ) - ttend_dyn (:,:, k )) & & + ttend_dyn (:,:, k ) qtend (:,:, k ) = ( 1 + sppt (:,:, k ) * mu ( k )) * ( qtend (:,:, k ) - qtend_dyn (:,:, k )) & & + qtend_dyn (:,:, k ) end do end if end end module","tags":"","loc":"sourcefile/physics.f90.html"},{"title":"surface_fluxes.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~surface_fluxes.f90~~EfferentGraph sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~surface_fluxes.f90->sourcefile~physical_constants.f90 sourcefile~mod_radcon.f90 mod_radcon.f90 sourcefile~surface_fluxes.f90->sourcefile~mod_radcon.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~surface_fluxes.f90->sourcefile~geometry.f90 sourcefile~humidity.f90 humidity.f90 sourcefile~surface_fluxes.f90->sourcefile~humidity.f90 sourcefile~params.f90 params.f90 sourcefile~surface_fluxes.f90->sourcefile~params.f90 sourcefile~land_model.f90->sourcefile~params.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~land_model.f90->sourcefile~input_output.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~land_model.f90->sourcefile~boundaries.f90 sourcefile~interpolation.f90 interpolation.f90 sourcefile~land_model.f90->sourcefile~interpolation.f90 sourcefile~auxiliaries.f90 auxiliaries.f90 sourcefile~land_model.f90->sourcefile~auxiliaries.f90 sourcefile~date.f90 date.f90 sourcefile~land_model.f90->sourcefile~date.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 sourcefile~mod_radcon.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~humidity.f90->sourcefile~params.f90 sourcefile~input_output.f90->sourcefile~physical_constants.f90 sourcefile~input_output.f90->sourcefile~geometry.f90 sourcefile~input_output.f90->sourcefile~params.f90 sourcefile~input_output.f90->sourcefile~date.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~boundaries.f90->sourcefile~physical_constants.f90 sourcefile~boundaries.f90->sourcefile~params.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~boundaries.f90->sourcefile~spectral.f90 sourcefile~interpolation.f90->sourcefile~params.f90 sourcefile~interpolation.f90->sourcefile~date.f90 sourcefile~auxiliaries.f90->sourcefile~params.f90 sourcefile~date.f90->sourcefile~params.f90 sourcefile~spectral.f90->sourcefile~physical_constants.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~spectral.f90->sourcefile~params.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~legendre.f90->sourcefile~params.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 sourcefile~fourier.f90->sourcefile~params.f90 var pansourcefilesurface_fluxesf90EfferentGraph = svgPanZoom('#sourcefilesurface_fluxesf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~surface_fluxes.f90~~AfferentGraph sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~forcing.f90->sourcefile~surface_fluxes.f90 sourcefile~physics.f90 physics.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 var pansourcefilesurface_fluxesf90AfferentGraph = svgPanZoom('#sourcefilesurface_fluxesf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules surface_fluxes Source Code surface_fluxes.f90 Source Code !> Parametrization of surface fluxes module surface_fluxes use params implicit none private public get_surface_fluxes , set_orog_land_sfc_drag !  Constants for surface fluxes real :: fwind0 = 0.95 !! Ratio of near-sfc wind to lowest-level wind !> Weight for near-sfc temperature extrapolation (0-1) : !  1 : linear extrapolation from two lowest levels !  0 : constant potential temperature ( = lowest level) real :: ftemp0 = 1.0 !> Weight for near-sfc specific humidity extrapolation (0-1) : !  1 : extrap. with constant relative hum. ( = lowest level) !  0 : constant specific hum. ( = lowest level) real :: fhum0 = 0.0 real :: cdl = 2.4e-3 !! Drag coefficient for momentum over land real :: cds = 1.0e-3 !! Drag coefficient for momentum over sea real :: chl = 1.2e-3 !! Heat exchange coefficient over land real :: chs = 0.9e-3 !! Heat exchange coefficient over sea real :: vgust = 5.0 !! Wind speed for sub-grid-scale gusts real :: ctday = 1.0e-2 !! Daily-cycle correction (dTskin/dSSRad) real :: dtheta = 3.0 !! Potential temp. gradient for stability correction real :: fstab = 0.67 !! Amplitude of stability correction (fraction) real :: hdrag = 200 0.0 !! Height scale for orographic correction real :: clambda = 7.0 !! Heat conductivity in skin-to-root soil layer real :: clambsn = 7.0 !! Heat conductivity in soil for snow cover = 1 real :: forog ( ix , il ) ! Time-invariant fields (initial. in SFLSET) contains !> Compute surface fluxes of momentum, energy and moisture, and define surface !  skin temperature from energy balance subroutine get_surface_fluxes ( psa , ua , va , ta , qa , rh , phi , phi0 , fmask , tsea , ssrd , slrd , & & ustr , vstr , shf , evap , slru , hfluxn , tsfc , tskin , u0 , v0 , t0 , lfluxland ) use physical_constants , only : p0 , rd , cp , alhc , sbc , sigl , wvi use geometry , only : coa use mod_radcon , only : emisfc , alb_l , alb_s , snowc use land_model , only : stl_am , soilw_am use humidity , only : get_qsat , rel_hum_to_spec_hum real , intent ( in ) :: psa ( ix , il ) !! Normalised surface pressure real , intent ( in ) :: ua ( ix , il , kx ) !! u-wind real , intent ( in ) :: va ( ix , il , kx ) !! v-wind real , intent ( in ) :: ta ( ix , il , kx ) !! Temperature real , intent ( in ) :: qa ( ix , il , kx ) !! Specific humidity [g/kg] real , intent ( in ) :: rh ( ix , il , kx ) !! Relative humidity real , intent ( in ) :: phi ( ix , il , kx ) !! Geopotential real , intent ( in ) :: phi0 ( ix , il ) !! Surface geopotential real , intent ( in ) :: fmask ( ix , il ) !! Fractional land-sea mask real , intent ( in ) :: tsea ( ix , il ) !! Sea-surface temperature real , intent ( in ) :: ssrd ( ix , il ) !! Downward flux of short-wave radiation at the surface real , intent ( in ) :: slrd ( ix , il ) !! Downward flux of long-wave radiation at the surface logical , intent ( in ) :: lfluxland real , intent ( out ) :: ustr ( ix , il , 3 ) !! u-stress real , intent ( out ) :: vstr ( ix , il , 3 ) !! v-stress real , intent ( out ) :: shf ( ix , il , 3 ) !! Sensible heat flux real , intent ( out ) :: evap ( ix , il , 3 ) !! Evaporation real , intent ( out ) :: slru ( ix , il , 3 ) !! Upward flux of long-wave radiation at the surface real , intent ( out ) :: hfluxn ( ix , il , 2 ) !! Net downward heat flux real , intent ( out ) :: tsfc ( ix , il ) !! Surface temperature real , intent ( out ) :: tskin ( ix , il ) !! Skin surface temperature real , intent ( out ) :: u0 ( ix , il ) !! Near-surface u-wind real , intent ( out ) :: v0 ( ix , il ) !! Near-surface v-wind real , intent ( out ) :: t0 ( ix , il ) !! Near-surface temperature integer :: i , j , ks , nl1 real , dimension ( ix , il , 2 ), save :: t1 , q1 real , dimension ( ix , il , 2 ) :: t2 , qsat0 real , save :: denvvs ( ix , il , 0 : 2 ) real :: dslr ( ix , il ), dtskin ( ix , il ), clamb ( ix , il ), astab , cdldv , cdsdv ( ix , il ), chlcp real :: dt1 , dthl , dths , esbc , ghum0 , gtemp0 real :: rcp , rdth , tsk3 ( ix , il ) logical lscasym , lskineb lscasym = . true . ! true : use an asymmetric stability coefficient lskineb = . true . ! true : redefine skin temp. from energy balance esbc = emisfc * sbc ghum0 = 1.0 - fhum0 ! ========================================================================= ! Land surface ! ========================================================================= if ( lfluxland ) then ! 1. Extrapolation of wind, temp, hum. and density to the surface ! 1.1 Wind components u0 = fwind0 * ua (:,:, kx ) v0 = fwind0 * va (:,:, kx ) ! 1.2 Temperature gtemp0 = 1.0 - ftemp0 rcp = 1.0 / cp nl1 = kx - 1 do i = 1 , ix do j = 1 , il ! Temperature difference between lowest level and sfc dt1 = wvi ( kx , 2 ) * ( ta ( i , j , kx ) - ta ( i , j , nl1 )) ! Extrapolated temperature using actual lapse rate (1:land, 2:sea) t1 ( i , j , 1 ) = ta ( i , j , kx ) + dt1 t1 ( i , j , 2 ) = t1 ( i , j , 1 ) - phi0 ( i , j ) * dt1 / ( rd * 28 8.0 * sigl ( kx )) ! Extrapolated temperature using dry-adiab. lapse rate (1:land, 2:sea) t2 ( i , j , 2 ) = ta ( i , j , kx ) + rcp * phi ( i , j , kx ) t2 ( i , j , 1 ) = t2 ( i , j , 2 ) - rcp * phi0 ( i , j ) end do end do do i = 1 , ix do j = 1 , il if ( ta ( i , j , kx ) > ta ( i , j , nl1 )) then ! Use extrapolated temp. if dT/dz < 0 t1 ( i , j , 1 ) = ftemp0 * t1 ( i , j , 1 ) + gtemp0 * t2 ( i , j , 1 ) t1 ( i , j , 2 ) = ftemp0 * t1 ( i , j , 2 ) + gtemp0 * t2 ( i , j , 2 ) else ! Use temp. at lowest level if dT/dz > 0 t1 ( i , j , 1 ) = ta ( i , j , kx ) t1 ( i , j , 2 ) = ta ( i , j , kx ) endif t0 ( i , j ) = t1 ( i , j , 2 ) + fmask ( i , j ) * ( t1 ( i , j , 1 ) - t1 ( i , j , 2 )) end do end do ! 1.3 Density * wind speed (including gustiness factor) denvvs (:,:, 0 ) = ( p0 * psa / ( rd * t0 )) * sqrt ( u0 ** 2.0 + v0 ** 2.0 + vgust ** 2.0 ) ! 2. Compute land-sfc. fluxes using prescribed skin temperature ! 2.1 Define effective skin temperature to compensate for !     non-linearity of heat/moisture fluxes during the daily cycle do j = 1 , il tskin (:, j ) = stl_am (:, j ) + ctday * sqrt ( coa ( j )) * ssrd (:, j ) * ( 1.0 - alb_l (:, j )) * psa (:, j ) end do ! 2.2 Stability correction = f[pot.temp.(sfc)-pot.temp.(air)] rdth = fstab / dtheta astab = 1.0 if ( lscasym ) astab = 0.5 ! to get smaller ds/dt in stable conditions do i = 1 , ix do j = 1 , il ! Potential temp. difference (land+sea average) if ( tskin ( i , j ) > t2 ( i , j , 1 )) then dthl = min ( dtheta , tskin ( i , j ) - t2 ( i , j , 1 )) else dthl = max ( - dtheta , astab * ( tskin ( i , j ) - t2 ( i , j , 1 ))) end if denvvs ( i , j , 1 ) = denvvs ( i , j , 0 ) * ( 1.0 + dthl * rdth ) end do end do ! 2.3 Wind stress do i = 1 , ix do j = 1 , il cdldv = cdl * denvvs ( i , j , 0 ) * forog ( i , j ) ustr ( i , j , 1 ) = - cdldv * ua ( i , j , kx ) vstr ( i , j , 1 ) = - cdldv * va ( i , j , kx ) end do end do ! 2.4 Sensible heat flux chlcp = chl * cp shf (:,:, 1 ) = chlcp * denvvs (:,:, 1 ) * ( tskin - t1 (:,:, 1 )) ! 2.5 Evaporation if ( fhum0 > 0.0 ) then call rel_hum_to_spec_hum ( t1 , psa , 1.0 , rh (:,:, kx ), q1 , qsat0 (:,:, 1 )) q1 (:,:, 1 ) = fhum0 * q1 (:,:, 1 ) + ghum0 * qa (:,:, kx ) else q1 (:,:, 1 ) = qa (:,:, kx ) end if qsat0 (:,:, 1 ) = get_qsat ( tskin , psa , 1.0 ) evap (:,:, 1 ) = chl * denvvs (:,:, 1 ) * max ( 0.0 , soilw_am * qsat0 (:,:, 1 ) - q1 (:,:, 1 )) ! 3. Compute land-surface energy balance; !    adjust skin temperature and heat fluxes ! 3.1. Emission of lw radiation from the surface !      and net heat fluxes into land surface tsk3 = tskin ** 3.0 dslr = 4.0 * esbc * tsk3 slru (:,:, 1 ) = esbc * tsk3 * tskin hfluxn (:,:, 1 ) = ssrd * ( 1.0 - alb_l ) + slrd - ( slru (:,:, 1 ) + shf (:,:, 1 ) + alhc * evap (:,:, 1 )) ! 3.2 Re-definition of skin temperature from energy balance if ( lskineb ) then ! Compute net heat flux including flux into ground clamb = clambda + snowc * ( clambsn - clambda ) hfluxn (:,:, 1 ) = hfluxn (:,:, 1 ) - clamb * ( tskin - stl_am ) dtskin = tskin + 1.0 ! Compute d(Evap) for a 1-degree increment of Tskin qsat0 (:,:, 2 ) = get_qsat ( dtskin , psa , 1.0 ) do i = 1 , ix do j = 1 , il if ( evap ( i , j , 1 ) > 0.0 ) then qsat0 ( i , j , 2 ) = soilw_am ( i , j ) * ( qsat0 ( i , j , 2 ) - qsat0 ( i , j , 1 )) else qsat0 ( i , j , 2 ) = 0.0 endif end do end do ! Redefine skin temperature to balance the heat budget dtskin = hfluxn (:,:, 1 ) / ( clamb + dslr + chl * denvvs (:,:, 1 ) * ( cp + alhc * qsat0 (:,:, 2 ))) tskin = tskin + dtskin ! Add linear corrections to heat fluxes shf (:,:, 1 ) = shf (:,:, 1 ) + chlcp * denvvs (:,:, 1 ) * dtskin evap (:,:, 1 ) = evap (:,:, 1 ) + chl * denvvs (:,:, 1 ) * qsat0 (:,:, 2 ) * dtskin slru (:,:, 1 ) = slru (:,:, 1 ) + dslr * dtskin hfluxn (:,:, 1 ) = clamb * ( tskin - stl_am ) end if rdth = fstab / dtheta astab = 1.0 if ( lscasym ) astab = 0.5 ! to get smaller dS/dT in stable conditions do i = 1 , ix do j = 1 , il if ( tsea ( i , j ) > t2 ( i , j , 2 )) then dths = min ( dtheta , tsea ( i , j ) - t2 ( i , j , 2 )) else dths = max ( - dtheta , astab * ( tsea ( i , j ) - t2 ( i , j , 2 ))) end if denvvs ( i , j , 2 ) = denvvs ( i , j , 0 ) * ( 1.0 + dths * rdth ) end do end do if ( fhum0 > 0.0 ) then call rel_hum_to_spec_hum ( t1 (:,:, 2 ), psa , 1.0 , rh (:,:, kx ), q1 (:,:, 2 ), qsat0 (:,:, 2 )) q1 (:,:, 2 ) = fhum0 * q1 (:,:, 2 ) + ghum0 * qa (:,:, kx ) else q1 (:,:, 2 ) = qa (:,:, kx ) end if ! 4.2 Wind stress ks = 2 cdsdv = cds * denvvs (:,:, ks ) ustr (:,:, 2 ) = - cdsdv * ua (:,:, kx ) vstr (:,:, 2 ) = - cdsdv * va (:,:, kx ) end if ! ========================================================================= ! Sea surface ! ========================================================================= ! 4.3 Sensible heat flux shf (:,:, 2 ) = chs * cp * denvvs (:,:, ks ) * ( tsea - t1 (:,:, 2 )) ! 4.4 Evaporation qsat0 (:,:, 2 ) = get_qsat ( tsea , psa , 1.0 ) evap (:,:, 2 ) = chs * denvvs (:,:, ks ) * ( qsat0 (:,:, 2 ) - q1 (:,:, 2 )) ! 4.5 Emission of lw radiation from the surface !     and net heat fluxes into sea surface slru (:,:, 2 ) = esbc * tsea ** 4.0 hfluxn (:,:, 2 ) = ssrd * ( 1.0 - alb_s ) + slrd - slru (:,:, 2 ) + shf (:,:, 2 ) + alhc * evap (:,:, 2 ) ! ========================================================================= ! Weighted average of surface fluxes and temperatures according to land-sea ! mask ! ========================================================================= if ( lfluxland ) then ustr (:,:, 3 ) = ustr (:,:, 2 ) + fmask * ( ustr (:,:, 1 ) - ustr (:,:, 2 )) vstr (:,:, 3 ) = vstr (:,:, 2 ) + fmask * ( vstr (:,:, 1 ) - vstr (:,:, 2 )) shf (:,:, 3 ) = shf (:,:, 2 ) + fmask * ( shf (:,:, 1 ) - shf (:,:, 2 )) evap (:,:, 3 ) = evap (:,:, 2 ) + fmask * ( evap (:,:, 1 ) - evap (:,:, 2 )) slru (:,:, 3 ) = slru (:,:, 2 ) + fmask * ( slru (:,:, 1 ) - slru (:,:, 2 )) tsfc = tsea + fmask * ( stl_am - tsea ) tskin = tsea + fmask * ( tskin - tsea ) t0 = t1 (:,:, 2 ) + fmask * ( t1 (:,:, 1 ) - t1 (:,:, 2 )) end if end ! Compute orographic factor for land surface drag ! Input:   phi0 = surface geopotential subroutine set_orog_land_sfc_drag ( phi0 ) use physical_constants , only : grav real , intent ( in ) :: phi0 ( ix , il ) real :: rhdrag rhdrag = 1.0 / ( grav * hdrag ) forog = 1.0 + rhdrag * ( 1.0 - exp ( - max ( phi0 , 0.0 ) * rhdrag )) end end module","tags":"","loc":"sourcefile/surface_fluxes.f90.html"},{"title":"mod_radcon.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~mod_radcon.f90~~EfferentGraph sourcefile~mod_radcon.f90 mod_radcon.f90 sourcefile~params.f90 params.f90 sourcefile~mod_radcon.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mod_radcon.f90~~AfferentGraph sourcefile~mod_radcon.f90 mod_radcon.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~surface_fluxes.f90->sourcefile~mod_radcon.f90 sourcefile~longwave_radiation.f90 longwave_radiation.f90 sourcefile~longwave_radiation.f90->sourcefile~mod_radcon.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~forcing.f90->sourcefile~mod_radcon.f90 sourcefile~forcing.f90->sourcefile~surface_fluxes.f90 sourcefile~forcing.f90->sourcefile~longwave_radiation.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~forcing.f90->sourcefile~sea_model.f90 sourcefile~shortwave_radiation.f90 shortwave_radiation.f90 sourcefile~forcing.f90->sourcefile~shortwave_radiation.f90 sourcefile~sea_model.f90->sourcefile~mod_radcon.f90 sourcefile~shortwave_radiation.f90->sourcefile~mod_radcon.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~speedy.f90->sourcefile~shortwave_radiation.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~coupler.f90 coupler.f90 sourcefile~speedy.f90->sourcefile~coupler.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~initialization.f90->sourcefile~sea_model.f90 sourcefile~physics.f90 physics.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~initialization.f90->sourcefile~coupler.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~physics.f90->sourcefile~longwave_radiation.f90 sourcefile~physics.f90->sourcefile~sea_model.f90 sourcefile~physics.f90->sourcefile~shortwave_radiation.f90 sourcefile~coupler.f90->sourcefile~sea_model.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 var pansourcefilemod_radconf90AfferentGraph = svgPanZoom('#sourcefilemod_radconf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mod_radcon Source Code mod_radcon.f90 Source Code module mod_radcon use params implicit none private public albsea , albice , albsn , epslw , emisfc , ablco2_ref public fband public alb_l , alb_s , albsfc , snowc public tau2 , st4a , stratc , flux ! Radiation and cloud constants ! albsea = Albedo over sea ! albice = Albedo over sea ice (for ice fraction = 1) ! albsn  = Albedo over snow (for snow cover = 1) ! epslw  = fraction of blackbody spectrum absorbed/emitted by PBL only ! emisfc = longwave surface emissivity real :: albsea = 0.07 real :: albice = 0.60 real :: albsn = 0.60 real :: epslw = 0.05 real :: emisfc = 0.98 real :: ablco2_ref ! Time-invariant fields (initial. in radset) ! fband  = energy fraction emitted in each LW band = f(T) real :: fband ( 100 : 400 , 4 ) ! Radiative properties of the surface (updated in fordate) ! alb_l  = daily-mean albedo over land (bare-land + snow) ! alb_s  = daily-mean albedo over sea  (open sea + sea ice) ! albsfc = combined surface albedo (land + sea) ! snowc  = effective snow cover (fraction) real , dimension ( ix , il ) :: alb_l , alb_s , albsfc , snowc ! Transmissivity and blackbody rad. (updated in radsw/radlw) ! tau2   = transmissivity of atmospheric layers ! st4a   = blackbody emission from full and half atmospheric levels ! stratc = stratospheric correction term ! flux   = radiative flux in different spectral bands real :: tau2 ( ix , il , kx , 4 ), st4a ( ix , il , kx , 2 ), stratc ( ix , il , 2 ), flux ( ix , il , 4 ) end module","tags":"","loc":"sourcefile/mod_radcon.f90.html"},{"title":"physical_constants.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~physical_constants.f90~~EfferentGraph sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~params.f90 params.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~physical_constants.f90~~AfferentGraph sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~input_output.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~input_output.f90->sourcefile~geometry.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~prognostics.f90 prognostics.f90 sourcefile~prognostics.f90->sourcefile~physical_constants.f90 sourcefile~prognostics.f90->sourcefile~input_output.f90 sourcefile~prognostics.f90->sourcefile~geometry.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~prognostics.f90->sourcefile~boundaries.f90 sourcefile~prognostics.f90->sourcefile~spectral.f90 sourcefile~diagnostics.f90 diagnostics.f90 sourcefile~prognostics.f90->sourcefile~diagnostics.f90 sourcefile~large_scale_condensation.f90 large_scale_condensation.f90 sourcefile~large_scale_condensation.f90->sourcefile~physical_constants.f90 sourcefile~large_scale_condensation.f90->sourcefile~geometry.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~surface_fluxes.f90->sourcefile~physical_constants.f90 sourcefile~surface_fluxes.f90->sourcefile~geometry.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~geopotential.f90 geopotential.f90 sourcefile~geopotential.f90->sourcefile~physical_constants.f90 sourcefile~geopotential.f90->sourcefile~geometry.f90 sourcefile~implicit.f90 implicit.f90 sourcefile~implicit.f90->sourcefile~physical_constants.f90 sourcefile~implicit.f90->sourcefile~geometry.f90 sourcefile~horizontal_diffusion.f90 horizontal_diffusion.f90 sourcefile~implicit.f90->sourcefile~horizontal_diffusion.f90 sourcefile~longwave_radiation.f90 longwave_radiation.f90 sourcefile~longwave_radiation.f90->sourcefile~physical_constants.f90 sourcefile~longwave_radiation.f90->sourcefile~geometry.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~sppt.f90 sppt.f90 sourcefile~sppt.f90->sourcefile~physical_constants.f90 sourcefile~sppt.f90->sourcefile~spectral.f90 sourcefile~horizontal_diffusion.f90->sourcefile~physical_constants.f90 sourcefile~horizontal_diffusion.f90->sourcefile~geometry.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~forcing.f90->sourcefile~physical_constants.f90 sourcefile~forcing.f90->sourcefile~surface_fluxes.f90 sourcefile~forcing.f90->sourcefile~longwave_radiation.f90 sourcefile~forcing.f90->sourcefile~horizontal_diffusion.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~forcing.f90->sourcefile~sea_model.f90 sourcefile~forcing.f90->sourcefile~boundaries.f90 sourcefile~forcing.f90->sourcefile~spectral.f90 sourcefile~forcing.f90->sourcefile~land_model.f90 sourcefile~shortwave_radiation.f90 shortwave_radiation.f90 sourcefile~forcing.f90->sourcefile~shortwave_radiation.f90 sourcefile~sea_model.f90->sourcefile~physical_constants.f90 sourcefile~sea_model.f90->sourcefile~input_output.f90 sourcefile~sea_model.f90->sourcefile~geometry.f90 sourcefile~sea_model.f90->sourcefile~boundaries.f90 sourcefile~physics.f90 physics.f90 sourcefile~physics.f90->sourcefile~physical_constants.f90 sourcefile~physics.f90->sourcefile~large_scale_condensation.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~physics.f90->sourcefile~longwave_radiation.f90 sourcefile~physics.f90->sourcefile~geometry.f90 sourcefile~physics.f90->sourcefile~sppt.f90 sourcefile~physics.f90->sourcefile~sea_model.f90 sourcefile~physics.f90->sourcefile~boundaries.f90 sourcefile~vertical_diffusion.f90 vertical_diffusion.f90 sourcefile~physics.f90->sourcefile~vertical_diffusion.f90 sourcefile~convection.f90 convection.f90 sourcefile~physics.f90->sourcefile~convection.f90 sourcefile~physics.f90->sourcefile~spectral.f90 sourcefile~physics.f90->sourcefile~land_model.f90 sourcefile~physics.f90->sourcefile~shortwave_radiation.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~physical_constants.f90 sourcefile~tendencies.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90->sourcefile~geopotential.f90 sourcefile~tendencies.f90->sourcefile~implicit.f90 sourcefile~tendencies.f90->sourcefile~geometry.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~tendencies.f90->sourcefile~spectral.f90 sourcefile~boundaries.f90->sourcefile~physical_constants.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~boundaries.f90->sourcefile~spectral.f90 sourcefile~vertical_diffusion.f90->sourcefile~physical_constants.f90 sourcefile~vertical_diffusion.f90->sourcefile~geometry.f90 sourcefile~convection.f90->sourcefile~physical_constants.f90 sourcefile~convection.f90->sourcefile~geometry.f90 sourcefile~spectral.f90->sourcefile~physical_constants.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~input_output.f90 sourcefile~speedy.f90->sourcefile~prognostics.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~speedy.f90->sourcefile~diagnostics.f90 sourcefile~coupler.f90 coupler.f90 sourcefile~speedy.f90->sourcefile~coupler.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~speedy.f90->sourcefile~shortwave_radiation.f90 sourcefile~land_model.f90->sourcefile~input_output.f90 sourcefile~land_model.f90->sourcefile~boundaries.f90 sourcefile~diagnostics.f90->sourcefile~spectral.f90 sourcefile~coupler.f90->sourcefile~sea_model.f90 sourcefile~coupler.f90->sourcefile~land_model.f90 sourcefile~time_stepping.f90->sourcefile~prognostics.f90 sourcefile~time_stepping.f90->sourcefile~implicit.f90 sourcefile~time_stepping.f90->sourcefile~horizontal_diffusion.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 sourcefile~time_stepping.f90->sourcefile~spectral.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 sourcefile~initialization.f90->sourcefile~input_output.f90 sourcefile~initialization.f90->sourcefile~prognostics.f90 sourcefile~initialization.f90->sourcefile~geopotential.f90 sourcefile~initialization.f90->sourcefile~geometry.f90 sourcefile~initialization.f90->sourcefile~horizontal_diffusion.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~initialization.f90->sourcefile~sea_model.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~initialization.f90->sourcefile~boundaries.f90 sourcefile~initialization.f90->sourcefile~spectral.f90 sourcefile~initialization.f90->sourcefile~coupler.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~shortwave_radiation.f90->sourcefile~geometry.f90 var pansourcefilephysical_constantsf90AfferentGraph = svgPanZoom('#sourcefilephysical_constantsf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules physical_constants Source Code physical_constants.f90 Source Code module physical_constants use params implicit none private public rearth , omega , grav , akap , rgas public p0 , rd , cp , alhc , alhs , sbc public sigl , sigh , grdsig , grdscp , wvi ! Physical constants for dynamics real , parameter :: rearth = 6.371e+6 real , parameter :: omega = 7.292e-05 real , parameter :: grav = 9.81 real , parameter :: akap = 2.0 / 7.0 real , parameter :: rgas = akap * 100 4.0 ! Physical constants for thermodynamics real , parameter :: p0 = 1.e+5 ! Reference pressure real , parameter :: rd = 28 7.0 ! Gas constant for dry air real , parameter :: cp = 100 4.0 ! Specific heat at constant pressure real , parameter :: alhc = 250 1.0 ! Latent heat of condensation, in J/g for consistency with ! specific humidity in g/Kg real , parameter :: alhs = 280 1.0 ! Latent heat of sublimation real , parameter :: sbc = 5.67e-8 ! Stefan-Boltzmann constant !   Functions of sigma and latitude (initial. in INPHYS) real , dimension ( kx ) :: sigl ! Logarithm of full-level sigma real , dimension ( 0 : kx ) :: sigh ! Half-level sigma real , dimension ( kx ) :: grdsig ! g/(d_sigma p0) : to convert fluxes of u,v,q into d(u,v,q)/dt real , dimension ( kx ) :: grdscp ! g/(d_sigma p0 c_p): to convert energy fluxes into dT/dt real , dimension ( kx , 2 ) :: wvi ! Weights for vertical interpolation end module","tags":"","loc":"sourcefile/physical_constants.f90.html"},{"title":"tendencies.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~tendencies.f90~~EfferentGraph sourcefile~tendencies.f90 tendencies.f90 sourcefile~prognostics.f90 prognostics.f90 sourcefile~tendencies.f90->sourcefile~prognostics.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~tendencies.f90->sourcefile~physical_constants.f90 sourcefile~geopotential.f90 geopotential.f90 sourcefile~tendencies.f90->sourcefile~geopotential.f90 sourcefile~implicit.f90 implicit.f90 sourcefile~tendencies.f90->sourcefile~implicit.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~tendencies.f90->sourcefile~geometry.f90 sourcefile~physics.f90 physics.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~params.f90 params.f90 sourcefile~tendencies.f90->sourcefile~params.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~tendencies.f90->sourcefile~spectral.f90 sourcefile~prognostics.f90->sourcefile~physical_constants.f90 sourcefile~prognostics.f90->sourcefile~geometry.f90 sourcefile~prognostics.f90->sourcefile~params.f90 sourcefile~prognostics.f90->sourcefile~spectral.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~prognostics.f90->sourcefile~input_output.f90 sourcefile~diagnostics.f90 diagnostics.f90 sourcefile~prognostics.f90->sourcefile~diagnostics.f90 sourcefile~dynamical_constants.f90 dynamical_constants.f90 sourcefile~prognostics.f90->sourcefile~dynamical_constants.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~prognostics.f90->sourcefile~boundaries.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 sourcefile~geopotential.f90->sourcefile~physical_constants.f90 sourcefile~geopotential.f90->sourcefile~geometry.f90 sourcefile~geopotential.f90->sourcefile~params.f90 sourcefile~implicit.f90->sourcefile~physical_constants.f90 sourcefile~implicit.f90->sourcefile~geometry.f90 sourcefile~implicit.f90->sourcefile~params.f90 sourcefile~matrix_inversion.f90 matrix_inversion.f90 sourcefile~implicit.f90->sourcefile~matrix_inversion.f90 sourcefile~horizontal_diffusion.f90 horizontal_diffusion.f90 sourcefile~implicit.f90->sourcefile~horizontal_diffusion.f90 sourcefile~implicit.f90->sourcefile~dynamical_constants.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~physics.f90->sourcefile~physical_constants.f90 sourcefile~physics.f90->sourcefile~geometry.f90 sourcefile~physics.f90->sourcefile~params.f90 sourcefile~physics.f90->sourcefile~spectral.f90 sourcefile~shortwave_radiation.f90 shortwave_radiation.f90 sourcefile~physics.f90->sourcefile~shortwave_radiation.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~physics.f90->sourcefile~land_model.f90 sourcefile~large_scale_condensation.f90 large_scale_condensation.f90 sourcefile~physics.f90->sourcefile~large_scale_condensation.f90 sourcefile~auxiliaries.f90 auxiliaries.f90 sourcefile~physics.f90->sourcefile~auxiliaries.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~longwave_radiation.f90 longwave_radiation.f90 sourcefile~physics.f90->sourcefile~longwave_radiation.f90 sourcefile~sppt.f90 sppt.f90 sourcefile~physics.f90->sourcefile~sppt.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~physics.f90->sourcefile~sea_model.f90 sourcefile~humidity.f90 humidity.f90 sourcefile~physics.f90->sourcefile~humidity.f90 sourcefile~physics.f90->sourcefile~boundaries.f90 sourcefile~vertical_diffusion.f90 vertical_diffusion.f90 sourcefile~physics.f90->sourcefile~vertical_diffusion.f90 sourcefile~convection.f90 convection.f90 sourcefile~physics.f90->sourcefile~convection.f90 sourcefile~spectral.f90->sourcefile~physical_constants.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~spectral.f90->sourcefile~params.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~shortwave_radiation.f90->sourcefile~geometry.f90 sourcefile~shortwave_radiation.f90->sourcefile~params.f90 sourcefile~mod_radcon.f90 mod_radcon.f90 sourcefile~shortwave_radiation.f90->sourcefile~mod_radcon.f90 sourcefile~input_output.f90->sourcefile~physical_constants.f90 sourcefile~input_output.f90->sourcefile~geometry.f90 sourcefile~input_output.f90->sourcefile~params.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~date.f90 date.f90 sourcefile~input_output.f90->sourcefile~date.f90 sourcefile~land_model.f90->sourcefile~params.f90 sourcefile~land_model.f90->sourcefile~input_output.f90 sourcefile~land_model.f90->sourcefile~auxiliaries.f90 sourcefile~land_model.f90->sourcefile~boundaries.f90 sourcefile~land_model.f90->sourcefile~date.f90 sourcefile~interpolation.f90 interpolation.f90 sourcefile~land_model.f90->sourcefile~interpolation.f90 sourcefile~large_scale_condensation.f90->sourcefile~physical_constants.f90 sourcefile~large_scale_condensation.f90->sourcefile~geometry.f90 sourcefile~large_scale_condensation.f90->sourcefile~params.f90 sourcefile~auxiliaries.f90->sourcefile~params.f90 sourcefile~diagnostics.f90->sourcefile~params.f90 sourcefile~diagnostics.f90->sourcefile~spectral.f90 sourcefile~surface_fluxes.f90->sourcefile~physical_constants.f90 sourcefile~surface_fluxes.f90->sourcefile~geometry.f90 sourcefile~surface_fluxes.f90->sourcefile~params.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 sourcefile~surface_fluxes.f90->sourcefile~humidity.f90 sourcefile~surface_fluxes.f90->sourcefile~mod_radcon.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~legendre.f90->sourcefile~params.f90 sourcefile~horizontal_diffusion.f90->sourcefile~physical_constants.f90 sourcefile~horizontal_diffusion.f90->sourcefile~geometry.f90 sourcefile~horizontal_diffusion.f90->sourcefile~params.f90 sourcefile~horizontal_diffusion.f90->sourcefile~dynamical_constants.f90 sourcefile~longwave_radiation.f90->sourcefile~physical_constants.f90 sourcefile~longwave_radiation.f90->sourcefile~geometry.f90 sourcefile~longwave_radiation.f90->sourcefile~params.f90 sourcefile~longwave_radiation.f90->sourcefile~mod_radcon.f90 sourcefile~sppt.f90->sourcefile~physical_constants.f90 sourcefile~sppt.f90->sourcefile~params.f90 sourcefile~sppt.f90->sourcefile~spectral.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 sourcefile~fourier.f90->sourcefile~params.f90 sourcefile~sea_model.f90->sourcefile~physical_constants.f90 sourcefile~sea_model.f90->sourcefile~geometry.f90 sourcefile~sea_model.f90->sourcefile~params.f90 sourcefile~sea_model.f90->sourcefile~input_output.f90 sourcefile~sea_model.f90->sourcefile~auxiliaries.f90 sourcefile~sea_model.f90->sourcefile~boundaries.f90 sourcefile~sea_model.f90->sourcefile~mod_radcon.f90 sourcefile~sea_model.f90->sourcefile~date.f90 sourcefile~sea_model.f90->sourcefile~interpolation.f90 sourcefile~humidity.f90->sourcefile~params.f90 sourcefile~boundaries.f90->sourcefile~physical_constants.f90 sourcefile~boundaries.f90->sourcefile~params.f90 sourcefile~boundaries.f90->sourcefile~spectral.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~vertical_diffusion.f90->sourcefile~physical_constants.f90 sourcefile~vertical_diffusion.f90->sourcefile~geometry.f90 sourcefile~vertical_diffusion.f90->sourcefile~params.f90 sourcefile~convection.f90->sourcefile~physical_constants.f90 sourcefile~convection.f90->sourcefile~geometry.f90 sourcefile~convection.f90->sourcefile~params.f90 sourcefile~mod_radcon.f90->sourcefile~params.f90 sourcefile~date.f90->sourcefile~params.f90 sourcefile~interpolation.f90->sourcefile~params.f90 sourcefile~interpolation.f90->sourcefile~date.f90 var pansourcefiletendenciesf90EfferentGraph = svgPanZoom('#sourcefiletendenciesf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~tendencies.f90~~AfferentGraph sourcefile~tendencies.f90 tendencies.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules tendencies Source Code tendencies.f90 Source Code module tendencies use params implicit none private public get_tendencies contains subroutine get_tendencies ( vordt , divdt , tdt , psdt , trdt , j2 ) use implicit , only : implicit_terms complex , dimension ( mx , nx , kx ), intent ( inout ) :: vordt , divdt , tdt complex , intent ( inout ) :: psdt ( mx , nx ), trdt ( mx , nx , kx , ntr ) integer , intent ( in ) :: j2 ! ========================================================================= ! Computation of grid-point tendencies (converted to spectral at the end of ! grtend) ! ========================================================================= call get_grid_point_tendencies ( vordt , divdt , tdt , psdt , trdt , 1 , j2 ) ! ========================================================================= ! Computation of spectral tendencies ! ========================================================================= if ( alph < 0.5 ) then call get_spectral_tendencies ( divdt , tdt , psdt , j2 ) else call get_spectral_tendencies ( divdt , tdt , psdt , 1 ) ! Implicit correction call implicit_terms ( divdt , tdt , psdt ) end if end subroutine ! Compute non-linear tendencies in grid point space from dynamics and ! physical parametrizations, and convert them to spectral tendencies ! dF/dt = T_dyn(F(J2)) + T_phy(F(J1)) !   Input:  j1 = time level index for physical tendencies !           j2 = time level index for dynamical tendencies !   Output: vordt = spectral tendency of vorticity !           divdt = spectral tendency of divergence !           tdt   = spectral tendency of temperature !           psdt  = spectral tendency of log(p_s) !           trdt  = spectral tendency of tracers subroutine get_grid_point_tendencies ( vordt , divdt , tdt , psdt , trdt , j1 , j2 ) use prognostics use physical_constants , only : akap , rgas use geometry , only : dhs , dhsr , fsgr , coriol use implicit , only : tref , tref3 use geopotential , only : get_geopotential use physics , only : get_physical_tendencies use spectral , only : grid_to_spec , spec_to_grid , laplacian , grad , uvspec , vdspec !** notes **** ! -- TG does not have to be computed at both time levels every time step, !     I have left it this way to retain parallel structure with subroutine !     using latitude loop ! -- memory can be reduced considerably eliminating TGG, computing VORG !     only when needed, etc -- I have not optimized this subroutine for !     routine use on the YMP ! -- results from grtend1.F should duplicate results from grtend.F !                              -- Isaac !************ complex , dimension ( mx , nx , kx ), intent ( inout ) :: vordt , divdt , tdt complex , intent ( inout ) :: psdt ( mx , nx ), trdt ( mx , nx , kx , ntr ) integer , intent ( in ) :: j1 , j2 complex :: dumc ( mx , nx , 2 ) real , dimension ( ix , il , kx ) :: utend , vtend , ttend real :: trtend ( ix , il , kx , ntr ) real , dimension ( ix , il , kx ) :: ug , vg , tg , vorg , divg , tgg , puv real , dimension ( ix , il ) :: px , py , umean , vmean , dmean real :: trg ( ix , il , kx , ntr ), sigdt ( ix , il , kx + 1 ) real :: temp ( ix , il , kx + 1 ), sigm ( ix , il , kx + 1 ) integer :: k , i , itr , j ! ========================================================================= ! Convert prognostics to grid point space ! ========================================================================= do k = 1 , kx vorg (:,:, k ) = spec_to_grid ( vor (:,:, k , j2 ), 1 ) divg (:,:, k ) = spec_to_grid ( div (:,:, k , j2 ), 1 ) tg (:,:, k ) = spec_to_grid ( t (:,:, k , j2 ), 1 ) do itr = 1 , ntr trg (:,:, k , itr ) = spec_to_grid ( tr (:,:, k , j2 , itr ), 1 ) end do call uvspec ( vor (:,:, k , j2 ), div (:,:, k , j2 ), dumc (:,:, 1 ), dumc (:,:, 2 )) vg (:,:, k ) = spec_to_grid ( dumc (:,:, 2 ), 2 ) ug (:,:, k ) = spec_to_grid ( dumc (:,:, 1 ), 2 ) do j = 1 , il do i = 1 , ix vorg ( i , j , k ) = vorg ( i , j , k ) + coriol ( j ) end do end do end do umean (:,:) = 0.0 vmean (:,:) = 0.0 dmean (:,:) = 0.0 do k = 1 , kx umean (:,:) = umean (:,:) + ug (:,:, k ) * dhs ( k ) vmean (:,:) = vmean (:,:) + vg (:,:, k ) * dhs ( k ) dmean (:,:) = dmean (:,:) + divg (:,:, k ) * dhs ( k ) end do ! Compute tendency of log(surface pressure) ! ps(1,1,j2)=zero call grad ( ps (:,:, j2 ), dumc (:,:, 1 ), dumc (:,:, 2 )) px = spec_to_grid ( dumc (:,:, 1 ), 2 ) py = spec_to_grid ( dumc (:,:, 2 ), 2 ) psdt = grid_to_spec ( - umean * px - vmean * py ) psdt ( 1 , 1 ) = ( 0.0 , 0.0 ) ! Compute \"vertical\" velocity sigdt (:,:, 1 ) = 0.0 sigdt (:,:, kx + 1 ) = 0.0 sigm (:,:, 1 ) = 0.0 sigm (:,:, kx + 1 ) = 0.0 ! (The following combination of terms is utilized later in the !     temperature equation) do k = 1 , kx puv (:,:, k ) = ( ug (:,:, k ) - umean ) * px + ( vg (:,:, k ) - vmean ) * py end do do k = 1 , kx sigdt (:,:, k + 1 ) = sigdt (:,:, k ) - dhs ( k ) * ( puv (:,:, k ) + divg (:,:, k ) - dmean ) sigm (:,:, k + 1 ) = sigm (:,:, k ) - dhs ( k ) * puv (:,:, k ) end do ! Subtract part of temperature field that is used as reference for ! implicit terms do k = 1 , kx tgg (:,:, k ) = tg (:,:, k ) - tref ( k ) end do ! Zonal wind tendency temp (:,:, 1 ) = 0.0 temp (:,:, kx + 1 ) = 0.0 do k = 2 , kx temp (:,:, k ) = sigdt (:,:, k ) * ( ug (:,:, k ) - ug (:,:, k - 1 )) end do do k = 1 , kx utend (:,:, k ) = vg (:,:, k ) * vorg (:,:, k ) - tgg (:,:, k ) * rgas * px & & - ( temp (:,:, k + 1 ) + temp (:,:, k )) * dhsr ( k ) end do ! Meridional wind tendency do k = 2 , kx temp (:,:, k ) = sigdt (:,:, k ) * ( vg (:,:, k ) - vg (:,:, k - 1 )) end do do k = 1 , kx vtend (:,:, k ) = - ug (:,:, k ) * vorg (:,:, k ) - tgg (:,:, k ) * rgas * py & & - ( temp (:,:, k + 1 ) + temp (:,:, k )) * dhsr ( k ) end do ! Temperature tendency do k = 2 , kx temp (:,:, k ) = sigdt (:,:, k ) * ( tgg (:,:, k ) - tgg (:,:, k - 1 )) & & + sigm (:,:, k ) * ( tref ( k ) - tref ( k - 1 )) end do do k = 1 , kx ttend (:,:, k ) = tgg (:,:, k ) * divg (:,:, k ) - ( temp (:,:, k + 1 ) + temp (:,:, k )) * dhsr ( k ) & & + fsgr ( k ) * tgg (:,:, k ) * ( sigdt (:,:, k + 1 ) + sigdt (:,:, k )) + tref3 ( k ) * ( sigm (:,:, k + 1 ) & & + sigm (:,:, k )) + akap * ( tg (:,:, k ) * puv (:,:, k ) - tgg (:,:, k ) * dmean (:,:)) end do ! Tracer tendency do itr = 1 , ntr do k = 2 , kx temp (:,:, k ) = sigdt (:,:, k ) * ( trg (:,:, k , itr ) - trg (:,:, k - 1 , itr )) end do temp (:,:, 2 : 3 ) = 0.0 do k = 1 , kx trtend (:,:, k , itr ) = trg (:,:, k , itr ) * divg (:,:, k ) - ( temp (:,:, k + 1 ) + temp (:,:, k )) * dhsr ( k ) end do end do ! ========================================================================= ! Compute physical tendencies ! ========================================================================= phi = get_geopotential ( t (:,:,:, j1 ), phis ) call get_physical_tendencies ( vor (:,:,:, j1 ), div (:,:,:, j1 ), t (:,:,:, j1 ), tr (:,:,:, j1 , 1 ), & & phi , ps (:,:, j1 ), utend , vtend , ttend , trtend ) ! ========================================================================= ! Convert tendencies to spectral space ! ========================================================================= do k = 1 , kx !  Convert u and v tendencies to vor and div spectral tendencies !  vdspec takes a grid u and a grid v and converts them to !  spectral vor and div call vdspec ( utend (:,:, k ), vtend (:,:, k ), vordt (:,:, k ), divdt (:,:, k ), 2 ) ! Divergence tendency ! add -lapl(0.5*(u**2+v**2)) to div tendency divdt (:,:, k ) = divdt (:,:, k ) & & - laplacian ( grid_to_spec ( 0.5 * ( ug (:,:, k ) ** 2.0 + vg (:,:, k ) ** 2.0 ))) ! Temperature tendency ! and add div(vT) to spectral t tendency call vdspec ( - ug (:,:, k ) * tgg (:,:, k ), - vg (:,:, k ) * tgg (:,:, k ), dumc (:,:, 1 ), tdt (:,:, k ), 2 ) tdt (:,:, k ) = tdt (:,:, k ) + grid_to_spec ( ttend (:,:, k )) ! tracer tendency do itr = 1 , ntr call vdspec ( - ug (:,:, k ) * trg (:,:, k , itr ), - vg (:,:, k ) * trg (:,:, k , itr ), & & dumc (:,:, 1 ), trdt (:,:, k , itr ), 2 ) trdt (:,:, k , itr ) = trdt (:,:, k , itr ) + grid_to_spec ( trtend (:,:, k , itr )) end do end do end subroutine ! Compute spectral tendencies of divergence, temperature  and log(surface pressure) ! Input/output : divdt = divergence tendency (spectral) !                tdt   = temperature tendency (spectral) !                psdt  = tendency of log_surf.pressure (spectral) !                j2    = time level index (1 or 2) subroutine get_spectral_tendencies ( divdt , tdt , psdt , j2 ) use prognostics , only : div , phi , ps , phis , t use physical_constants , only : rgas use geometry , only : dhs , dhsr use geopotential , only : get_geopotential use implicit , only : tref , tref2 , tref3 use spectral , only : laplacian complex , intent ( inout ) :: psdt ( mx , nx ), divdt ( mx , nx , kx ), tdt ( mx , nx , kx ) integer , intent ( in ) :: j2 complex :: dumk ( mx , nx , kx + 1 ), dmeanc ( mx , nx ), sigdtc ( mx , nx , kx + 1 ) integer :: k ! Vertical mean div and pressure tendency dmeanc (:,:) = ( 0.0 , 0.0 ) do k = 1 , kx dmeanc = dmeanc + div (:,:, k , j2 ) * dhs ( k ) end do psdt = psdt - dmeanc psdt ( 1 , 1 ) = ( 0.0 , 0.0 ) ! Sigma-dot \"velocity\" and temperature tendency sigdtc (:,:, 1 ) = ( 0.0 , 0.0 ) sigdtc (:,:, kx + 1 ) = ( 0.0 , 0.0 ) do k = 1 , kx - 1 sigdtc (:,:, k + 1 ) = sigdtc (:,:, k ) - dhs ( k ) * ( div (:,:, k , j2 ) - dmeanc ) end do dumk (:,:, 1 ) = ( 0.0 , 0.0 ) dumk (:,:, kx + 1 ) = ( 0.0 , 0.0 ) do k = 2 , kx dumk (:,:, k ) = sigdtc (:,:, k ) * ( tref ( k ) - tref ( k - 1 )) end do do k = 1 , kx tdt (:,:, k ) = tdt (:,:, k ) - ( dumk (:,:, k + 1 ) + dumk (:,:, k )) * dhsr ( k )& & + tref3 ( k ) * ( sigdtc (:,:, k + 1 ) + sigdtc (:,:, k ))& & - tref2 ( k ) * dmeanc end do ! Geopotential and divergence tendency phi = get_geopotential ( t (:,:,:, j2 ), phis ) do k = 1 , kx divdt (:,:, k ) = divdt (:,:, k ) - laplacian ( phi (:,:, k ) + rgas * tref ( k ) * ps (:,:, j2 )) end do end subroutine end module","tags":"","loc":"sourcefile/tendencies.f90.html"},{"title":"shortwave_radiation.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~shortwave_radiation.f90~~EfferentGraph sourcefile~shortwave_radiation.f90 shortwave_radiation.f90 sourcefile~mod_radcon.f90 mod_radcon.f90 sourcefile~shortwave_radiation.f90->sourcefile~mod_radcon.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~shortwave_radiation.f90->sourcefile~geometry.f90 sourcefile~params.f90 params.f90 sourcefile~shortwave_radiation.f90->sourcefile~params.f90 sourcefile~mod_radcon.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~shortwave_radiation.f90~~AfferentGraph sourcefile~shortwave_radiation.f90 shortwave_radiation.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~shortwave_radiation.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~physics.f90 physics.f90 sourcefile~physics.f90->sourcefile~shortwave_radiation.f90 sourcefile~forcing.f90->sourcefile~shortwave_radiation.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 var pansourcefileshortwave_radiationf90AfferentGraph = svgPanZoom('#sourcefileshortwave_radiationf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules shortwave_radiation Source Code shortwave_radiation.f90 Source Code !> Parametrization of short-wave radiation module shortwave_radiation use params implicit none private public ablco2 public get_shortwave_rad_fluxes , get_zonal_average_fields , clouds public increase_co2 , compute_shortwave ! Shortwave radiation and cloud constants real , parameter :: solc = 34 2.0 !! Solar constant (area averaged) in W/m&#94;2 real , parameter :: rhcl1 = 0.30 !! Relative humidity threshold corresponding to !! cloud cover = 0 real , parameter :: rhcl2 = 1.00 !! Relative humidity correponding to cloud cover = 1 real , parameter :: qacl = 0.20 !! Specific humidity threshold for cloud cover real , parameter :: wpcl = 0.2 !! Cloud cover weight for the square-root of precipitation !! (for p = 1 mm/day) real , parameter :: pmaxcl = 1 0.0 !! Maximum value of precipitation (mm/day) contributing to !! cloud cover real , parameter :: clsmax = 0.60 !! Maximum stratiform cloud cover real , parameter :: clsminl = 0.15 !! Minimum stratiform cloud cover over land (for RH = 1) real , parameter :: gse_s0 = 0.25 !! Gradient of dry static energy corresponding to stratiform !! cloud cover = 0 real , parameter :: gse_s1 = 0.40 !! Gradient of dry static energy corresponding to stratiform !! cloud cover = 1 real , parameter :: albcl = 0.43 !! Cloud albedo (for cloud cover = 1) real , parameter :: albcls = 0.50 !! Stratiform cloud albedo (for st. cloud cover = 1) real , parameter :: epssw = 0.020 !! Fraction of incoming solar radiation absorbed by ozone ! Shortwave absorptivities (for dp = 10&#94;5 Pa) real , parameter :: absdry = 0.033 !! Absorptivity of dry air (visible band) real , parameter :: absaer = 0.033 !! Absorptivity of aerosols (visible band) real , parameter :: abswv1 = 0.022 !! Absorptivity of water vapour !! (visible band, for dq = 1 g/kg) real , parameter :: abswv2 = 1 5.000 !! Absorptivity of water vapour !! (near IR band, for dq = 1 g/kg) real , parameter :: abscl1 = 0.015 !! Absorptivity of clouds (visible band, maximum value) real , parameter :: abscl2 = 0.15 !! Absorptivity of clouds !! (visible band, for dq_base = 1 g/kg) ! Longwave absorptivities (per dp = 10&#94;5 Pa) real , parameter :: ablwin = 0.3 !! Absorptivity of air in \"window\" band real :: ablco2 = 6.0 !! Absorptivity of air in CO2 band real , parameter :: ablwv1 = 0.7 !! Absorptivity of water vapour in H2O band 1 (weak), !! (for dq = 1 g/kg) real , parameter :: ablwv2 = 5 0.0 !! Absorptivity of water vapour in H2O band 2 (strong), !! (for dq = 1 g/kg) real , parameter :: ablcl1 = 1 2.0 !! Absorptivity of \"thick\" clouds in window band !! (below cloud top) real , parameter :: ablcl2 = 0.6 !! Absorptivity of \"thin\" upper clouds in window and H2O bands ! Zonally-averaged fields for SW/LW scheme (updated in sol_oz) real , dimension ( ix , il ) :: fsol !! Flux of incoming solar radiation real , dimension ( ix , il ) :: ozone !! Flux absorbed by ozone (lower stratosphere) real , dimension ( ix , il ) :: ozupp !! Flux absorbed by ozone (upper stratosphere) real , dimension ( ix , il ) :: zenit !! Optical depth ratio (function of solar zenith angle) real , dimension ( ix , il ) :: stratz !! Stratospheric correction for polar night real , dimension ( ix , il ) :: qcloud !! Equivalent specific humidity of clouds ! Logical flags to control shortwave radiation behaviour logical , parameter :: increase_co2 = . false . !! Flag for CO2 optical thickness increase logical :: compute_shortwave = . true . !! Flag for shortwave radiation routine (turned on !! and off in main loop depending on the value of !! nstrad) contains !> Compute the absorption of shortwave radiation and initialize arrays !  for longwave-radiation routines subroutine get_shortwave_rad_fluxes ( psa , qa , icltop , cloudc , clstr , fsfcd , fsfc , ftop , dfabs ) use geometry , only : fsg , dhs use mod_radcon real , intent ( in ) :: psa ( ix , il ) !! Normalised surface pressure [p/p0] real , intent ( in ) :: qa ( ix , il , kx ) !! Specific humidity [g/kg] integer , intent ( in ) :: icltop ( ix , il ) !! Cloud top level real , intent ( in ) :: cloudc ( ix , il ) !! Total cloud cover real , intent ( in ) :: clstr ( ix , il ) !! Stratiform cloud cover real , intent ( out ) :: fsfcd ( ix , il ) !! Total downward flux of short-wave radiation at the !! surface real , intent ( out ) :: fsfc ( ix , il ) !! Net downward flux of short-wave radiation at the !! surface real , intent ( out ) :: ftop ( ix , il ) !! Net downward flux of short-wave radiation at the !! top of the atmosphere real , intent ( out ) :: dfabs ( ix , il , kx ) !! Flux of short-wave radiation absorbed in each !! atmospheric layer integer :: i , j , k , nl1 real :: acloud ( ix , il ), psaz ( ix , il ), abs1 , acloud1 , deltap , eps1 real :: fband1 , fband2 nl1 = kx - 1 fband2 = 0.05 fband1 = 1.0 - fband2 ! 1.  Initialization tau2 = 0.0 do i = 1 , ix do j = 1 , il if ( icltop ( i , j ) <= kx ) then tau2 ( i , j , icltop ( i , j ), 3 ) = albcl * cloudc ( i , j ) end if tau2 ( i , j , kx , 3 ) = albcls * clstr ( i , j ) end do end do ! 2. Shortwave transmissivity: ! function of layer mass, ozone (in the statosphere), ! abs. humidity and cloud cover (in the troposphere) psaz = psa * zenit acloud = cloudc * min ( abscl1 * qcloud , abscl2 ) tau2 (:,:, 1 , 1 ) = exp ( - psaz * dhs ( 1 ) * absdry ) do k = 2 , nl1 abs1 = absdry + absaer * fsg ( k ) ** 2 do i = 1 , ix do j = 1 , il if ( k >= icltop ( i , j )) then tau2 ( i , j , k , 1 ) = exp ( - psaz ( i , j ) * dhs ( k ) * ( abs1 + abswv1 * qa ( i , j , k ) + acloud ( i , j ))) else tau2 ( i , j , k , 1 ) = exp ( - psaz ( i , j ) * dhs ( k ) * ( abs1 + abswv1 * qa ( i , j , k ))) end if end do end do end do abs1 = absdry + absaer * fsg ( kx ) ** 2 tau2 (:,:, kx , 1 ) = exp ( - psaz * dhs ( kx ) * ( abs1 + abswv1 * qa (:,:, kx ))) do k = 2 , kx tau2 (:,:, k , 2 ) = exp ( - psaz * dhs ( k ) * abswv2 * qa (:,:, k )) end do ! 3. Shortwave downward flux ! 3.1 Initialization of fluxes ftop = fsol flux (:,:, 1 ) = fsol * fband1 flux (:,:, 2 ) = fsol * fband2 ! 3.2 Ozone and dry-air absorption in the stratosphere k = 1 dfabs (:,:, k ) = flux (:,:, 1 ) flux (:,:, 1 ) = tau2 (:,:, k , 1 ) * ( flux (:,:, 1 ) - ozupp * psa ) dfabs (:,:, k ) = dfabs (:,:, k ) - flux (:,:, 1 ) k = 2 dfabs (:,:, k ) = flux (:,:, 1 ) flux (:,:, 1 ) = tau2 (:,:, k , 1 ) * ( flux (:,:, 1 ) - ozone * psa ) dfabs (:,:, k ) = dfabs (:,:, k ) - flux (:,:, 1 ) ! 3.3  Absorption and reflection in the troposphere do k = 3 , kx tau2 (:,:, k , 3 ) = flux (:,:, 1 ) * tau2 (:,:, k , 3 ) flux (:,:, 1 ) = flux (:,:, 1 ) - tau2 (:,:, k , 3 ) dfabs (:,:, k ) = flux (:,:, 1 ) flux (:,:, 1 ) = tau2 (:,:, k , 1 ) * flux (:,:, 1 ) dfabs (:,:, k ) = dfabs (:,:, k ) - flux (:,:, 1 ) end do do k = 2 , kx dfabs (:,:, k ) = dfabs (:,:, k ) + flux (:,:, 2 ) flux (:,:, 2 ) = tau2 (:,:, k , 2 ) * flux (:,:, 2 ) dfabs (:,:, k ) = dfabs (:,:, k ) - flux (:,:, 2 ) end do ! 4. Shortwave upward flux ! 4.1  Absorption and reflection at the surface fsfcd = flux (:,:, 1 ) + flux (:,:, 2 ) flux (:,:, 1 ) = flux (:,:, 1 ) * albsfc fsfc = fsfcd - flux (:,:, 1 ) ! 4.2  Absorption of upward flux do k = kx , 1 , - 1 dfabs (:,:, k ) = dfabs (:,:, k ) + flux (:,:, 1 ) flux (:,:, 1 ) = tau2 (:,:, k , 1 ) * flux (:,:, 1 ) dfabs (:,:, k ) = dfabs (:,:, k ) - flux (:,:, 1 ) flux (:,:, 1 ) = flux (:,:, 1 ) + tau2 (:,:, k , 3 ) end do ! 4.3  Net solar radiation = incoming - outgoing ftop = ftop - flux (:,:, 1 ) ! 5.  Initialization of longwave radiation model ! 5.1  Longwave transmissivity: ! function of layer mass, abs. humidity and cloud cover. ! Cloud-free levels (stratosphere + PBL) k = 1 tau2 (:,:, k , 1 ) = exp ( - psa * dhs ( k ) * ablwin ) tau2 (:,:, k , 2 ) = exp ( - psa * dhs ( k ) * ablco2 ) tau2 (:,:, k , 3 ) = 1.0 tau2 (:,:, k , 4 ) = 1.0 do k = 2 , kx , kx - 2 tau2 (:,:, k , 1 ) = exp ( - psa * dhs ( k ) * ablwin ) tau2 (:,:, k , 2 ) = exp ( - psa * dhs ( k ) * ablco2 ) tau2 (:,:, k , 3 ) = exp ( - psa * dhs ( k ) * ablwv1 * qa (:,:, k )) tau2 (:,:, k , 4 ) = exp ( - psa * dhs ( k ) * ablwv2 * qa (:,:, k )) end do ! Cloudy layers (free troposphere) acloud = cloudc * ablcl2 do k = 3 , nl1 do i = 1 , ix do j = 1 , il deltap = psa ( i , j ) * dhs ( k ) if ( k < icltop ( i , j )) then acloud1 = acloud ( i , j ) else acloud1 = ablcl1 * cloudc ( i , j ) endif tau2 ( i , j , k , 1 ) = exp ( - deltap * ( ablwin + acloud1 )) tau2 ( i , j , k , 2 ) = exp ( - deltap * ablco2 ) tau2 ( i , j , k , 3 ) = exp ( - deltap * max ( ablwv1 * qa ( i , j , k ), acloud ( i , j ))) tau2 ( i , j , k , 4 ) = exp ( - deltap * max ( ablwv2 * qa ( i , j , k ), acloud ( i , j ))) end do end do end do ! 5.2  Stratospheric correction terms eps1 = epslw / ( dhs ( 1 ) + dhs ( 2 )) stratc (:,:, 1 ) = stratz * psa stratc (:,:, 2 ) = eps1 * psa end !> Compute zonally-averaged fields to be used in the computation of !  short-wave absorption subroutine get_zonal_average_fields ( tyear ) use geometry , only : sia , coa real , intent ( in ) :: tyear !! time as fraction of year (0-1, 0 = 1jan.h00) real :: topsr ( il ), alpha , azen , coz1 , coz2 , dalpha , flat2 , fs0 real :: nzen , rzen integer :: j ! alpha = year phase ( 0 - 2pi, 0 = winter solstice = 22dec.h00 ) alpha = 4.0 * asin ( 1.0 ) * ( tyear + 1 0.0 / 36 5.0 ) dalpha = 0.0 coz1 = 1.0 * max ( 0.0 , cos ( alpha - dalpha )) coz2 = 1.8 azen = 1.0 nzen = 2 rzen = - cos ( alpha ) * 2 3.45 * asin ( 1.0 ) / 9 0.0 fs0 = 6.0 ! Solar radiation at the top call solar ( tyear , 4.0 * solc , topsr ) do j = 1 , il flat2 = 1.5 * sia ( j ) ** 2 - 0.5 ! Solar radiation at the top fsol (:, j ) = topsr ( j ) ! Ozone depth in upper and lower stratosphere ozupp (:, j ) = 0.5 * epssw ozone (:, j ) = 0.4 * epssw * ( 1.0 + coz1 * sia ( j ) + coz2 * flat2 ) ! Zenith angle correction to (downward) absorptivity zenit (:, j ) = 1.0 + azen * ( 1.0 - ( coa ( j ) * cos ( rzen ) + sia ( j ) * sin ( rzen ))) ** nzen ! Ozone absorption in upper and lower stratosphere ozupp (:, j ) = fsol (:, j ) * ozupp (:, j ) * zenit (:, j ) ozone (:, j ) = fsol (:, j ) * ozone (:, j ) * zenit (:, j ) ! Polar night cooling in the stratosphere stratz (:, j ) = max ( fs0 - fsol (:, j ), 0.0 ) end do end ! Average daily flux of solar radiation, from Hartmann (1994) subroutine solar ( tyear , csol , topsr ) use geometry , only : coa , sia real , intent ( in ) :: tyear !! time as fraction of year (0-1, 0 = 1jan.h00) real , intent ( in ) :: csol !! The solar constant [W/m&#94;2] real , intent ( out ) :: topsr ( il ) !! Daily-average insolation at the top of the atmosphere as a !! function of latitude integer :: j real :: ca1 , ca2 , ca3 , cdecl , ch0 , csolp , decl , fdis , h0 , alpha , pigr , sa1 real :: sa2 , sa3 , sdecl , sh0 , tdecl ! 1. Compute declination angle and Earth-Sun distance factor pigr = 2.0 * asin ( 1.0 ) alpha = 2.0 * pigr * tyear ca1 = cos ( alpha ) sa1 = sin ( alpha ) ca2 = ca1 * ca1 - sa1 * sa1 sa2 = 2. * sa1 * ca1 ca3 = ca1 * ca2 - sa1 * sa2 sa3 = sa1 * ca2 + sa2 * ca1 decl = 0.006918 - 0.399912 * ca1 + 0.070257 * sa1 - 0.006758 * ca2 + 0.000907 * sa2 & & - 0.002697 * ca3 + 0.001480 * sa3 fdis = 1.000110 + 0.034221 * ca1 + 0.001280 * sa1 + 0.000719 * ca2 + 0.000077 * sa2 cdecl = cos ( decl ) sdecl = sin ( decl ) tdecl = sdecl / cdecl ! 2. Compute daily-average insolation at the atm. top csolp = csol / pigr do j = 1 , il ch0 = min ( 1.0 , max ( - 1.0 , - tdecl * sia ( j ) / coa ( j ))) h0 = acos ( ch0 ) sh0 = sin ( h0 ) topsr ( j ) = csolp * fdis * ( h0 * sia ( j ) * sdecl + sh0 * coa ( j ) * cdecl ) end do end !>  Compute cloud-top level and cloud cover subroutine clouds ( qa , rh , precnv , precls , iptop , gse , fmask , icltop , cloudc , clstr ) integer :: iptop ( ix , il ) real , intent ( in ) :: qa ( ix , il , kx ) !! Specific humidity [g/kg] real , intent ( in ) :: rh ( ix , il , kx ) !! Relative humidity real , intent ( in ) :: precnv ( ix , il ) !! Convection precipitation real , intent ( in ) :: precls ( ix , il ) !! Large-scale condensational precipitation real , intent ( in ) :: gse ( ix , il ) !! Vertical gradient of dry static energy real , intent ( in ) :: fmask ( ix , il ) !! Fraction land-sea mask integer , intent ( out ) :: icltop ( ix , il ) !! Cloud top level real , intent ( out ) :: cloudc ( ix , il ) !! Total cloud cover real , intent ( out ) :: clstr ( ix , il ) !! Stratiform cloud cover integer :: i , j , k , nl1 , nlp real :: clfact , clstrl , drh , fstab , pr1 , rgse , rrcl nl1 = kx - 1 nlp = kx + 1 rrcl = 1. / ( rhcl2 - rhcl1 ) ! 1.  Cloud cover, defined as the sum of: !     - a term proportional to the square-root of precip. rate !     - a quadratic function of the max. relative humidity !       in tropospheric layers above PBL where Q > QACL : !       ( = 0 for RHmax < RHCL1, = 1 for RHmax > RHCL2 ) !     Cloud-top level: defined as the highest (i.e. least sigma) !       between the top of convection/condensation and !       the level of maximum relative humidity. do i = 1 , ix do j = 1 , il if ( rh ( i , j , nl1 ) > rhcl1 ) then cloudc ( i , j ) = rh ( i , j , nl1 ) - rhcl1 icltop ( i , j ) = nl1 else cloudc ( i , j ) = 0.0 icltop ( i , j ) = nlp end if end do end do do k = 3 , kx - 2 do i = 1 , ix do j = 1 , il drh = rh ( i , j , k ) - rhcl1 if ( drh > cloudc ( i , j ) . and . qa ( i , j , k ) > qacl ) then cloudc ( i , j ) = drh icltop ( i , j ) = k end if end do end do end do do i = 1 , ix do j = 1 , il pr1 = min ( pmaxcl , 8 6.4 * ( precnv ( i , j ) + precls ( i , j ))) cloudc ( i , j ) = min ( 1.0 , wpcl * sqrt ( pr1 ) + min ( 1.0 , cloudc ( i , j ) * rrcl ) ** 2.0 ) icltop ( i , j ) = min ( iptop ( i , j ), icltop ( i , j )) end do end do ! 2.  Equivalent specific humidity of clouds qcloud = qa (:,:, nl1 ) ! 3. Stratiform clouds at the top of PBL clfact = 1.2 rgse = 1.0 / ( gse_s1 - gse_s0 ) do i = 1 , ix do j = 1 , il ! Stratocumulus clouds over sea fstab = max ( 0.0 , min ( 1.0 , rgse * ( gse ( i , j ) - gse_s0 ))) clstr ( i , j ) = fstab * max ( clsmax - clfact * cloudc ( i , j ), 0.0 ) ! Stratocumulus clouds over land clstrl = max ( clstr ( i , j ), clsminl ) * rh ( i , j , kx ) clstr ( i , j ) = clstr ( i , j ) + fmask ( i , j ) * ( clstrl - clstr ( i , j )) end do end do end end module","tags":"","loc":"sourcefile/shortwave_radiation.f90.html"},{"title":"date.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~date.f90~~EfferentGraph sourcefile~date.f90 date.f90 sourcefile~params.f90 params.f90 sourcefile~date.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~date.f90~~AfferentGraph sourcefile~date.f90 date.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~date.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~speedy.f90->sourcefile~input_output.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~prognostics.f90 prognostics.f90 sourcefile~speedy.f90->sourcefile~prognostics.f90 sourcefile~coupler.f90 coupler.f90 sourcefile~speedy.f90->sourcefile~coupler.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~input_output.f90->sourcefile~date.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~land_model.f90->sourcefile~date.f90 sourcefile~land_model.f90->sourcefile~input_output.f90 sourcefile~interpolation.f90 interpolation.f90 sourcefile~land_model.f90->sourcefile~interpolation.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~land_model.f90->sourcefile~boundaries.f90 sourcefile~interpolation.f90->sourcefile~date.f90 sourcefile~forcing.f90->sourcefile~date.f90 sourcefile~forcing.f90->sourcefile~land_model.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~forcing.f90->sourcefile~sea_model.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~forcing.f90->sourcefile~surface_fluxes.f90 sourcefile~forcing.f90->sourcefile~boundaries.f90 sourcefile~initialization.f90->sourcefile~date.f90 sourcefile~initialization.f90->sourcefile~input_output.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~initialization.f90->sourcefile~sea_model.f90 sourcefile~initialization.f90->sourcefile~prognostics.f90 sourcefile~initialization.f90->sourcefile~coupler.f90 sourcefile~physics.f90 physics.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~initialization.f90->sourcefile~boundaries.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~sea_model.f90->sourcefile~date.f90 sourcefile~sea_model.f90->sourcefile~input_output.f90 sourcefile~sea_model.f90->sourcefile~interpolation.f90 sourcefile~sea_model.f90->sourcefile~boundaries.f90 sourcefile~prognostics.f90->sourcefile~input_output.f90 sourcefile~prognostics.f90->sourcefile~boundaries.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 sourcefile~coupler.f90->sourcefile~land_model.f90 sourcefile~coupler.f90->sourcefile~sea_model.f90 sourcefile~physics.f90->sourcefile~land_model.f90 sourcefile~physics.f90->sourcefile~sea_model.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~physics.f90->sourcefile~boundaries.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~time_stepping.f90->sourcefile~prognostics.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 var pansourcefiledatef90AfferentGraph = svgPanZoom('#sourcefiledatef90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules date Source Code date.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !  date: 01/05/2019 !  For keeping track of the model's date and time. module date implicit none private public model_datetime , start_datetime , end_datetime public imont1 , tmonth , tyear , ndaycal public isst0 public datetime_equal , initialize_date , newdate !> For storing dates and times. type datetime integer :: year integer :: month integer :: day integer :: hour integer :: minute end type ! Date and time variables type ( datetime ) :: model_datetime !! The model's current datetime (continuously updated) type ( datetime ) :: start_datetime !! The start datetime type ( datetime ) :: end_datetime !! The end datetime integer :: imont1 !! The month used for computing seasonal forcing fields real :: tmonth !! The fraction of the current month elapsed real :: tyear !! The fraction of the current year elapsed integer :: isst0 !! Initial month of SST anomalies integer :: ndaycal ( 12 , 2 ) !! The model calendar integer , parameter :: ncal = 365 !! The number of days in a year !> The number of days in each month integer :: ncal365 ( 12 ) = ( / 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 / ) contains !> Checks whether two datetimes are equal. logical function datetime_equal ( datetime1 , datetime2 ) type ( datetime ), intent ( in ) :: datetime1 , datetime2 if ( datetime1 % year == datetime2 % year . and . & datetime1 % month == datetime2 % month . and . & datetime1 % day == datetime2 % day . and . & datetime1 % hour == datetime2 % hour . and . & datetime1 % minute == datetime2 % minute ) then datetime_equal = . true . else datetime_equal = . false . end if end function !> Initializes model date and calendar. subroutine initialize_date use params , only : iseasc namelist / date / start_datetime , end_datetime integer :: jm logical :: namelist_file_exists ! Set default values for start and end datetime start_datetime = datetime ( 1982 , 1 , 1 , 0 , 0 ) end_datetime = datetime ( 1982 , 2 , 1 , 0 , 0 ) ! Read namelist file inquire ( file = \"namelist.nml\" , exist = namelist_file_exists ) if ( namelist_file_exists ) then open ( 10 , file = \"namelist.nml\" ) read ( 10 , nml = date ) close ( 10 ) end if ! Current model datetime is start datetime model_datetime = start_datetime ! Print values to screen write ( * , '(A12,I4,A,I0.2,A,I0.2,A,I0.2,A,I0.2)' ) 'Start date: ' , & & start_datetime % year , '/' , start_datetime % month , '/' , start_datetime % day , ' ' , & & start_datetime % hour , ':' , start_datetime % minute write ( * , '(A12,I4,A,I0.2,A,I0.2,A,I0.2,A,I0.2)' ) 'End date: ' , & & end_datetime % year , '/' , end_datetime % month , '/' , end_datetime % day , ' ' , & & end_datetime % hour , ':' , end_datetime % minute ! Set calendar if ( ncal == 365 ) then ndaycal (:, 1 ) = ncal365 (:) else ndaycal (:, 1 ) = 30 end if ndaycal ( 1 , 2 ) = 0 do jm = 2 , 12 ndaycal ( jm , 2 ) = ndaycal ( jm - 1 , 1 ) + ndaycal ( jm - 1 , 2 ) end do ! Additional variables to define forcing terms and boundary cond. if ( iseasc >= 1 ) then imont1 = model_datetime % month tmonth = ( model_datetime % day - 0.5 ) / float ( ndaycal ( model_datetime % month , 1 )) tyear = ( ndaycal ( model_datetime % month , 2 ) + model_datetime % day - 0.5 ) / float ( ncal ) else imont1 = start_datetime % month tmonth = 0.5 tyear = ( ndaycal ( imont1 , 2 ) + 0.5 * ndaycal ( imont1 , 2 )) / float ( ncal ) end if end subroutine !> Updates the current datetime and related date variables. subroutine newdate use params , only : iseasc , nsteps ! Increment minute counter model_datetime % minute = model_datetime % minute + int ( 24 * 60 / nsteps ) ! Increment hour counter if necessary if ( model_datetime % minute >= 60 ) then model_datetime % minute = mod ( model_datetime % minute , 60 ) model_datetime % hour = model_datetime % hour + 1 end if ! Increment day counter if necessary if ( model_datetime % hour >= 24 ) then model_datetime % hour = mod ( model_datetime % hour , 24 ) model_datetime % day = model_datetime % day + 1 end if ! Increment month counter if necessary ! Leap year and February? if ( mod ( model_datetime % year , 4 ) == 0 . and . model_datetime % month == 2 ) then if ( model_datetime % day > 29 ) then model_datetime % day = 1 model_datetime % month = model_datetime % month + 1 end if else if ( model_datetime % day > ndaycal ( model_datetime % month , 1 )) then model_datetime % day = 1 model_datetime % month = model_datetime % month + 1 end if end if ! Increment year counter if necessary if ( model_datetime % month > 12 ) then model_datetime % month = 1 model_datetime % year = model_datetime % year + 1 end if ! additional variables to define forcing terms and boundary cond. if ( iseasc >= 1 ) then imont1 = model_datetime % month tmonth = ( model_datetime % day - 0.5 ) / float ( ndaycal ( model_datetime % month , 1 )) tyear = ( ndaycal ( model_datetime % month , 2 ) + model_datetime % day - 0.5 ) / float ( ncal ) else imont1 = start_datetime % month tmonth = 0.5 tyear = ( ndaycal ( imont1 , 2 ) + 0.5 * ndaycal ( imont1 , 2 )) / float ( ncal ) end if end subroutine end module","tags":"","loc":"sourcefile/date.f90.html"},{"title":"geometry.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~geometry.f90~~EfferentGraph sourcefile~geometry.f90 geometry.f90 sourcefile~params.f90 params.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~geometry.f90~~AfferentGraph sourcefile~geometry.f90 geometry.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~input_output.f90->sourcefile~geometry.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~prognostics.f90 prognostics.f90 sourcefile~prognostics.f90->sourcefile~geometry.f90 sourcefile~prognostics.f90->sourcefile~input_output.f90 sourcefile~prognostics.f90->sourcefile~spectral.f90 sourcefile~diagnostics.f90 diagnostics.f90 sourcefile~prognostics.f90->sourcefile~diagnostics.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~prognostics.f90->sourcefile~boundaries.f90 sourcefile~large_scale_condensation.f90 large_scale_condensation.f90 sourcefile~large_scale_condensation.f90->sourcefile~geometry.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~surface_fluxes.f90->sourcefile~geometry.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 sourcefile~legendre.f90 legendre.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~geopotential.f90 geopotential.f90 sourcefile~geopotential.f90->sourcefile~geometry.f90 sourcefile~implicit.f90 implicit.f90 sourcefile~implicit.f90->sourcefile~geometry.f90 sourcefile~horizontal_diffusion.f90 horizontal_diffusion.f90 sourcefile~implicit.f90->sourcefile~horizontal_diffusion.f90 sourcefile~longwave_radiation.f90 longwave_radiation.f90 sourcefile~longwave_radiation.f90->sourcefile~geometry.f90 sourcefile~horizontal_diffusion.f90->sourcefile~geometry.f90 sourcefile~fourier.f90 fourier.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~initialization.f90->sourcefile~geometry.f90 sourcefile~initialization.f90->sourcefile~input_output.f90 sourcefile~initialization.f90->sourcefile~prognostics.f90 sourcefile~initialization.f90->sourcefile~geopotential.f90 sourcefile~initialization.f90->sourcefile~horizontal_diffusion.f90 sourcefile~physics.f90 physics.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~initialization.f90->sourcefile~sea_model.f90 sourcefile~initialization.f90->sourcefile~spectral.f90 sourcefile~coupler.f90 coupler.f90 sourcefile~initialization.f90->sourcefile~coupler.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~initialization.f90->sourcefile~boundaries.f90 sourcefile~physics.f90->sourcefile~geometry.f90 sourcefile~physics.f90->sourcefile~large_scale_condensation.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~physics.f90->sourcefile~longwave_radiation.f90 sourcefile~physics.f90->sourcefile~sea_model.f90 sourcefile~shortwave_radiation.f90 shortwave_radiation.f90 sourcefile~physics.f90->sourcefile~shortwave_radiation.f90 sourcefile~vertical_diffusion.f90 vertical_diffusion.f90 sourcefile~physics.f90->sourcefile~vertical_diffusion.f90 sourcefile~convection.f90 convection.f90 sourcefile~physics.f90->sourcefile~convection.f90 sourcefile~physics.f90->sourcefile~spectral.f90 sourcefile~physics.f90->sourcefile~land_model.f90 sourcefile~sppt.f90 sppt.f90 sourcefile~physics.f90->sourcefile~sppt.f90 sourcefile~physics.f90->sourcefile~boundaries.f90 sourcefile~sea_model.f90->sourcefile~geometry.f90 sourcefile~sea_model.f90->sourcefile~input_output.f90 sourcefile~sea_model.f90->sourcefile~boundaries.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~tendencies.f90->sourcefile~geometry.f90 sourcefile~tendencies.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90->sourcefile~geopotential.f90 sourcefile~tendencies.f90->sourcefile~implicit.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~tendencies.f90->sourcefile~spectral.f90 sourcefile~shortwave_radiation.f90->sourcefile~geometry.f90 sourcefile~vertical_diffusion.f90->sourcefile~geometry.f90 sourcefile~convection.f90->sourcefile~geometry.f90 sourcefile~spectral.f90->sourcefile~geometry.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~input_output.f90 sourcefile~speedy.f90->sourcefile~prognostics.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~speedy.f90->sourcefile~shortwave_radiation.f90 sourcefile~speedy.f90->sourcefile~diagnostics.f90 sourcefile~speedy.f90->sourcefile~coupler.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~land_model.f90->sourcefile~input_output.f90 sourcefile~land_model.f90->sourcefile~boundaries.f90 sourcefile~diagnostics.f90->sourcefile~spectral.f90 sourcefile~coupler.f90->sourcefile~sea_model.f90 sourcefile~coupler.f90->sourcefile~land_model.f90 sourcefile~time_stepping.f90->sourcefile~prognostics.f90 sourcefile~time_stepping.f90->sourcefile~implicit.f90 sourcefile~time_stepping.f90->sourcefile~horizontal_diffusion.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 sourcefile~time_stepping.f90->sourcefile~spectral.f90 sourcefile~forcing.f90->sourcefile~surface_fluxes.f90 sourcefile~forcing.f90->sourcefile~longwave_radiation.f90 sourcefile~forcing.f90->sourcefile~horizontal_diffusion.f90 sourcefile~forcing.f90->sourcefile~sea_model.f90 sourcefile~forcing.f90->sourcefile~shortwave_radiation.f90 sourcefile~forcing.f90->sourcefile~spectral.f90 sourcefile~forcing.f90->sourcefile~land_model.f90 sourcefile~forcing.f90->sourcefile~boundaries.f90 sourcefile~sppt.f90->sourcefile~spectral.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~boundaries.f90->sourcefile~spectral.f90 var pansourcefilegeometryf90AfferentGraph = svgPanZoom('#sourcefilegeometryf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules geometry Source Code geometry.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !  date: 01/05/2019 !  For storing all variables related to the model's grid space. module geometry use params implicit none private public initialize_geometry public hsg , dhs , fsg , dhsr , fsgr , radang , coriol , sia , coa , sia_half , coa_half , & cosg , cosgr , cosgr2 ! Vertical level parameters real :: hsg ( kx + 1 ) !! Half sigma levels real :: dhs ( kx ) !! Sigma level thicknesses real :: fsg ( kx ) !! Full sigma levels real :: dhsr ( kx ) !! 1/(2*sigma level thicknesses) real :: fsgr ( kx ) !! akap/(2*full sigma levels) ! Functions of latitude and longitude real , dimension ( il ) :: radang !! Latitudes in radians real , dimension ( il ) :: coriol !! Coriolis parameter as a function of latitude real , dimension ( il ) :: sia !! sine(latitude) real , dimension ( il ) :: coa !! cosine(latitude) real , dimension ( iy ) :: sia_half !! sine(latitude) over one hemisphere only real , dimension ( il ) :: coa_half !! cosine(latitude) over one hemisphere only real , dimension ( il ) :: cosg !! Same as coa (TODO: remove) real , dimension ( il ) :: cosgr !! 1/coa real , dimension ( il ) :: cosgr2 !! 1/coa&#94;2 contains !> Initializes all of the model geometry variables. subroutine initialize_geometry use physical_constants , only : akap , omega integer j , jj , k ! Definition of model levels ! Half (vertical velocity) levels if ( kx == 5 ) then hsg (: 6 ) = ( / 0.000 , 0.150 , 0.350 , 0.650 , 0.900 , 1.000 / ) else if ( kx == 7 ) then hsg (: 8 ) = ( / 0.020 , 0.140 , 0.260 , 0.420 , 0.600 , 0.770 , 0.900 , 1.000 / ) else if ( kx == 8 ) then hsg (: 9 ) = ( / 0.000 , 0.050 , 0.140 , 0.260 , 0.420 , 0.600 , 0.770 , 0.900 , 1.000 / ) end if ! Layer thicknesses and full (u,v,T) levels do k = 1 , kx dhs ( k ) = hsg ( k + 1 ) - hsg ( k ) fsg ( k ) = 0.5 * ( hsg ( k + 1 ) + hsg ( k )) end do ! Additional functions of sigma do k = 1 , kx dhsr ( k ) = 0.5 / dhs ( k ) fsgr ( k ) = akap / ( 2. * fsg ( k )) end do ! Horizontal functions ! Latitudes and functions of latitude ! NB: J=1 is Southernmost point! do j = 1 , iy jj = il + 1 - j sia_half ( j ) = cos ( 3.141592654 * ( j - 0.25 ) / ( il + 0.5 )) coa_half ( j ) = sqrt ( 1.0 - sia_half ( j ) ** 2.0 ) sia ( j ) = - sia_half ( j ) sia ( jj ) = sia_half ( j ) coa ( j ) = coa_half ( j ) coa ( jj ) = coa_half ( j ) radang ( j ) = - asin ( sia_half ( j )) radang ( jj ) = asin ( sia_half ( j )) end do ! Expand cosine and its reciprocal to cover both hemispheres do j = 1 , iy jj = il + 1 - j cosg ( j ) = coa_half ( j ) cosg ( jj ) = coa_half ( j ) cosgr ( j ) = 1. / coa_half ( j ) cosgr ( jj ) = 1. / coa_half ( j ) cosgr2 ( j ) = 1. / ( coa_half ( j ) * coa_half ( j )) cosgr2 ( jj ) = 1. / ( coa_half ( j ) * coa_half ( j )) end do coriol = 2.0 * omega * sia end subroutine end module","tags":"","loc":"sourcefile/geometry.f90.html"},{"title":"legendre.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~legendre.f90~~EfferentGraph sourcefile~legendre.f90 legendre.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~legendre.f90->sourcefile~geometry.f90 sourcefile~params.f90 params.f90 sourcefile~legendre.f90->sourcefile~params.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~legendre.f90->sourcefile~physical_constants.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~legendre.f90~~AfferentGraph sourcefile~legendre.f90 legendre.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~spectral.f90->sourcefile~legendre.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~prognostics.f90 prognostics.f90 sourcefile~prognostics.f90->sourcefile~spectral.f90 sourcefile~prognostics.f90->sourcefile~input_output.f90 sourcefile~diagnostics.f90 diagnostics.f90 sourcefile~prognostics.f90->sourcefile~diagnostics.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~prognostics.f90->sourcefile~boundaries.f90 sourcefile~diagnostics.f90->sourcefile~spectral.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~time_stepping.f90->sourcefile~spectral.f90 sourcefile~time_stepping.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~forcing.f90->sourcefile~spectral.f90 sourcefile~forcing.f90->sourcefile~boundaries.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~forcing.f90->sourcefile~land_model.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~forcing.f90->sourcefile~sea_model.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~forcing.f90->sourcefile~surface_fluxes.f90 sourcefile~sppt.f90 sppt.f90 sourcefile~sppt.f90->sourcefile~spectral.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~initialization.f90->sourcefile~spectral.f90 sourcefile~initialization.f90->sourcefile~input_output.f90 sourcefile~initialization.f90->sourcefile~prognostics.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~physics.f90 physics.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~initialization.f90->sourcefile~boundaries.f90 sourcefile~initialization.f90->sourcefile~sea_model.f90 sourcefile~coupler.f90 coupler.f90 sourcefile~initialization.f90->sourcefile~coupler.f90 sourcefile~physics.f90->sourcefile~spectral.f90 sourcefile~physics.f90->sourcefile~sppt.f90 sourcefile~physics.f90->sourcefile~boundaries.f90 sourcefile~physics.f90->sourcefile~land_model.f90 sourcefile~physics.f90->sourcefile~sea_model.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~tendencies.f90->sourcefile~spectral.f90 sourcefile~tendencies.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~boundaries.f90->sourcefile~spectral.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~input_output.f90 sourcefile~speedy.f90->sourcefile~prognostics.f90 sourcefile~speedy.f90->sourcefile~diagnostics.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~speedy.f90->sourcefile~coupler.f90 sourcefile~land_model.f90->sourcefile~input_output.f90 sourcefile~land_model.f90->sourcefile~boundaries.f90 sourcefile~sea_model.f90->sourcefile~input_output.f90 sourcefile~sea_model.f90->sourcefile~boundaries.f90 sourcefile~coupler.f90->sourcefile~land_model.f90 sourcefile~coupler.f90->sourcefile~sea_model.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 var pansourcefilelegendref90AfferentGraph = svgPanZoom('#sourcefilelegendref90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules legendre Source Code legendre.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !  date: 09/05/2019 !  For computing direct and inverse Legendre transforms. module legendre use params implicit none private public initialize_legendre , legendre_dir , legendre_inv public epsi real :: cpol ( 2 * mx , nx , iy ) !! The Legendre polynomials real :: epsi ( mx + 1 , nx + 1 ) !! Epsilon function used for various spectral calculations real :: repsi ( mx + 1 , nx + 1 ) !! 1/epsi integer :: nsh2 ( nx ) !! Used for defining shape of spectral triangle real , dimension ( iy ) :: wt !! Gaussian weights used for integration in direct Legendre transform contains !> Initializes Legendre transforms and constants used for other subroutines !  that manipulate spherical harmonics. subroutine initialize_legendre use physical_constants , only : rearth real :: emm2 , ell2 , poly ( mx , nx ) integer :: j , n , m , m1 , m2 , mm ( mx ), wavenum_tot ( mx , nx ) ! First compute Gaussian latitudes and weights at the IY points from ! pole to equator wt = get_weights () do n = 1 , nx nsh2 ( n ) = 0 do m = 1 , mx mm ( m ) = m - 1 wavenum_tot ( m , n ) = mm ( m ) + n - 1 if ( wavenum_tot ( m , n ) <= ( trunc + 1 ) . or . ix /= 4 * iy ) nsh2 ( n ) = nsh2 ( n ) + 2 end do end do do m = 1 , mx + 1 do n = 1 , nx + 1 emm2 = float ( m - 1 ) ** 2 ell2 = float ( n + m - 2 ) ** 2 if ( n == ( nx + 1 )) then epsi ( m , n ) = 0.0 else if ( n == 1 . and . m == 1 ) then epsi ( m , n ) = 0.0 else epsi ( m , n ) = sqrt (( ell2 - emm2 ) / ( 4.0 * ell2 - 1.0 )) end if repsi ( m , n ) = 0.0 if ( epsi ( m , n ) > 0. ) repsi ( m , n ) = 1.0 / epsi ( m , n ) end do end do ! Generate associated Legendre polynomials do j = 1 , iy poly = get_legendre_poly ( j ) do n = 1 , nx do m = 1 , mx m1 = 2 * m - 1 m2 = 2 * m cpol ( m1 , n , j ) = poly ( m , n ) cpol ( m2 , n , j ) = poly ( m , n ) end do end do end do end subroutine !> Computes inverse Legendre transformation. function legendre_inv ( input ) result ( output ) ! 2*mx because these arrays actually represent complex variables real , intent ( in ) :: input ( 2 * mx , nx ) !! Input field real :: output ( 2 * mx , il ) !! Output field real :: even ( 2 * mx ), odd ( 2 * mx ) integer :: j , j1 , m , n ! Loop over Northern Hemisphere, computing odd and even decomposition of ! incoming field do j = 1 , iy j1 = il + 1 - j ! Initialise arrays even = 0.0 odd = 0.0 ! Compute even decomposition do n = 1 , nx , 2 do m = 1 , nsh2 ( n ) even ( m ) = even ( m ) + input ( m , n ) * cpol ( m , n , j ) end do end do ! Compute odd decomposition do n = 2 , nx , 2 do m = 1 , nsh2 ( n ) odd ( m ) = odd ( m ) + input ( m , n ) * cpol ( m , n , j ) end do end do ! Compute Southern Hemisphere output (:, j1 ) = even + odd ! Compute Northern Hemisphere output (:, j ) = even - odd end do end function !> Computes direct Legendre transformation. function legendre_dir ( input ) result ( output ) ! 2*mx because these arrays actually represent complex variables real , intent ( in ) :: input ( 2 * mx , il ) !! Input field real :: output ( 2 * mx , nx ) !! Output field real :: even ( 2 * mx , iy ), odd ( 2 * mx , iy ) integer :: j , j1 , m , n ! Initialise output array output = 0.0 ! Loop over Northern Hemisphere, computing odd and even decomposition of ! incoming field. The Legendre weights (wt) are applied here do j = 1 , iy ! Corresponding Southern Hemisphere latitude j1 = il + 1 - j even (:, j ) = ( input (:, j1 ) + input (:, j )) * wt ( j ) odd (:, j ) = ( input (:, j1 ) - input (:, j )) * wt ( j ) end do ! The parity of an associated Legendre polynomial is the same ! as the parity of n' - m'. n', m' are the actual total wavenumber and zonal ! wavenumber, n and m are the indices used for SPEEDY's spectral packing. ! m' = m - 1 and n' = m + n - 2, therefore n' - m' = n - 1 ! Loop over coefficients corresponding to even associated Legendre ! polynomials do n = 1 , trunc + 1 , 2 do m = 1 , nsh2 ( n ) output ( m , n ) = dot_product ( cpol ( m , n ,: iy ), even ( m ,: iy )) end do end do ! Loop over coefficients corresponding to odd associated Legendre ! polynomials do n = 2 , trunc + 1 , 2 do m = 1 , nsh2 ( n ) output ( m , n ) = dot_product ( cpol ( m , n ,: iy ), odd ( m ,: iy )) end do end do end function !> Compute Gaussian weights for direct Legendre transform function get_weights () result ( w ) ! A slightly modified version of a program in Numerical Recipes ! (Cambridge Univ. Press, 1989). real :: w ( iy ) !! Weights in gaussian quadrature (sum should equal 1.0) real :: z , z1 , p1 , p2 , p3 , pp real , parameter :: eps = 3.0e-14 integer :: n , j , i n = 2 * iy z1 = 2.0 do i = 1 , iy z = cos ( 3.141592654 * ( i - 0.25 ) / ( n + 0.5 )) do while ( abs ( z - z1 ) > eps ) p1 = 1.d0 p2 = 0.d0 do j = 1 , n p3 = p2 p2 = p1 p1 = (( 2.0 * j - 1.0 ) * z * p2 - ( j - 1.0 ) * p3 ) / j end do pp = n * ( z * p1 - p2 ) / ( z ** 2.0 - 1.0 ) z1 = z z = z1 - p1 / pp end do w ( i ) = 2.0 / (( 1.0 - z ** 2.0 ) * pp ** 2.0 ) end do end function !> Compute associated Legendre polynomials at given latitude. function get_legendre_poly ( j ) result ( poly ) use geometry , only : sia_half , coa_half integer , intent ( in ) :: j !! The latitude to compute the polynomials at real :: poly ( mx , nx ) !! The Legendre polynomials real , parameter :: small = 1.e-30 real :: consq ( mx ) integer :: m , n real :: alp ( mx + 1 , nx ), x , y y = coa_half ( j ) x = sia_half ( j ) do m = 1 , mx consq ( m ) = sqrt ( 0.5 * ( 2.0 * float ( m ) + 1.0 ) / float ( m )) end do ! start recursion with N=1 (M=L) diagonal alp ( 1 , 1 ) = sqrt ( 0.5 ) do m = 2 , mx + 1 alp ( m , 1 ) = consq ( m - 1 ) * y * alp ( m - 1 , 1 ) end do ! continue with other elements do m = 1 , mx + 1 alp ( m , 2 ) = ( x * alp ( m , 1 )) * repsi ( m , 2 ) end do do n = 3 , nx do m = 1 , mx + 1 alp ( m , n ) = ( x * alp ( m , n - 1 ) - epsi ( m , n - 1 ) * alp ( m , n - 2 )) * repsi ( m , n ) end do end do ! zero polynomials with absolute values smaller than 10**(-30) do n = 1 , nx do m = 1 , mx + 1 if ( abs ( alp ( m , n )) <= small ) alp ( m , n ) = 0.0 end do end do ! pick off the required polynomials poly = alp ( 1 : mx , 1 : nx ) end function end module","tags":"","loc":"sourcefile/legendre.f90.html"},{"title":"fourier.f90 – SPEEDY.f90","text":"This file depends on sourcefile~~fourier.f90~~EfferentGraph sourcefile~fourier.f90 fourier.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~fourier.f90->sourcefile~geometry.f90 sourcefile~params.f90 params.f90 sourcefile~fourier.f90->sourcefile~params.f90 sourcefile~geometry.f90->sourcefile~params.f90 sourcefile~physical_constants.f90 physical_constants.f90 sourcefile~geometry.f90->sourcefile~physical_constants.f90 sourcefile~physical_constants.f90->sourcefile~params.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~fourier.f90~~AfferentGraph sourcefile~fourier.f90 fourier.f90 sourcefile~spectral.f90 spectral.f90 sourcefile~spectral.f90->sourcefile~fourier.f90 sourcefile~input_output.f90 input_output.f90 sourcefile~input_output.f90->sourcefile~spectral.f90 sourcefile~prognostics.f90 prognostics.f90 sourcefile~prognostics.f90->sourcefile~spectral.f90 sourcefile~prognostics.f90->sourcefile~input_output.f90 sourcefile~diagnostics.f90 diagnostics.f90 sourcefile~prognostics.f90->sourcefile~diagnostics.f90 sourcefile~boundaries.f90 boundaries.f90 sourcefile~prognostics.f90->sourcefile~boundaries.f90 sourcefile~diagnostics.f90->sourcefile~spectral.f90 sourcefile~time_stepping.f90 time_stepping.f90 sourcefile~time_stepping.f90->sourcefile~spectral.f90 sourcefile~time_stepping.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90 tendencies.f90 sourcefile~time_stepping.f90->sourcefile~tendencies.f90 sourcefile~forcing.f90 forcing.f90 sourcefile~forcing.f90->sourcefile~spectral.f90 sourcefile~forcing.f90->sourcefile~boundaries.f90 sourcefile~land_model.f90 land_model.f90 sourcefile~forcing.f90->sourcefile~land_model.f90 sourcefile~sea_model.f90 sea_model.f90 sourcefile~forcing.f90->sourcefile~sea_model.f90 sourcefile~surface_fluxes.f90 surface_fluxes.f90 sourcefile~forcing.f90->sourcefile~surface_fluxes.f90 sourcefile~sppt.f90 sppt.f90 sourcefile~sppt.f90->sourcefile~spectral.f90 sourcefile~initialization.f90 initialization.f90 sourcefile~initialization.f90->sourcefile~spectral.f90 sourcefile~initialization.f90->sourcefile~input_output.f90 sourcefile~initialization.f90->sourcefile~prognostics.f90 sourcefile~initialization.f90->sourcefile~time_stepping.f90 sourcefile~initialization.f90->sourcefile~forcing.f90 sourcefile~physics.f90 physics.f90 sourcefile~initialization.f90->sourcefile~physics.f90 sourcefile~initialization.f90->sourcefile~boundaries.f90 sourcefile~initialization.f90->sourcefile~sea_model.f90 sourcefile~coupler.f90 coupler.f90 sourcefile~initialization.f90->sourcefile~coupler.f90 sourcefile~physics.f90->sourcefile~spectral.f90 sourcefile~physics.f90->sourcefile~sppt.f90 sourcefile~physics.f90->sourcefile~boundaries.f90 sourcefile~physics.f90->sourcefile~land_model.f90 sourcefile~physics.f90->sourcefile~sea_model.f90 sourcefile~physics.f90->sourcefile~surface_fluxes.f90 sourcefile~tendencies.f90->sourcefile~spectral.f90 sourcefile~tendencies.f90->sourcefile~prognostics.f90 sourcefile~tendencies.f90->sourcefile~physics.f90 sourcefile~boundaries.f90->sourcefile~spectral.f90 sourcefile~boundaries.f90->sourcefile~input_output.f90 sourcefile~speedy.f90 speedy.f90 sourcefile~speedy.f90->sourcefile~input_output.f90 sourcefile~speedy.f90->sourcefile~prognostics.f90 sourcefile~speedy.f90->sourcefile~diagnostics.f90 sourcefile~speedy.f90->sourcefile~time_stepping.f90 sourcefile~speedy.f90->sourcefile~forcing.f90 sourcefile~speedy.f90->sourcefile~initialization.f90 sourcefile~speedy.f90->sourcefile~coupler.f90 sourcefile~land_model.f90->sourcefile~input_output.f90 sourcefile~land_model.f90->sourcefile~boundaries.f90 sourcefile~sea_model.f90->sourcefile~input_output.f90 sourcefile~sea_model.f90->sourcefile~boundaries.f90 sourcefile~coupler.f90->sourcefile~land_model.f90 sourcefile~coupler.f90->sourcefile~sea_model.f90 sourcefile~surface_fluxes.f90->sourcefile~land_model.f90 var pansourcefilefourierf90AfferentGraph = svgPanZoom('#sourcefilefourierf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules fourier Source Code fourier.f90 Source Code !> author: Sam Hatfield, Fred Kucharski, Franco Molteni !  date: 01/05/2019 !  For computing direct and inverse Fourier transforms. module fourier use params implicit none private public initialize_fourier , fourier_inv , fourier_dir real :: work ( ix ) !! Work array required by FFTPACK. Contains trigonometric functions etc. integer :: ifac ( 15 ) !! Work array required by FFTPACK. Contains prime factors contains !> Initializes the Fourier transforms. subroutine initialize_fourier call rffti1 ( ix , work , ifac ) end subroutine !> Transforms Fourier coefficients to grid-point data. function fourier_inv ( input , kcos ) result ( output ) use geometry , only : cosgr real , intent ( in ) :: input ( 2 * mx , il ) !! Input field integer , intent ( in ) :: kcos !! Scale output by cos(lat) (1) or not (0) real :: output ( ix , il ) !! Output field integer :: j , m real :: fvar ( ix ), ch ( ix ) do j = 1 , il fvar ( 1 ) = input ( 1 , j ) do m = 3 , 2 * mx fvar ( m - 1 ) = input ( m , j ) end do do m = 2 * mx , ix fvar ( m ) = 0.0 end do ! Inverse FFT call rfftb1 ( ix , fvar , ch , work , ifac ) ! Copy output into grid-point field, scaling by cos(lat) if needed if ( kcos == 1 ) then output (:, j ) = fvar else output (:, j ) = fvar * cosgr ( j ) end if end do end function !> Transforms grid-point data to Fourier coefficients. function fourier_dir ( input ) result ( output ) real , intent ( in ) :: input ( ix , il ) !! Input field real :: output ( 2 * mx , il ) !! Output field integer :: j , m real :: fvar ( ix ), scale real :: ch ( ix ) ! Copy grid-point data into working array do j = 1 , il fvar = input (:, j ) ! Direct FFT call rfftf1 ( ix , fvar , ch , work , ifac ) ! Copy output into spectral field, dividing by no. of long. scale = 1.0 / float ( ix ) ! Mean value (a(0)) output ( 1 , j ) = fvar ( 1 ) * scale output ( 2 , j ) = 0.0 do m = 3 , 2 * mx output ( m , j ) = fvar ( m - 1 ) * scale end do end do end function end module","tags":"","loc":"sourcefile/fourier.f90.html"},{"title":"datetime – SPEEDY.f90 ","text":"type, private :: datetime For storing dates and times. Contents Variables year month day hour minute Components Type Visibility Attributes Name Initial integer, public :: year integer, public :: month integer, public :: day integer, public :: hour integer, public :: minute","tags":"","loc":"type/datetime.html"},{"title":"rffti1 – SPEEDY.f90","text":"subroutine rffti1(n, wa, ifac) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(inout) :: wa (*) integer, intent(inout) :: ifac (*) Called by proc~~rffti1~~CalledByGraph proc~rffti1 rffti1 proc~initialize_fourier initialize_fourier proc~initialize_fourier->proc~rffti1 proc~initialize_spectral initialize_spectral proc~initialize_spectral->proc~initialize_fourier proc~initialize initialize proc~initialize->proc~initialize_spectral program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rffti1.html"},{"title":"rfftb1 – SPEEDY.f90","text":"subroutine rfftb1(n, c, ch, wa, ifac) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(inout) :: c (*) real, intent(inout) :: ch (*) real, intent(inout) :: wa (*) integer, intent(in) :: ifac (*) Called by proc~~rfftb1~~CalledByGraph proc~rfftb1 rfftb1 proc~fourier_inv fourier_inv proc~fourier_inv->proc~rfftb1 proc~spec_to_grid spec_to_grid proc~spec_to_grid->proc~fourier_inv proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_grid_point_tendencies->proc~spec_to_grid proc~gen_sppt gen_sppt proc~gen_sppt->proc~spec_to_grid proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->proc~spec_to_grid proc~get_physical_tendencies->proc~gen_sppt proc~spectral_truncation spectral_truncation proc~spectral_truncation->proc~spec_to_grid proc~output output proc~output->proc~spec_to_grid proc~initialize_boundaries initialize_boundaries proc~initialize_boundaries->proc~spectral_truncation proc~get_tendencies get_tendencies proc~get_tendencies->proc~get_grid_point_tendencies proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_from_rest_state->proc~output proc~initialize_prognostics initialize_prognostics proc~initialize_prognostics->proc~initialize_from_rest_state proc~initialize initialize proc~initialize->proc~initialize_boundaries proc~initialize->proc~initialize_prognostics proc~first_step first_step proc~initialize->proc~first_step proc~step step proc~step->proc~get_tendencies program~speedy speedy program~speedy->proc~initialize program~speedy->proc~step proc~first_step->proc~step var panprocrfftb1CalledByGraph = svgPanZoom('#procrfftb1CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rfftb1.html"},{"title":"rfftf1 – SPEEDY.f90","text":"subroutine rfftf1(n, c, ch, wa, ifac) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real, intent(inout) :: c (*) real, intent(inout) :: ch (*) real, intent(inout) :: wa (*) integer, intent(in) :: ifac (*) Called by proc~~rfftf1~~CalledByGraph proc~rfftf1 rfftf1 proc~fourier_dir fourier_dir proc~fourier_dir->proc~rfftf1 proc~grid_to_spec grid_to_spec proc~grid_to_spec->proc~fourier_dir proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_grid_point_tendencies->proc~grid_to_spec proc~set_forcing set_forcing proc~set_forcing->proc~grid_to_spec proc~vdspec vdspec proc~vdspec->proc~grid_to_spec proc~spectral_truncation spectral_truncation proc~spectral_truncation->proc~grid_to_spec proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_from_rest_state->proc~grid_to_spec proc~initialize initialize proc~initialize->proc~set_forcing proc~initialize_prognostics initialize_prognostics proc~initialize->proc~initialize_prognostics proc~initialize_boundaries initialize_boundaries proc~initialize->proc~initialize_boundaries proc~first_step first_step proc~initialize->proc~first_step proc~get_tendencies get_tendencies proc~get_tendencies->proc~get_grid_point_tendencies program~speedy speedy program~speedy->proc~set_forcing program~speedy->proc~initialize proc~step step program~speedy->proc~step proc~initialize_prognostics->proc~initialize_from_rest_state proc~initialize_boundaries->proc~spectral_truncation proc~step->proc~get_tendencies proc~first_step->proc~step var panprocrfftf1CalledByGraph = svgPanZoom('#procrfftf1CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rfftf1.html"},{"title":"radb2 – SPEEDY.f90","text":"subroutine radb2(ido, l1, cc, ch, wa1) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real, intent(in) :: cc (ido,2,*) real, intent(inout) :: ch (ido,l1,2) real, intent(inout) :: wa1 (*) Contents None","tags":"","loc":"proc/radb2.html"},{"title":"radb3 – SPEEDY.f90","text":"subroutine radb3(ido, l1, cc, ch, wa1, wa2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real, intent(in) :: cc (ido,3,*) real, intent(inout) :: ch (ido,l1,3) real, intent(in) :: wa1 (*) real, intent(in) :: wa2 (*) Contents None","tags":"","loc":"proc/radb3.html"},{"title":"radb4 – SPEEDY.f90","text":"subroutine radb4(ido, l1, cc, ch, wa1, wa2, wa3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real, intent(in) :: cc (ido,4,*) real, intent(inout) :: ch (ido,l1,4) real, intent(in) :: wa1 (*) real, intent(in) :: wa2 (*) real, intent(in) :: wa3 (*) Contents None","tags":"","loc":"proc/radb4.html"},{"title":"radb5 – SPEEDY.f90","text":"subroutine radb5(ido, l1, cc, ch, wa1, wa2, wa3, wa4) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real, intent(in) :: cc (ido,5,*) real, intent(inout) :: ch (ido,l1,5) real, intent(in) :: wa1 (*) real, intent(in) :: wa2 (*) real, intent(in) :: wa3 (*) real, intent(in) :: wa4 (*) Contents None","tags":"","loc":"proc/radb5.html"},{"title":"radbg – SPEEDY.f90","text":"subroutine radbg(ido, ip, l1, idl1, cc, c1, c2, ch, ch2, wa) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: ip integer, intent(in) :: l1 integer, intent(in) :: idl1 real, intent(in) :: cc (ido,ip,*) real, intent(inout) :: c1 (ido,l1,*) real, intent(inout) :: c2 (idl1,*) real, intent(inout) :: ch (ido,l1,*) real, intent(inout) :: ch2 (idl1,*) real, intent(in) :: wa (*) Contents None","tags":"","loc":"proc/radbg.html"},{"title":"radf2 – SPEEDY.f90","text":"subroutine radf2(ido, l1, cc, ch, wa1) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real, intent(in) :: cc (ido,l1,2) real, intent(inout) :: ch (ido,2,*) real, intent(in) :: wa1 (*) Contents None","tags":"","loc":"proc/radf2.html"},{"title":"radf3 – SPEEDY.f90","text":"subroutine radf3(ido, l1, cc, ch, wa1, wa2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real, intent(in) :: cc (ido,l1,3) real, intent(inout) :: ch (ido,3,*) real, intent(in) :: wa1 (*) real, intent(in) :: wa2 (*) Contents None","tags":"","loc":"proc/radf3.html"},{"title":"radf4 – SPEEDY.f90","text":"subroutine radf4(ido, l1, cc, ch, wa1, wa2, wa3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real, intent(in) :: cc (ido,l1,4) real, intent(inout) :: ch (ido,4,*) real, intent(in) :: wa1 (*) real, intent(in) :: wa2 (*) real, intent(in) :: wa3 (*) Contents None","tags":"","loc":"proc/radf4.html"},{"title":"radf5 – SPEEDY.f90","text":"subroutine radf5(ido, l1, cc, ch, wa1, wa2, wa3, wa4) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real, intent(in) :: cc (ido,l1,5) real, intent(inout) :: ch (ido,5,*) real, intent(in) :: wa1 (*) real, intent(in) :: wa2 (*) real, intent(in) :: wa3 (*) real, intent(in) :: wa4 (*) Contents None","tags":"","loc":"proc/radf5.html"},{"title":"radfg – SPEEDY.f90","text":"subroutine radfg(ido, ip, l1, idl1, cc, c1, c2, ch, ch2, wa) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: ip integer, intent(in) :: l1 integer, intent(in) :: idl1 real, intent(inout) :: cc (ido,ip,*) real, intent(inout) :: c1 (ido,l1,*) real, intent(inout) :: c2 (idl1,*) real, intent(inout) :: ch (ido,l1,*) real, intent(inout) :: ch2 (idl1,*) real, intent(in) :: wa (*) Contents None","tags":"","loc":"proc/radfg.html"},{"title":"get_geopotential – SPEEDY.f90","text":"public function get_geopotential(t, phis) result(phi) Uses geometry proc~~get_geopotential~~UsesGraph proc~get_geopotential get_geopotential module~geometry geometry proc~get_geopotential->module~geometry module~params params module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Computes spectral geopotential from spectral temperature T and spectral\n  topography phis, as in GFDL Climate Group GCM. Arguments Type Intent Optional Attributes Name complex, intent(in) :: t (mx,nx,kx) Spectral temperature complex, intent(in) :: phis (mx,nx) Spectral surface geopotential Return Value complex\n  (mx,nx,kx) Spectral geopotential Called by proc~~get_geopotential~~CalledByGraph proc~get_geopotential get_geopotential proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_grid_point_tendencies->proc~get_geopotential proc~get_spectral_tendencies get_spectral_tendencies proc~get_spectral_tendencies->proc~get_geopotential proc~get_tendencies get_tendencies proc~get_tendencies->proc~get_grid_point_tendencies proc~get_tendencies->proc~get_spectral_tendencies proc~step step proc~step->proc~get_tendencies program~speedy speedy program~speedy->proc~step proc~initialize initialize program~speedy->proc~initialize proc~first_step first_step proc~first_step->proc~step proc~initialize->proc~first_step var panprocget_geopotentialCalledByGraph = svgPanZoom('#procget_geopotentialCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_geopotential.html"},{"title":"initialize_geopotential – SPEEDY.f90","text":"public subroutine initialize_geopotential() Uses physical_constants geometry proc~~initialize_geopotential~~UsesGraph proc~initialize_geopotential initialize_geopotential module~physical_constants physical_constants proc~initialize_geopotential->module~physical_constants module~geometry geometry proc~initialize_geopotential->module~geometry module~params params module~physical_constants->module~params module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Initializes the arrays used for geopotential calculations Arguments None Called by proc~~initialize_geopotential~~CalledByGraph proc~initialize_geopotential initialize_geopotential proc~initialize initialize proc~initialize->proc~initialize_geopotential program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize_geopotential.html"},{"title":"forint – SPEEDY.f90","text":"public subroutine forint(imon, for12, for1) Performs linear interpolation of monthly-mean forcing fields. Arguments Type Intent Optional Attributes Name integer, intent(in) :: imon The month real, intent(in) :: for12 (ix*il,*) The input field real, intent(inout) :: for1 (ix*il) The output field Called by proc~~forint~~CalledByGraph proc~forint forint proc~couple_land_atm couple_land_atm proc~couple_land_atm->proc~forint proc~couple_sea_atm couple_sea_atm proc~couple_sea_atm->proc~forint proc~couple_sea_land couple_sea_land proc~couple_sea_land->proc~couple_land_atm proc~couple_sea_land->proc~couple_sea_atm proc~initialize_coupler initialize_coupler proc~initialize_coupler->proc~couple_land_atm proc~initialize_coupler->proc~couple_sea_atm program~speedy speedy program~speedy->proc~couple_sea_land proc~initialize initialize program~speedy->proc~initialize proc~initialize->proc~initialize_coupler Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/forint.html"},{"title":"forin5 – SPEEDY.f90","text":"public subroutine forin5(imon, for12, for1) Performs nonlinear, mean-conserving interpolation of monthly-mean forcing fields. Arguments Type Intent Optional Attributes Name integer, intent(in) :: imon The month real, intent(in) :: for12 (ix*il,12) The input field real, intent(inout) :: for1 (ix*il) The output field Called by proc~~forin5~~CalledByGraph proc~forin5 forin5 proc~couple_land_atm couple_land_atm proc~couple_land_atm->proc~forin5 proc~couple_sea_atm couple_sea_atm proc~couple_sea_atm->proc~forin5 proc~couple_sea_land couple_sea_land proc~couple_sea_land->proc~couple_land_atm proc~couple_sea_land->proc~couple_sea_atm proc~initialize_coupler initialize_coupler proc~initialize_coupler->proc~couple_land_atm proc~initialize_coupler->proc~couple_sea_atm program~speedy speedy program~speedy->proc~couple_sea_land proc~initialize initialize program~speedy->proc~initialize proc~initialize->proc~initialize_coupler Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/forin5.html"},{"title":"load_boundary_file_2d – SPEEDY.f90","text":"private function load_boundary_file_2d(file_name, field_name) result(field) Loads the given 2D field from the given boundary file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name The NetCDF file to read from character(len=*), intent(in) :: field_name The field to read Return Value real,\n  dimension(ix,il) Calls proc~~load_boundary_file_2d~~CallsGraph proc~load_boundary_file_2d load_boundary_file_2d nf90_inq_varid nf90_inq_varid proc~load_boundary_file_2d->nf90_inq_varid nf90_close nf90_close proc~load_boundary_file_2d->nf90_close nf90_open nf90_open proc~load_boundary_file_2d->nf90_open nf90_get_var nf90_get_var proc~load_boundary_file_2d->nf90_get_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~load_boundary_file_2d~~CalledByGraph proc~load_boundary_file_2d load_boundary_file_2d interface~load_boundary_file load_boundary_file interface~load_boundary_file->proc~load_boundary_file_2d proc~sea_model_init sea_model_init proc~sea_model_init->interface~load_boundary_file proc~obs_ssta obs_ssta proc~obs_ssta->interface~load_boundary_file proc~initialize_boundaries initialize_boundaries proc~initialize_boundaries->interface~load_boundary_file proc~land_model_init land_model_init proc~land_model_init->interface~load_boundary_file proc~initialize initialize proc~initialize->proc~initialize_boundaries proc~initialize_coupler initialize_coupler proc~initialize->proc~initialize_coupler proc~initialize_coupler->proc~sea_model_init proc~initialize_coupler->proc~land_model_init program~speedy speedy program~speedy->proc~initialize var panprocload_boundary_file_2dCalledByGraph = svgPanZoom('#procload_boundary_file_2dCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/load_boundary_file_2d.html"},{"title":"load_boundary_file_one_month_from_year – SPEEDY.f90","text":"private function load_boundary_file_one_month_from_year(file_name, field_name, month) result(field) Loads the given 2D field at the given month from the given monthly\n  boundary file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name The NetCDF file to read from character(len=*), intent(in) :: field_name The field to read integer, intent(in) :: month The month to read Return Value real,\n  dimension(ix,il) Calls proc~~load_boundary_file_one_month_from_year~~CallsGraph proc~load_boundary_file_one_month_from_year load_boundary_file_one_month_from_year nf90_inq_varid nf90_inq_varid proc~load_boundary_file_one_month_from_year->nf90_inq_varid nf90_close nf90_close proc~load_boundary_file_one_month_from_year->nf90_close nf90_open nf90_open proc~load_boundary_file_one_month_from_year->nf90_open nf90_get_var nf90_get_var proc~load_boundary_file_one_month_from_year->nf90_get_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~load_boundary_file_one_month_from_year~~CalledByGraph proc~load_boundary_file_one_month_from_year load_boundary_file_one_month_from_year interface~load_boundary_file load_boundary_file interface~load_boundary_file->proc~load_boundary_file_one_month_from_year proc~sea_model_init sea_model_init proc~sea_model_init->interface~load_boundary_file proc~obs_ssta obs_ssta proc~obs_ssta->interface~load_boundary_file proc~initialize_boundaries initialize_boundaries proc~initialize_boundaries->interface~load_boundary_file proc~land_model_init land_model_init proc~land_model_init->interface~load_boundary_file proc~initialize initialize proc~initialize->proc~initialize_boundaries proc~initialize_coupler initialize_coupler proc~initialize->proc~initialize_coupler proc~initialize_coupler->proc~sea_model_init proc~initialize_coupler->proc~land_model_init program~speedy speedy program~speedy->proc~initialize var panprocload_boundary_file_one_month_from_yearCalledByGraph = svgPanZoom('#procload_boundary_file_one_month_from_yearCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/load_boundary_file_one_month_from_year.html"},{"title":"load_boundary_file_one_month_from_long – SPEEDY.f90","text":"private function load_boundary_file_one_month_from_long(file_name, field_name, month, length) result(field) Loads the given 2D field at the given month from the given boundary file\n  of a given length. This is used for reading the SST anomalies from a particular month of a\n  particular year. The SST anomalies are stored in a long multidecadal\n  file and the total number of months in this file must be passed as an\n  argument ( length ). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name The NetCDF file to read from character(len=*), intent(in) :: field_name The field to read integer, intent(in) :: month The month to read integer, intent(in) :: length The total length of the file in number of\n months Return Value real,\n  dimension(ix,il) Calls proc~~load_boundary_file_one_month_from_long~~CallsGraph proc~load_boundary_file_one_month_from_long load_boundary_file_one_month_from_long nf90_inq_varid nf90_inq_varid proc~load_boundary_file_one_month_from_long->nf90_inq_varid nf90_close nf90_close proc~load_boundary_file_one_month_from_long->nf90_close nf90_open nf90_open proc~load_boundary_file_one_month_from_long->nf90_open nf90_get_var nf90_get_var proc~load_boundary_file_one_month_from_long->nf90_get_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~load_boundary_file_one_month_from_long~~CalledByGraph proc~load_boundary_file_one_month_from_long load_boundary_file_one_month_from_long interface~load_boundary_file load_boundary_file interface~load_boundary_file->proc~load_boundary_file_one_month_from_long proc~sea_model_init sea_model_init proc~sea_model_init->interface~load_boundary_file proc~obs_ssta obs_ssta proc~obs_ssta->interface~load_boundary_file proc~initialize_boundaries initialize_boundaries proc~initialize_boundaries->interface~load_boundary_file proc~land_model_init land_model_init proc~land_model_init->interface~load_boundary_file proc~initialize initialize proc~initialize->proc~initialize_boundaries proc~initialize_coupler initialize_coupler proc~initialize->proc~initialize_coupler proc~initialize_coupler->proc~sea_model_init proc~initialize_coupler->proc~land_model_init program~speedy speedy program~speedy->proc~initialize var panprocload_boundary_file_one_month_from_longCalledByGraph = svgPanZoom('#procload_boundary_file_one_month_from_longCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/load_boundary_file_one_month_from_long.html"},{"title":"output – SPEEDY.f90","text":"public subroutine output(timestep, vor, div, t, ps, tr, phi) Uses geometry physical_constants date spectral proc~~output~~UsesGraph proc~output output module~spectral spectral proc~output->module~spectral module~physical_constants physical_constants proc~output->module~physical_constants module~date date proc~output->module~date module~geometry geometry proc~output->module~geometry module~params params module~spectral->module~params module~physical_constants->module~params module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Writes a snapshot of all prognostic variables to a NetCDF file. Arguments Type Intent Optional Attributes Name integer, intent(in) :: timestep The time step that is being written complex, intent(in) :: vor (mx,nx,kx,2) Vorticity complex, intent(in) :: div (mx,nx,kx,2) Divergence complex, intent(in) :: t (mx,nx,kx,2) Temperature complex, intent(in) :: ps (mx,nx,2) log(normalized surface pressure) complex, intent(in) :: tr (mx,nx,kx,2,ntr) Tracers complex, intent(in) :: phi (mx,nx,kx) Geopotential Calls proc~~output~~CallsGraph proc~output output nf90_enddef nf90_enddef proc~output->nf90_enddef nf90_close nf90_close proc~output->nf90_close nf90_def_var nf90_def_var proc~output->nf90_def_var nf90_create nf90_create proc~output->nf90_create nf90_put_att nf90_put_att proc~output->nf90_put_att nf90_def_dim nf90_def_dim proc~output->nf90_def_dim nf90_put_var nf90_put_var proc~output->nf90_put_var proc~spec_to_grid spec_to_grid proc~output->proc~spec_to_grid proc~legendre_inv legendre_inv proc~spec_to_grid->proc~legendre_inv proc~fourier_inv fourier_inv proc~spec_to_grid->proc~fourier_inv proc~rfftb1 rfftb1 proc~fourier_inv->proc~rfftb1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~output~~CalledByGraph proc~output output proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_from_rest_state->proc~output proc~initialize_prognostics initialize_prognostics proc~initialize_prognostics->proc~initialize_from_rest_state proc~initialize initialize proc~initialize->proc~initialize_prognostics program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/output.html"},{"title":"check – SPEEDY.f90","text":"private subroutine check(ierr) Handles any errors from the NetCDF API. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ierr Calls proc~~check~~CallsGraph proc~check check nf90_strerror nf90_strerror proc~check->nf90_strerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check.html"},{"title":"load_boundary_file – SPEEDY.f90","text":"public interface load_boundary_file Interface for reading boundary files. Calls interface~~load_boundary_file~~CallsGraph interface~load_boundary_file load_boundary_file proc~load_boundary_file_one_month_from_long load_boundary_file_one_month_from_long interface~load_boundary_file->proc~load_boundary_file_one_month_from_long proc~load_boundary_file_2d load_boundary_file_2d interface~load_boundary_file->proc~load_boundary_file_2d proc~load_boundary_file_one_month_from_year load_boundary_file_one_month_from_year interface~load_boundary_file->proc~load_boundary_file_one_month_from_year nf90_inq_varid nf90_inq_varid proc~load_boundary_file_one_month_from_long->nf90_inq_varid nf90_close nf90_close proc~load_boundary_file_one_month_from_long->nf90_close nf90_open nf90_open proc~load_boundary_file_one_month_from_long->nf90_open nf90_get_var nf90_get_var proc~load_boundary_file_one_month_from_long->nf90_get_var proc~load_boundary_file_2d->nf90_inq_varid proc~load_boundary_file_2d->nf90_close proc~load_boundary_file_2d->nf90_open proc~load_boundary_file_2d->nf90_get_var proc~load_boundary_file_one_month_from_year->nf90_inq_varid proc~load_boundary_file_one_month_from_year->nf90_close proc~load_boundary_file_one_month_from_year->nf90_open proc~load_boundary_file_one_month_from_year->nf90_get_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~load_boundary_file~~CalledByGraph interface~load_boundary_file load_boundary_file proc~sea_model_init sea_model_init proc~sea_model_init->interface~load_boundary_file proc~obs_ssta obs_ssta proc~obs_ssta->interface~load_boundary_file proc~initialize_boundaries initialize_boundaries proc~initialize_boundaries->interface~load_boundary_file proc~land_model_init land_model_init proc~land_model_init->interface~load_boundary_file proc~initialize initialize proc~initialize->proc~initialize_boundaries proc~initialize_coupler initialize_coupler proc~initialize->proc~initialize_coupler proc~initialize_coupler->proc~sea_model_init proc~initialize_coupler->proc~land_model_init program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures load_boundary_file_2d load_boundary_file_one_month_from_year load_boundary_file_one_month_from_long Module Procedures private function load_boundary_file_2d (file_name, field_name) result(field) Loads the given 2D field from the given boundary file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name The NetCDF file to read from character(len=*), intent(in) :: field_name The field to read Return Value real,\n  dimension(ix,il) private function load_boundary_file_one_month_from_year (file_name, field_name, month) result(field) Loads the given 2D field at the given month from the given monthly\n  boundary file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name The NetCDF file to read from character(len=*), intent(in) :: field_name The field to read integer, intent(in) :: month The month to read Return Value real,\n  dimension(ix,il) private function load_boundary_file_one_month_from_long (file_name, field_name, month, length) result(field) Loads the given 2D field at the given month from the given boundary file\n  of a given length. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name The NetCDF file to read from character(len=*), intent(in) :: field_name The field to read integer, intent(in) :: month The month to read integer, intent(in) :: length The total length of the file in number of\n months Return Value real,\n  dimension(ix,il)","tags":"","loc":"interface/load_boundary_file.html"},{"title":"gen_sppt – SPEEDY.f90","text":"public function gen_sppt() result(sppt_grid) Uses spectral physical_constants proc~~gen_sppt~~UsesGraph proc~gen_sppt gen_sppt module~spectral spectral proc~gen_sppt->module~spectral module~physical_constants physical_constants proc~gen_sppt->module~physical_constants module~params params module~spectral->module~params module~physical_constants->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Generate grid point space SPPT pattern distribution. Arguments None Return Value real\n  (ix,il,kx) The generated grid point pattern Calls proc~~gen_sppt~~CallsGraph proc~gen_sppt gen_sppt proc~randn randn proc~gen_sppt->proc~randn proc~spec_to_grid spec_to_grid proc~gen_sppt->proc~spec_to_grid proc~legendre_inv legendre_inv proc~spec_to_grid->proc~legendre_inv proc~fourier_inv fourier_inv proc~spec_to_grid->proc~fourier_inv proc~rfftb1 rfftb1 proc~fourier_inv->proc~rfftb1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~gen_sppt~~CalledByGraph proc~gen_sppt gen_sppt proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->proc~gen_sppt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gen_sppt.html"},{"title":"randn – SPEEDY.f90","text":"private function randn(mean, stdev) Generates a random number drawn for the specified normal distribution. Arguments Type Intent Optional Attributes Name real, intent(in) :: mean The mean of the distribution to draw from real, intent(in) :: stdev The standard deviation of the distribution to draw from Return Value real The generated random number Called by proc~~randn~~CalledByGraph proc~randn randn proc~gen_sppt gen_sppt proc~gen_sppt->proc~randn proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->proc~gen_sppt Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/randn.html"},{"title":"time_seed – SPEEDY.f90","text":"private subroutine time_seed() Seeds RNG from system clock. Arguments None Contents None","tags":"","loc":"proc/time_seed.html"},{"title":"get_convection_tendencies – SPEEDY.f90","text":"public subroutine get_convection_tendencies(psa, se, qa, qsat, itop, cbmf, precnv, dfse, dfqa) Uses physical_constants geometry proc~~get_convection_tendencies~~UsesGraph proc~get_convection_tendencies get_convection_tendencies module~physical_constants physical_constants proc~get_convection_tendencies->module~physical_constants module~geometry geometry proc~get_convection_tendencies->module~geometry module~params params module~physical_constants->module~params module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute convective fluxes of dry static energy and moisture using a\n  simplified mass-flux scheme Arguments Type Intent Optional Attributes Name real, intent(in) :: psa (ix,il) Normalised surface pressure [p/p0] real, intent(in) :: se (ix,il,kx) Dry static energy [c_p.T + g.z] real, intent(in) :: qa (ix,il,kx) Specific humidity [g/kg] real, intent(in) :: qsat (ix,il,kx) Saturation specific humidity [g/kg] integer, intent(out) :: itop (ix,il) Top of convection (layer index) real, intent(out) :: cbmf (ix,il) Cloud-base mass flux real, intent(out) :: precnv (ix,il) Convective precipitation [g/(m&#94;2 s)] real, intent(out) :: dfse (ix,il,kx) Net flux of dry static energy into each atmospheric\n layer real, intent(out) :: dfqa (ix,il,kx) Net flux of specific humidity into each atmospheric\n layer Calls proc~~get_convection_tendencies~~CallsGraph proc~get_convection_tendencies get_convection_tendencies proc~diagnose_convection diagnose_convection proc~get_convection_tendencies->proc~diagnose_convection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_convection_tendencies~~CalledByGraph proc~get_convection_tendencies get_convection_tendencies proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->proc~get_convection_tendencies Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_convection_tendencies.html"},{"title":"diagnose_convection – SPEEDY.f90","text":"private subroutine diagnose_convection(psa, se, qa, qsat, itop, qdif) Uses physical_constants proc~~diagnose_convection~~UsesGraph proc~diagnose_convection diagnose_convection module~physical_constants physical_constants proc~diagnose_convection->module~physical_constants module~params params module~physical_constants->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Diagnose convectively unstable gridboxes Convection is activated in gridboxes with conditional instability. This\n  is diagnosed by checking for any tropopsheric half level where the\n  saturation moist static energy is lower than in the boundary-layer level.\n  In gridboxes where this is true, convection is activated if either: there\n  is convective instability - the actual moist static energy at the\n  tropospheric level is lower than in the boundary-layer level, or, the\n  relative humidity in the boundary-layer level and lowest tropospheric\n  level exceed a set threshold (rhbl). Arguments Type Intent Optional Attributes Name real, intent(in) :: psa (ix,il) Normalised surface pressure [p/p0] real, intent(in) :: se (ix,il,kx) Dry static energy [c_p.T + g.z] real, intent(in) :: qa (ix,il,kx) Specific humidity [g/kg] real, intent(in) :: qsat (ix,il,kx) Saturation specific humidity [g/kg] integer, intent(out) :: itop (ix,il) Top of convection (layer index) real, intent(out) :: qdif (ix,il) Excess humidity in convective gridboxes Called by proc~~diagnose_convection~~CalledByGraph proc~diagnose_convection diagnose_convection proc~get_convection_tendencies get_convection_tendencies proc~get_convection_tendencies->proc~diagnose_convection proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->proc~get_convection_tendencies Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/diagnose_convection.html"},{"title":"get_large_scale_condensation_tendencies – SPEEDY.f90","text":"public subroutine get_large_scale_condensation_tendencies(psa, qa, qsat, itop, precls, dtlsc, dqlsc) Uses physical_constants geometry proc~~get_large_scale_condensation_tendencies~~UsesGraph proc~get_large_scale_condensation_tendencies get_large_scale_condensation_tendencies module~physical_constants physical_constants proc~get_large_scale_condensation_tendencies->module~physical_constants module~geometry geometry proc~get_large_scale_condensation_tendencies->module~geometry module~params params module~physical_constants->module~params module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute large-scale condensation and associated tendencies of temperature\n  and moisture Arguments Type Intent Optional Attributes Name real, intent(in) :: psa (ix,il) Normalised surface pressure [p/p0] real, intent(in) :: qa (ix,il,kx) Specific humidity [g/kg] real, intent(in) :: qsat (ix,il,kx) Saturation specific humidity [g/kg] integer, intent(inout) :: itop (ix,il) Cloud top diagnosed from precipitation due to\n convection and large-scale condensation real, intent(out) :: precls (ix,il) Precipitation due to large-scale condensation real, intent(out) :: dtlsc (ix,il,kx) Temperature tendency due to large-scale\n condensation real, intent(out) :: dqlsc (ix,il,kx) Specific humidity tendency due to large-scale\n condensation Called by proc~~get_large_scale_condensation_tendencies~~CalledByGraph proc~get_large_scale_condensation_tendencies get_large_scale_condensation_tendencies proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->proc~get_large_scale_condensation_tendencies Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_large_scale_condensation_tendencies.html"},{"title":"get_downward_longwave_rad_fluxes – SPEEDY.f90","text":"public subroutine get_downward_longwave_rad_fluxes(ta, fsfcd, dfabs) Uses physical_constants mod_radcon proc~~get_downward_longwave_rad_fluxes~~UsesGraph proc~get_downward_longwave_rad_fluxes get_downward_longwave_rad_fluxes module~mod_radcon mod_radcon proc~get_downward_longwave_rad_fluxes->module~mod_radcon module~physical_constants physical_constants proc~get_downward_longwave_rad_fluxes->module~physical_constants module~params params module~mod_radcon->module~params module~physical_constants->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute the downward flux of long-wave radiation Arguments Type Intent Optional Attributes Name real, intent(in) :: ta (ix,il,kx) Absolute temperature [K] real, intent(out) :: fsfcd (ix,il) Downward flux of long-wave radiation at the surface real, intent(out) :: dfabs (ix,il,kx) Flux of long-wave radiation absorbed in each\n atmospheric layer Called by proc~~get_downward_longwave_rad_fluxes~~CalledByGraph proc~get_downward_longwave_rad_fluxes get_downward_longwave_rad_fluxes proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->proc~get_downward_longwave_rad_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_downward_longwave_rad_fluxes.html"},{"title":"get_upward_longwave_rad_fluxes – SPEEDY.f90","text":"public subroutine get_upward_longwave_rad_fluxes(ta, ts, fsfcd, fsfcu, fsfc, ftop, dfabs) Uses geometry mod_radcon proc~~get_upward_longwave_rad_fluxes~~UsesGraph proc~get_upward_longwave_rad_fluxes get_upward_longwave_rad_fluxes module~mod_radcon mod_radcon proc~get_upward_longwave_rad_fluxes->module~mod_radcon module~geometry geometry proc~get_upward_longwave_rad_fluxes->module~geometry module~params params module~mod_radcon->module~params module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute the absorption of upward long-wave radiation fluxes Arguments Type Intent Optional Attributes Name real, intent(in) :: ta (ix,il,kx) Absolute temperature real, intent(in) :: ts (ix,il) Surface temperature real, intent(in) :: fsfcd (ix,il) Downward flux of long-wave radiation at the\n surface real, intent(in) :: fsfcu (ix,il) Surface blackbody emission real, intent(out) :: fsfc (ix,il) Net upward flux of long-wave radiation at the\n surface real, intent(out) :: ftop (ix,il) Outgoing flux of long-wave radiation at the\n top of the atmosphere real, intent(inout) :: dfabs (ix,il,kx) Flux of long-wave radiation absorbed in each\n atmospheric layer Contents None","tags":"","loc":"proc/get_upward_longwave_rad_fluxes.html"},{"title":"radset – SPEEDY.f90","text":"public subroutine radset() Uses mod_radcon proc~~radset~~UsesGraph proc~radset radset module~mod_radcon mod_radcon proc~radset->module~mod_radcon module~params params module~mod_radcon->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute energy fractions in longwave bands as a function of temperature Arguments None Called by proc~~radset~~CalledByGraph proc~radset radset proc~set_forcing set_forcing proc~set_forcing->proc~radset program~speedy speedy program~speedy->proc~set_forcing proc~initialize initialize program~speedy->proc~initialize proc~initialize->proc~set_forcing Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/radset.html"},{"title":"set_forcing – SPEEDY.f90","text":"public subroutine set_forcing(imode) Uses dynamical_constants params horizontal_diffusion physical_constants boundaries surface_fluxes date land_model sea_model mod_radcon shortwave_radiation longwave_radiation humidity spectral proc~~set_forcing~~UsesGraph proc~set_forcing set_forcing module~physical_constants physical_constants proc~set_forcing->module~physical_constants module~surface_fluxes surface_fluxes proc~set_forcing->module~surface_fluxes module~date date proc~set_forcing->module~date module~horizontal_diffusion horizontal_diffusion proc~set_forcing->module~horizontal_diffusion module~boundaries boundaries proc~set_forcing->module~boundaries module~shortwave_radiation shortwave_radiation proc~set_forcing->module~shortwave_radiation module~humidity humidity proc~set_forcing->module~humidity module~spectral spectral proc~set_forcing->module~spectral module~dynamical_constants dynamical_constants proc~set_forcing->module~dynamical_constants module~land_model land_model proc~set_forcing->module~land_model module~sea_model sea_model proc~set_forcing->module~sea_model module~params params proc~set_forcing->module~params module~mod_radcon mod_radcon proc~set_forcing->module~mod_radcon module~longwave_radiation longwave_radiation proc~set_forcing->module~longwave_radiation module~physical_constants->module~params module~surface_fluxes->module~params module~horizontal_diffusion->module~params module~boundaries->module~params module~shortwave_radiation->module~params module~humidity->module~params module~spectral->module~params module~land_model->module~params module~sea_model->module~params module~mod_radcon->module~params module~longwave_radiation->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute forcing fields for the current date and correction terms for\n  horizontal diffusion Arguments Type Intent Optional Attributes Name integer, intent(in) :: imode Mode -> 0 = initialization step, 1 = daily update Calls proc~~set_forcing~~CallsGraph proc~set_forcing set_forcing proc~get_qsat get_qsat proc~set_forcing->proc~get_qsat proc~set_orog_land_sfc_drag set_orog_land_sfc_drag proc~set_forcing->proc~set_orog_land_sfc_drag proc~radset radset proc~set_forcing->proc~radset proc~setgam setgam proc~set_forcing->proc~setgam proc~get_zonal_average_fields get_zonal_average_fields proc~set_forcing->proc~get_zonal_average_fields proc~grid_to_spec grid_to_spec proc~set_forcing->proc~grid_to_spec proc~solar solar proc~get_zonal_average_fields->proc~solar proc~legendre_dir legendre_dir proc~grid_to_spec->proc~legendre_dir proc~fourier_dir fourier_dir proc~grid_to_spec->proc~fourier_dir proc~rfftf1 rfftf1 proc~fourier_dir->proc~rfftf1 float float proc~fourier_dir->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~set_forcing~~CalledByGraph proc~set_forcing set_forcing program~speedy speedy program~speedy->proc~set_forcing proc~initialize initialize program~speedy->proc~initialize proc~initialize->proc~set_forcing Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_forcing.html"},{"title":"setgam – SPEEDY.f90","text":"private subroutine setgam(gamlat) Uses dynamical_constants params physical_constants proc~~setgam~~UsesGraph proc~setgam setgam module~dynamical_constants dynamical_constants proc~setgam->module~dynamical_constants module~physical_constants physical_constants proc~setgam->module~physical_constants module~params params proc~setgam->module~params module~physical_constants->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute reference lapse rate as a function of latitude and date Arguments Type Intent Optional Attributes Name real, intent(inout) :: gamlat (il) The reference lapse rate Called by proc~~setgam~~CalledByGraph proc~setgam setgam proc~set_forcing set_forcing proc~set_forcing->proc~setgam program~speedy speedy program~speedy->proc~set_forcing proc~initialize initialize program~speedy->proc~initialize proc~initialize->proc~set_forcing Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setgam.html"},{"title":"initialize_implicit – SPEEDY.f90","text":"public subroutine initialize_implicit(dt) Uses dynamical_constants physical_constants geometry horizontal_diffusion matrix_inversion proc~~initialize_implicit~~UsesGraph proc~initialize_implicit initialize_implicit module~physical_constants physical_constants proc~initialize_implicit->module~physical_constants module~horizontal_diffusion horizontal_diffusion proc~initialize_implicit->module~horizontal_diffusion module~dynamical_constants dynamical_constants proc~initialize_implicit->module~dynamical_constants module~geometry geometry proc~initialize_implicit->module~geometry module~matrix_inversion matrix_inversion proc~initialize_implicit->module~matrix_inversion module~params params module~physical_constants->module~params module~horizontal_diffusion->module~params module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Initialize constants for implicit computation of horizontal diffusion and\n  gravity waves. Initialize_implicit initializes constants for the implicit gravity wave computation.\n  It is assumed that that all implicit steps are of length 2*delt and use\n  the forward/backward parameter alph. initialize_implicit has to be re-called\n  whenever either of these two parameters is changed. initialize_implicit should\n  be called even if the explicit option is chosen for the gravity wave\n  terms (the reference state temperature tref is subtracted from some\n  terms anyway to reduce roundoff error; also the constants needed for\n  the biharmonic diffusion, which is assumed always to be backwards\n  implicit, are defined in initialize_implicit). Arguments Type Intent Optional Attributes Name real, intent(in) :: dt Time step Calls proc~~initialize_implicit~~CallsGraph proc~initialize_implicit initialize_implicit float float proc~initialize_implicit->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initialize_implicit~~CalledByGraph proc~initialize_implicit initialize_implicit proc~first_step first_step proc~first_step->proc~initialize_implicit proc~initialize initialize proc~initialize->proc~first_step program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize_implicit.html"},{"title":"implicit_terms – SPEEDY.f90","text":"public subroutine implicit_terms(divdt, tdt, psdt) Correct tendencies for implicit gravity wave model Arguments Type Intent Optional Attributes Name complex, intent(inout) :: divdt (mx,nx,kx) Divergence tendency complex, intent(inout) :: tdt (mx,nx,kx) Temperature tendency complex, intent(inout) :: psdt (mx,nx) log(surface pressure) tendency Called by proc~~implicit_terms~~CalledByGraph proc~implicit_terms implicit_terms proc~get_tendencies get_tendencies proc~get_tendencies->proc~implicit_terms proc~step step proc~step->proc~get_tendencies program~speedy speedy program~speedy->proc~step proc~initialize initialize program~speedy->proc~initialize proc~first_step first_step proc~first_step->proc~step proc~initialize->proc~first_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/implicit_terms.html"},{"title":"initialize_boundaries – SPEEDY.f90","text":"public subroutine initialize_boundaries() Uses physical_constants input_output proc~~initialize_boundaries~~UsesGraph proc~initialize_boundaries initialize_boundaries module~input_output input_output proc~initialize_boundaries->module~input_output module~physical_constants physical_constants proc~initialize_boundaries->module~physical_constants module~params params module~input_output->module~params netcdf netcdf module~input_output->netcdf module~physical_constants->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Initialize boundary conditions (land-sea mask, surface geopotential\n  and surface albedo). Arguments None Calls proc~~initialize_boundaries~~CallsGraph proc~initialize_boundaries initialize_boundaries interface~load_boundary_file load_boundary_file proc~initialize_boundaries->interface~load_boundary_file proc~spectral_truncation spectral_truncation proc~initialize_boundaries->proc~spectral_truncation proc~load_boundary_file_one_month_from_long load_boundary_file_one_month_from_long interface~load_boundary_file->proc~load_boundary_file_one_month_from_long proc~load_boundary_file_2d load_boundary_file_2d interface~load_boundary_file->proc~load_boundary_file_2d proc~load_boundary_file_one_month_from_year load_boundary_file_one_month_from_year interface~load_boundary_file->proc~load_boundary_file_one_month_from_year proc~grid_to_spec grid_to_spec proc~spectral_truncation->proc~grid_to_spec proc~spec_to_grid spec_to_grid proc~spectral_truncation->proc~spec_to_grid nf90_inq_varid nf90_inq_varid proc~load_boundary_file_one_month_from_long->nf90_inq_varid nf90_close nf90_close proc~load_boundary_file_one_month_from_long->nf90_close nf90_open nf90_open proc~load_boundary_file_one_month_from_long->nf90_open nf90_get_var nf90_get_var proc~load_boundary_file_one_month_from_long->nf90_get_var proc~load_boundary_file_2d->nf90_inq_varid proc~load_boundary_file_2d->nf90_close proc~load_boundary_file_2d->nf90_open proc~load_boundary_file_2d->nf90_get_var proc~load_boundary_file_one_month_from_year->nf90_inq_varid proc~load_boundary_file_one_month_from_year->nf90_close proc~load_boundary_file_one_month_from_year->nf90_open proc~load_boundary_file_one_month_from_year->nf90_get_var proc~legendre_dir legendre_dir proc~grid_to_spec->proc~legendre_dir proc~fourier_dir fourier_dir proc~grid_to_spec->proc~fourier_dir proc~legendre_inv legendre_inv proc~spec_to_grid->proc~legendre_inv proc~fourier_inv fourier_inv proc~spec_to_grid->proc~fourier_inv proc~rfftf1 rfftf1 proc~fourier_dir->proc~rfftf1 float float proc~fourier_dir->float proc~rfftb1 rfftb1 proc~fourier_inv->proc~rfftb1 var panprocinitialize_boundariesCallsGraph = svgPanZoom('#procinitialize_boundariesCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initialize_boundaries~~CalledByGraph proc~initialize_boundaries initialize_boundaries proc~initialize initialize proc~initialize->proc~initialize_boundaries program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize_boundaries.html"},{"title":"forchk – SPEEDY.f90","text":"public subroutine forchk(fmask, nf, fmin, fmax, fset, field) Check consistency of surface fields with land-sea mask and set undefined\n  values to a constant (to avoid over/underflow). Arguments Type Intent Optional Attributes Name real, intent(in) :: fmask (ix,il) The fractional land-sea mask integer, intent(in) :: nf The number of input 2D fields real, intent(in) :: fmin The minimum allowable value real, intent(in) :: fmax The maximum allowable value real, intent(in) :: fset Replacement for undefined values real, intent(inout) :: field (ix,il,nf) The output field Called by proc~~forchk~~CalledByGraph proc~forchk forchk proc~sea_model_init sea_model_init proc~sea_model_init->proc~forchk proc~land_model_init land_model_init proc~land_model_init->proc~forchk proc~initialize_coupler initialize_coupler proc~initialize_coupler->proc~sea_model_init proc~initialize_coupler->proc~land_model_init proc~initialize initialize proc~initialize->proc~initialize_coupler program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/forchk.html"},{"title":"spectral_truncation – SPEEDY.f90","text":"private subroutine spectral_truncation(fg1, fg2) Uses spectral proc~~spectral_truncation~~UsesGraph proc~spectral_truncation spectral_truncation module~spectral spectral proc~spectral_truncation->module~spectral module~params params module~spectral->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute a spectrally-filtered grid-point field. Arguments Type Intent Optional Attributes Name real, intent(inout) :: fg1 (ix,il) Original grid-point field real, intent(inout) :: fg2 (ix,il) Filtered grid-point field Calls proc~~spectral_truncation~~CallsGraph proc~spectral_truncation spectral_truncation proc~grid_to_spec grid_to_spec proc~spectral_truncation->proc~grid_to_spec proc~spec_to_grid spec_to_grid proc~spectral_truncation->proc~spec_to_grid proc~legendre_dir legendre_dir proc~grid_to_spec->proc~legendre_dir proc~fourier_dir fourier_dir proc~grid_to_spec->proc~fourier_dir proc~fourier_inv fourier_inv proc~spec_to_grid->proc~fourier_inv proc~legendre_inv legendre_inv proc~spec_to_grid->proc~legendre_inv proc~rfftb1 rfftb1 proc~fourier_inv->proc~rfftb1 proc~rfftf1 rfftf1 proc~fourier_dir->proc~rfftf1 float float proc~fourier_dir->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~spectral_truncation~~CalledByGraph proc~spectral_truncation spectral_truncation proc~initialize_boundaries initialize_boundaries proc~initialize_boundaries->proc~spectral_truncation proc~initialize initialize proc~initialize->proc~initialize_boundaries program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/spectral_truncation.html"},{"title":"fillsf – SPEEDY.f90","text":"public subroutine fillsf(sf, fmis) Replace missing values in surface fields. Note It is assumed that non-missing values exist near the Equator. Arguments Type Intent Optional Attributes Name real, intent(inout) :: sf (ix,il) Field to replace missing values in real, intent(in) :: fmis Replacement for missing values Calls proc~~fillsf~~CallsGraph proc~fillsf fillsf float float proc~fillsf->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fillsf.html"},{"title":"initialize_coupler – SPEEDY.f90","text":"public subroutine initialize_coupler() Uses land_model sea_model proc~~initialize_coupler~~UsesGraph proc~initialize_coupler initialize_coupler module~land_model land_model proc~initialize_coupler->module~land_model module~sea_model sea_model proc~initialize_coupler->module~sea_model module~params params module~land_model->module~params module~sea_model->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Initialize both land and sea models. Arguments None Calls proc~~initialize_coupler~~CallsGraph proc~initialize_coupler initialize_coupler proc~sea_model_init sea_model_init proc~initialize_coupler->proc~sea_model_init proc~couple_sea_atm couple_sea_atm proc~initialize_coupler->proc~couple_sea_atm proc~couple_land_atm couple_land_atm proc~initialize_coupler->proc~couple_land_atm proc~land_model_init land_model_init proc~initialize_coupler->proc~land_model_init proc~forchk forchk proc~sea_model_init->proc~forchk interface~load_boundary_file load_boundary_file proc~sea_model_init->interface~load_boundary_file proc~forint forint proc~couple_sea_atm->proc~forint proc~forin5 forin5 proc~couple_sea_atm->proc~forin5 proc~run_sea_model run_sea_model proc~couple_sea_atm->proc~run_sea_model proc~run_land_model run_land_model proc~couple_land_atm->proc~run_land_model proc~couple_land_atm->proc~forint proc~couple_land_atm->proc~forin5 proc~land_model_init->proc~forchk proc~land_model_init->interface~load_boundary_file proc~load_boundary_file_one_month_from_long load_boundary_file_one_month_from_long interface~load_boundary_file->proc~load_boundary_file_one_month_from_long proc~load_boundary_file_2d load_boundary_file_2d interface~load_boundary_file->proc~load_boundary_file_2d proc~load_boundary_file_one_month_from_year load_boundary_file_one_month_from_year interface~load_boundary_file->proc~load_boundary_file_one_month_from_year nf90_inq_varid nf90_inq_varid proc~load_boundary_file_one_month_from_long->nf90_inq_varid nf90_close nf90_close proc~load_boundary_file_one_month_from_long->nf90_close nf90_open nf90_open proc~load_boundary_file_one_month_from_long->nf90_open nf90_get_var nf90_get_var proc~load_boundary_file_one_month_from_long->nf90_get_var proc~load_boundary_file_2d->nf90_inq_varid proc~load_boundary_file_2d->nf90_close proc~load_boundary_file_2d->nf90_open proc~load_boundary_file_2d->nf90_get_var proc~load_boundary_file_one_month_from_year->nf90_inq_varid proc~load_boundary_file_one_month_from_year->nf90_close proc~load_boundary_file_one_month_from_year->nf90_open proc~load_boundary_file_one_month_from_year->nf90_get_var var panprocinitialize_couplerCallsGraph = svgPanZoom('#procinitialize_couplerCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initialize_coupler~~CalledByGraph proc~initialize_coupler initialize_coupler proc~initialize initialize proc~initialize->proc~initialize_coupler program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize_coupler.html"},{"title":"couple_sea_land – SPEEDY.f90","text":"public subroutine couple_sea_land(day) Uses land_model sea_model proc~~couple_sea_land~~UsesGraph proc~couple_sea_land couple_sea_land module~land_model land_model proc~couple_sea_land->module~land_model module~sea_model sea_model proc~couple_sea_land->module~sea_model module~params params module~land_model->module~params module~sea_model->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Exchange fluxes between atmosphere and land/sea. Arguments Type Intent Optional Attributes Name integer, intent(in) :: day The current day of the model integration (starting from 0) Calls proc~~couple_sea_land~~CallsGraph proc~couple_sea_land couple_sea_land proc~couple_land_atm couple_land_atm proc~couple_sea_land->proc~couple_land_atm proc~couple_sea_atm couple_sea_atm proc~couple_sea_land->proc~couple_sea_atm proc~run_land_model run_land_model proc~couple_land_atm->proc~run_land_model proc~forin5 forin5 proc~couple_land_atm->proc~forin5 proc~forint forint proc~couple_land_atm->proc~forint proc~run_sea_model run_sea_model proc~couple_sea_atm->proc~run_sea_model proc~couple_sea_atm->proc~forin5 proc~couple_sea_atm->proc~forint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~couple_sea_land~~CalledByGraph proc~couple_sea_land couple_sea_land program~speedy speedy program~speedy->proc~couple_sea_land Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/couple_sea_land.html"},{"title":"check_diagnostics – SPEEDY.f90","text":"public subroutine check_diagnostics(vor, div, t, istep) Uses params spectral proc~~check_diagnostics~~UsesGraph proc~check_diagnostics check_diagnostics module~params params proc~check_diagnostics->module~params module~spectral spectral proc~check_diagnostics->module~spectral module~spectral->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Prints global means of eddy kinetic energy and temperature.\n  Also stops the integration if the computed diagnostics are outside of\n  allowable ranges. Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(mx,nx,kx) :: vor Spectral vorticity complex, intent(in), dimension(mx,nx,kx) :: div Spectral divergence complex, intent(in), dimension(mx,nx,kx) :: t Spectral temperature integer, intent(in) :: istep Current time step Calls proc~~check_diagnostics~~CallsGraph proc~check_diagnostics check_diagnostics proc~inverse_laplacian inverse_laplacian proc~check_diagnostics->proc~inverse_laplacian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check_diagnostics.html"},{"title":"initialize_prognostics – SPEEDY.f90","text":"public subroutine initialize_prognostics() Arguments None Calls proc~~initialize_prognostics~~CallsGraph proc~initialize_prognostics initialize_prognostics proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_prognostics->proc~initialize_from_rest_state proc~output output proc~initialize_from_rest_state->proc~output proc~grid_to_spec grid_to_spec proc~initialize_from_rest_state->proc~grid_to_spec nf90_enddef nf90_enddef proc~output->nf90_enddef nf90_close nf90_close proc~output->nf90_close nf90_def_var nf90_def_var proc~output->nf90_def_var nf90_create nf90_create proc~output->nf90_create nf90_put_att nf90_put_att proc~output->nf90_put_att nf90_def_dim nf90_def_dim proc~output->nf90_def_dim nf90_put_var nf90_put_var proc~output->nf90_put_var proc~spec_to_grid spec_to_grid proc~output->proc~spec_to_grid proc~legendre_dir legendre_dir proc~grid_to_spec->proc~legendre_dir proc~fourier_dir fourier_dir proc~grid_to_spec->proc~fourier_dir proc~rfftf1 rfftf1 proc~fourier_dir->proc~rfftf1 float float proc~fourier_dir->float proc~legendre_inv legendre_inv proc~spec_to_grid->proc~legendre_inv proc~fourier_inv fourier_inv proc~spec_to_grid->proc~fourier_inv proc~rfftb1 rfftb1 proc~fourier_inv->proc~rfftb1 var panprocinitialize_prognosticsCallsGraph = svgPanZoom('#procinitialize_prognosticsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initialize_prognostics~~CalledByGraph proc~initialize_prognostics initialize_prognostics proc~initialize initialize proc~initialize->proc~initialize_prognostics program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize_prognostics.html"},{"title":"initialize_from_rest_state – SPEEDY.f90","text":"private subroutine initialize_from_rest_state() Uses dynamical_constants physical_constants geometry boundaries diagnostics spectral input_output proc~~initialize_from_rest_state~~UsesGraph proc~initialize_from_rest_state initialize_from_rest_state module~diagnostics diagnostics proc~initialize_from_rest_state->module~diagnostics module~physical_constants physical_constants proc~initialize_from_rest_state->module~physical_constants module~boundaries boundaries proc~initialize_from_rest_state->module~boundaries module~spectral spectral proc~initialize_from_rest_state->module~spectral module~dynamical_constants dynamical_constants proc~initialize_from_rest_state->module~dynamical_constants module~input_output input_output proc~initialize_from_rest_state->module~input_output module~geometry geometry proc~initialize_from_rest_state->module~geometry module~params params module~physical_constants->module~params module~boundaries->module~params module~spectral->module~params module~input_output->module~params netcdf netcdf module~input_output->netcdf module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~initialize_from_rest_state~~CallsGraph proc~initialize_from_rest_state initialize_from_rest_state proc~output output proc~initialize_from_rest_state->proc~output proc~grid_to_spec grid_to_spec proc~initialize_from_rest_state->proc~grid_to_spec nf90_enddef nf90_enddef proc~output->nf90_enddef nf90_close nf90_close proc~output->nf90_close nf90_def_var nf90_def_var proc~output->nf90_def_var nf90_create nf90_create proc~output->nf90_create nf90_put_att nf90_put_att proc~output->nf90_put_att nf90_def_dim nf90_def_dim proc~output->nf90_def_dim nf90_put_var nf90_put_var proc~output->nf90_put_var proc~spec_to_grid spec_to_grid proc~output->proc~spec_to_grid proc~legendre_dir legendre_dir proc~grid_to_spec->proc~legendre_dir proc~fourier_dir fourier_dir proc~grid_to_spec->proc~fourier_dir proc~rfftf1 rfftf1 proc~fourier_dir->proc~rfftf1 float float proc~fourier_dir->float proc~legendre_inv legendre_inv proc~spec_to_grid->proc~legendre_inv proc~fourier_inv fourier_inv proc~spec_to_grid->proc~fourier_inv proc~rfftb1 rfftb1 proc~fourier_inv->proc~rfftb1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initialize_from_rest_state~~CalledByGraph proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_prognostics initialize_prognostics proc~initialize_prognostics->proc~initialize_from_rest_state proc~initialize initialize proc~initialize->proc~initialize_prognostics program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize_from_rest_state.html"},{"title":"initialize_params – SPEEDY.f90","text":"public subroutine initialize_params() Initializes user-defined parameters from namelist file. Arguments None Called by proc~~initialize_params~~CalledByGraph proc~initialize_params initialize_params proc~initialize initialize proc~initialize->proc~initialize_params program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize_params.html"},{"title":"laplacian – SPEEDY.f90","text":"public function laplacian(input) result(output) Arguments Type Intent Optional Attributes Name complex, intent(in) :: input (mx,nx) Return Value complex\n  (mx,nx) Called by proc~~laplacian~~CalledByGraph proc~laplacian laplacian proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_grid_point_tendencies->proc~laplacian proc~get_spectral_tendencies get_spectral_tendencies proc~get_spectral_tendencies->proc~laplacian proc~get_tendencies get_tendencies proc~get_tendencies->proc~get_grid_point_tendencies proc~get_tendencies->proc~get_spectral_tendencies proc~step step proc~step->proc~get_tendencies program~speedy speedy program~speedy->proc~step proc~initialize initialize program~speedy->proc~initialize proc~first_step first_step proc~first_step->proc~step proc~initialize->proc~first_step var panproclaplacianCalledByGraph = svgPanZoom('#proclaplacianCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/laplacian.html"},{"title":"inverse_laplacian – SPEEDY.f90","text":"public function inverse_laplacian(input) result(output) Arguments Type Intent Optional Attributes Name complex, intent(in) :: input (mx,nx) Return Value complex\n  (mx,nx) Called by proc~~inverse_laplacian~~CalledByGraph proc~inverse_laplacian inverse_laplacian proc~check_diagnostics check_diagnostics proc~check_diagnostics->proc~inverse_laplacian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/inverse_laplacian.html"},{"title":"spec_to_grid – SPEEDY.f90","text":"public function spec_to_grid(vorm, kcos) result(vorg) Uses legendre fourier proc~~spec_to_grid~~UsesGraph proc~spec_to_grid spec_to_grid module~legendre legendre proc~spec_to_grid->module~legendre module~fourier fourier proc~spec_to_grid->module~fourier module~params params module~legendre->module~params module~fourier->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name complex, intent(in) :: vorm (mx,nx) integer, intent(in) :: kcos Return Value real\n  (ix,il) Calls proc~~spec_to_grid~~CallsGraph proc~spec_to_grid spec_to_grid proc~legendre_inv legendre_inv proc~spec_to_grid->proc~legendre_inv proc~fourier_inv fourier_inv proc~spec_to_grid->proc~fourier_inv proc~rfftb1 rfftb1 proc~fourier_inv->proc~rfftb1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~spec_to_grid~~CalledByGraph proc~spec_to_grid spec_to_grid proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_grid_point_tendencies->proc~spec_to_grid proc~gen_sppt gen_sppt proc~gen_sppt->proc~spec_to_grid proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->proc~spec_to_grid proc~get_physical_tendencies->proc~gen_sppt proc~spectral_truncation spectral_truncation proc~spectral_truncation->proc~spec_to_grid proc~output output proc~output->proc~spec_to_grid proc~initialize_boundaries initialize_boundaries proc~initialize_boundaries->proc~spectral_truncation proc~get_tendencies get_tendencies proc~get_tendencies->proc~get_grid_point_tendencies proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_from_rest_state->proc~output proc~initialize_prognostics initialize_prognostics proc~initialize_prognostics->proc~initialize_from_rest_state proc~initialize initialize proc~initialize->proc~initialize_boundaries proc~initialize->proc~initialize_prognostics proc~first_step first_step proc~initialize->proc~first_step proc~step step proc~step->proc~get_tendencies program~speedy speedy program~speedy->proc~initialize program~speedy->proc~step proc~first_step->proc~step var panprocspec_to_gridCalledByGraph = svgPanZoom('#procspec_to_gridCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/spec_to_grid.html"},{"title":"grid_to_spec – SPEEDY.f90","text":"public function grid_to_spec(vorg) result(vorm) Uses legendre fourier proc~~grid_to_spec~~UsesGraph proc~grid_to_spec grid_to_spec module~legendre legendre proc~grid_to_spec->module~legendre module~fourier fourier proc~grid_to_spec->module~fourier module~params params module~legendre->module~params module~fourier->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real, intent(in) :: vorg (ix,il) Return Value complex\n  (mx,nx) Calls proc~~grid_to_spec~~CallsGraph proc~grid_to_spec grid_to_spec proc~legendre_dir legendre_dir proc~grid_to_spec->proc~legendre_dir proc~fourier_dir fourier_dir proc~grid_to_spec->proc~fourier_dir proc~rfftf1 rfftf1 proc~fourier_dir->proc~rfftf1 float float proc~fourier_dir->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~grid_to_spec~~CalledByGraph proc~grid_to_spec grid_to_spec proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_grid_point_tendencies->proc~grid_to_spec proc~set_forcing set_forcing proc~set_forcing->proc~grid_to_spec proc~vdspec vdspec proc~vdspec->proc~grid_to_spec proc~spectral_truncation spectral_truncation proc~spectral_truncation->proc~grid_to_spec proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_from_rest_state->proc~grid_to_spec proc~initialize initialize proc~initialize->proc~set_forcing proc~initialize_prognostics initialize_prognostics proc~initialize->proc~initialize_prognostics proc~initialize_boundaries initialize_boundaries proc~initialize->proc~initialize_boundaries proc~first_step first_step proc~initialize->proc~first_step proc~get_tendencies get_tendencies proc~get_tendencies->proc~get_grid_point_tendencies program~speedy speedy program~speedy->proc~set_forcing program~speedy->proc~initialize proc~step step program~speedy->proc~step proc~initialize_prognostics->proc~initialize_from_rest_state proc~initialize_boundaries->proc~spectral_truncation proc~step->proc~get_tendencies proc~first_step->proc~step var panprocgrid_to_specCalledByGraph = svgPanZoom('#procgrid_to_specCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/grid_to_spec.html"},{"title":"initialize_spectral – SPEEDY.f90","text":"public subroutine initialize_spectral() Uses physical_constants fourier legendre proc~~initialize_spectral~~UsesGraph proc~initialize_spectral initialize_spectral module~legendre legendre proc~initialize_spectral->module~legendre module~physical_constants physical_constants proc~initialize_spectral->module~physical_constants module~fourier fourier proc~initialize_spectral->module~fourier module~params params module~legendre->module~params module~physical_constants->module~params module~fourier->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~initialize_spectral~~CallsGraph proc~initialize_spectral initialize_spectral proc~initialize_fourier initialize_fourier proc~initialize_spectral->proc~initialize_fourier proc~initialize_legendre initialize_legendre proc~initialize_spectral->proc~initialize_legendre float float proc~initialize_spectral->float proc~rffti1 rffti1 proc~initialize_fourier->proc~rffti1 proc~initialize_legendre->float proc~get_legendre_poly get_legendre_poly proc~initialize_legendre->proc~get_legendre_poly proc~get_weights get_weights proc~initialize_legendre->proc~get_weights proc~get_legendre_poly->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initialize_spectral~~CalledByGraph proc~initialize_spectral initialize_spectral proc~initialize initialize proc~initialize->proc~initialize_spectral program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize_spectral.html"},{"title":"grad – SPEEDY.f90","text":"public subroutine grad(psi, psdx, psdy) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(mx,nx) :: psi complex, intent(inout), dimension(mx,nx) :: psdx complex, intent(inout), dimension(mx,nx) :: psdy Contents None","tags":"","loc":"proc/grad.html"},{"title":"vds – SPEEDY.f90","text":"public subroutine vds(ucosm, vcosm, vorm, divm) Arguments Type Intent Optional Attributes Name complex, dimension(mx,nx) :: ucosm complex, dimension(mx,nx) :: vcosm complex, intent(inout), dimension(mx,nx) :: vorm complex, intent(inout), dimension(mx,nx) :: divm Called by proc~~vds~~CalledByGraph proc~vds vds proc~vdspec vdspec proc~vdspec->proc~vds Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/vds.html"},{"title":"uvspec – SPEEDY.f90","text":"public subroutine uvspec(vorm, divm, ucosm, vcosm) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(mx,nx) :: vorm complex, intent(in), dimension(mx,nx) :: divm complex, intent(inout), dimension(mx,nx) :: ucosm complex, intent(inout), dimension(mx,nx) :: vcosm Contents None","tags":"","loc":"proc/uvspec.html"},{"title":"vdspec – SPEEDY.f90","text":"public subroutine vdspec(ug, vg, vorm, divm, kcos) Uses geometry proc~~vdspec~~UsesGraph proc~vdspec vdspec module~geometry geometry proc~vdspec->module~geometry module~params params module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real, intent(in) :: ug (ix,il) real, intent(in) :: vg (ix,il) complex, intent(out) :: vorm (mx,nx) complex, intent(out) :: divm (mx,nx) integer, intent(in) :: kcos Calls proc~~vdspec~~CallsGraph proc~vdspec vdspec proc~grid_to_spec grid_to_spec proc~vdspec->proc~grid_to_spec proc~vds vds proc~vdspec->proc~vds proc~legendre_dir legendre_dir proc~grid_to_spec->proc~legendre_dir proc~fourier_dir fourier_dir proc~grid_to_spec->proc~fourier_dir proc~rfftf1 rfftf1 proc~fourier_dir->proc~rfftf1 float float proc~fourier_dir->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/vdspec.html"},{"title":"trunct – SPEEDY.f90","text":"public subroutine trunct(vor) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: vor (mx,nx) Called by proc~~trunct~~CalledByGraph proc~trunct trunct proc~step_field_2d step_field_2d proc~step_field_2d->proc~trunct proc~step step proc~step->proc~step_field_2d proc~step_field_3d step_field_3d proc~step->proc~step_field_3d proc~step_field_3d->proc~step_field_2d program~speedy speedy program~speedy->proc~step proc~initialize initialize program~speedy->proc~initialize proc~first_step first_step proc~first_step->proc~step proc~initialize->proc~first_step var panproctrunctCalledByGraph = svgPanZoom('#proctrunctCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/trunct.html"},{"title":"get_qsat – SPEEDY.f90","text":"public function get_qsat(ta, ps, sig) result(qsat) Computes saturation specific humidity. Arguments Type Intent Optional Attributes Name real, intent(in) :: ta (ix,il) Absolute temperature real, intent(in) :: ps (ix,il) Normalized pressure (p/1000 hPa) real, intent(in) :: sig Sigma level Return Value real\n  (ix,il) Saturation specific humidity in g/kg Called by proc~~get_qsat~~CalledByGraph proc~get_qsat get_qsat proc~rel_hum_to_spec_hum rel_hum_to_spec_hum proc~rel_hum_to_spec_hum->proc~get_qsat proc~set_forcing set_forcing proc~set_forcing->proc~get_qsat proc~get_surface_fluxes get_surface_fluxes proc~get_surface_fluxes->proc~get_qsat proc~spec_hum_to_rel_hum spec_hum_to_rel_hum proc~spec_hum_to_rel_hum->proc~get_qsat program~speedy speedy program~speedy->proc~set_forcing proc~initialize initialize program~speedy->proc~initialize proc~initialize->proc~set_forcing proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->proc~get_surface_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_qsat.html"},{"title":"spec_hum_to_rel_hum – SPEEDY.f90","text":"public subroutine spec_hum_to_rel_hum(ta, ps, sig, qa, rh, qsat) Converts specific humidity to relative humidity, and also returns\n  saturation specific humidity. Arguments Type Intent Optional Attributes Name real, intent(in) :: ta (ix,il) Absolute temperature real, intent(in) :: ps (ix,il) Normalized pressure (p/1000 hPa) real, intent(in) :: sig Sigma level real, intent(in) :: qa (ix,il) Specific humidity real, intent(inout) :: rh (ix,il) Relative humidity real, intent(inout) :: qsat (ix,il) Saturation specific humidity Calls proc~~spec_hum_to_rel_hum~~CallsGraph proc~spec_hum_to_rel_hum spec_hum_to_rel_hum proc~get_qsat get_qsat proc~spec_hum_to_rel_hum->proc~get_qsat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/spec_hum_to_rel_hum.html"},{"title":"rel_hum_to_spec_hum – SPEEDY.f90","text":"public subroutine rel_hum_to_spec_hum(ta, ps, sig, rh, qa, qsat) Converts relative humidity to specific humidity, and also returns\n  saturation specific humidity. Arguments Type Intent Optional Attributes Name real, intent(in) :: ta (ix,il) Absolute temperature real, intent(in) :: ps (ix,il) Normalized pressure (p/1000 hPa) real, intent(in) :: sig Sigma level real, intent(in) :: rh (ix,il) Relative humidity real, intent(inout) :: qa (ix,il) Specific humidity real, intent(inout) :: qsat (ix,il) Saturation specific humidity Calls proc~~rel_hum_to_spec_hum~~CallsGraph proc~rel_hum_to_spec_hum rel_hum_to_spec_hum proc~get_qsat get_qsat proc~rel_hum_to_spec_hum->proc~get_qsat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rel_hum_to_spec_hum.html"},{"title":"get_vertical_diffusion_tend – SPEEDY.f90","text":"public subroutine get_vertical_diffusion_tend(se, rh, qa, qsat, phi, icnv, utenvd, vtenvd, ttenvd, qtenvd) Uses physical_constants geometry proc~~get_vertical_diffusion_tend~~UsesGraph proc~get_vertical_diffusion_tend get_vertical_diffusion_tend module~physical_constants physical_constants proc~get_vertical_diffusion_tend->module~physical_constants module~geometry geometry proc~get_vertical_diffusion_tend->module~geometry module~params params module~physical_constants->module~params module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute tendencies of momentum, energy and moisture due to vertical diffusion\n  and shallow convection Arguments Type Intent Optional Attributes Name real, intent(in) :: se (ix,il,kx) Dry static energy real, intent(in) :: rh (ix,il,kx) Relative humidity real, intent(in) :: qa (ix,il,kx) Specific humidity [g/kg] real, intent(in) :: qsat (ix,il,kx) Saturated specific humidity [g/kg] real, intent(in) :: phi (ix,il,kx) Geopotential integer, intent(in) :: icnv (ix,il) Sigma-level index of deep convection real, intent(out) :: utenvd (ix,il,kx) u-wind tendency real, intent(out) :: vtenvd (ix,il,kx) v-wind tendency real, intent(out) :: ttenvd (ix,il,kx) Temperature tendency real, intent(out) :: qtenvd (ix,il,kx) Specific humidity tendency Called by proc~~get_vertical_diffusion_tend~~CalledByGraph proc~get_vertical_diffusion_tend get_vertical_diffusion_tend proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->proc~get_vertical_diffusion_tend Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_vertical_diffusion_tend.html"},{"title":"do_horizontal_diffusion_2d – SPEEDY.f90","text":"private function do_horizontal_diffusion_2d(field, fdt_in, dmp, dmp1) result(fdt_out) Adds horizontal diffusion tendency of field to spectral tendency fdt\n  using damping coefficients dmp and dmp1. Arguments Type Intent Optional Attributes Name complex, intent(in) :: field (mx,nx) complex, intent(in) :: fdt_in (mx,nx) real, intent(in) :: dmp (mx,nx) real, intent(in) :: dmp1 (mx,nx) Return Value complex\n  (mx,nx) Called by proc~~do_horizontal_diffusion_2d~~CalledByGraph proc~do_horizontal_diffusion_2d do_horizontal_diffusion_2d proc~do_horizontal_diffusion_3d do_horizontal_diffusion_3d proc~do_horizontal_diffusion_3d->proc~do_horizontal_diffusion_2d interface~do_horizontal_diffusion do_horizontal_diffusion interface~do_horizontal_diffusion->proc~do_horizontal_diffusion_2d interface~do_horizontal_diffusion->proc~do_horizontal_diffusion_3d proc~step step proc~step->interface~do_horizontal_diffusion program~speedy speedy program~speedy->proc~step proc~initialize initialize program~speedy->proc~initialize proc~first_step first_step proc~first_step->proc~step proc~initialize->proc~first_step var panprocdo_horizontal_diffusion_2dCalledByGraph = svgPanZoom('#procdo_horizontal_diffusion_2dCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/do_horizontal_diffusion_2d.html"},{"title":"do_horizontal_diffusion_3d – SPEEDY.f90","text":"private function do_horizontal_diffusion_3d(field, fdt_in, dmp, dmp1) result(fdt_out) Adds horizontal diffusion tendency of field to spectral tendency fdt\n  at all model levels using damping coefficients dmp and dmp1. Arguments Type Intent Optional Attributes Name complex, intent(in) :: field (mx,nx,kx) complex, intent(in) :: fdt_in (mx,nx,kx) real, intent(in) :: dmp (mx,nx) real, intent(in) :: dmp1 (mx,nx) Return Value complex\n  (mx,nx,kx) Calls proc~~do_horizontal_diffusion_3d~~CallsGraph proc~do_horizontal_diffusion_3d do_horizontal_diffusion_3d proc~do_horizontal_diffusion_2d do_horizontal_diffusion_2d proc~do_horizontal_diffusion_3d->proc~do_horizontal_diffusion_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~do_horizontal_diffusion_3d~~CalledByGraph proc~do_horizontal_diffusion_3d do_horizontal_diffusion_3d interface~do_horizontal_diffusion do_horizontal_diffusion interface~do_horizontal_diffusion->proc~do_horizontal_diffusion_3d proc~step step proc~step->interface~do_horizontal_diffusion program~speedy speedy program~speedy->proc~step proc~initialize initialize program~speedy->proc~initialize proc~first_step first_step proc~first_step->proc~step proc~initialize->proc~first_step var panprocdo_horizontal_diffusion_3dCalledByGraph = svgPanZoom('#procdo_horizontal_diffusion_3dCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/do_horizontal_diffusion_3d.html"},{"title":"initialize_horizontal_diffusion – SPEEDY.f90","text":"public subroutine initialize_horizontal_diffusion() Uses dynamical_constants physical_constants geometry proc~~initialize_horizontal_diffusion~~UsesGraph proc~initialize_horizontal_diffusion initialize_horizontal_diffusion module~dynamical_constants dynamical_constants proc~initialize_horizontal_diffusion->module~dynamical_constants module~physical_constants physical_constants proc~initialize_horizontal_diffusion->module~physical_constants module~geometry geometry proc~initialize_horizontal_diffusion->module~geometry module~params params module~physical_constants->module~params module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Initializes the arrays used for horizontal diffusion. Arguments None Calls proc~~initialize_horizontal_diffusion~~CallsGraph proc~initialize_horizontal_diffusion initialize_horizontal_diffusion float float proc~initialize_horizontal_diffusion->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initialize_horizontal_diffusion~~CalledByGraph proc~initialize_horizontal_diffusion initialize_horizontal_diffusion proc~initialize initialize proc~initialize->proc~initialize_horizontal_diffusion program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize_horizontal_diffusion.html"},{"title":"do_horizontal_diffusion – SPEEDY.f90","text":"public interface do_horizontal_diffusion Calls interface~~do_horizontal_diffusion~~CallsGraph interface~do_horizontal_diffusion do_horizontal_diffusion proc~do_horizontal_diffusion_3d do_horizontal_diffusion_3d interface~do_horizontal_diffusion->proc~do_horizontal_diffusion_3d proc~do_horizontal_diffusion_2d do_horizontal_diffusion_2d interface~do_horizontal_diffusion->proc~do_horizontal_diffusion_2d proc~do_horizontal_diffusion_3d->proc~do_horizontal_diffusion_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~do_horizontal_diffusion~~CalledByGraph interface~do_horizontal_diffusion do_horizontal_diffusion proc~step step proc~step->interface~do_horizontal_diffusion program~speedy speedy program~speedy->proc~step proc~initialize initialize program~speedy->proc~initialize proc~first_step first_step proc~first_step->proc~step proc~initialize->proc~first_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures do_horizontal_diffusion_2d do_horizontal_diffusion_3d Module Procedures private function do_horizontal_diffusion_2d (field, fdt_in, dmp, dmp1) result(fdt_out) Adds horizontal diffusion tendency of field to spectral tendency fdt\n  using damping coefficients dmp and dmp1. Arguments Type Intent Optional Attributes Name complex, intent(in) :: field (mx,nx) complex, intent(in) :: fdt_in (mx,nx) real, intent(in) :: dmp (mx,nx) real, intent(in) :: dmp1 (mx,nx) Return Value complex\n  (mx,nx) private function do_horizontal_diffusion_3d (field, fdt_in, dmp, dmp1) result(fdt_out) Adds horizontal diffusion tendency of field to spectral tendency fdt\n  at all model levels using damping coefficients dmp and dmp1. Arguments Type Intent Optional Attributes Name complex, intent(in) :: field (mx,nx,kx) complex, intent(in) :: fdt_in (mx,nx,kx) real, intent(in) :: dmp (mx,nx) real, intent(in) :: dmp1 (mx,nx) Return Value complex\n  (mx,nx,kx)","tags":"","loc":"interface/do_horizontal_diffusion.html"},{"title":"initialize – SPEEDY.f90","text":"public subroutine initialize() Uses params date coupler sea_model geometry spectral geopotential horizontal_diffusion physics input_output time_stepping boundaries prognostics forcing proc~~initialize~~UsesGraph proc~initialize initialize module~physics physics proc~initialize->module~physics module~horizontal_diffusion horizontal_diffusion proc~initialize->module~horizontal_diffusion module~date date proc~initialize->module~date module~prognostics prognostics proc~initialize->module~prognostics module~boundaries boundaries proc~initialize->module~boundaries module~forcing forcing proc~initialize->module~forcing module~spectral spectral proc~initialize->module~spectral module~input_output input_output proc~initialize->module~input_output module~sea_model sea_model proc~initialize->module~sea_model module~geometry geometry proc~initialize->module~geometry module~params params proc~initialize->module~params module~coupler coupler proc~initialize->module~coupler module~time_stepping time_stepping proc~initialize->module~time_stepping module~geopotential geopotential proc~initialize->module~geopotential module~physics->module~params module~horizontal_diffusion->module~params module~prognostics->module~params module~boundaries->module~params module~spectral->module~params module~input_output->module~params netcdf netcdf module~input_output->netcdf module~sea_model->module~params module~geometry->module~params module~time_stepping->module~params module~geopotential->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Initializes everything. Arguments None Calls proc~~initialize~~CallsGraph proc~initialize initialize proc~initialize_date initialize_date proc~initialize->proc~initialize_date proc~initialize_coupler initialize_coupler proc~initialize->proc~initialize_coupler proc~initialize_horizontal_diffusion initialize_horizontal_diffusion proc~initialize->proc~initialize_horizontal_diffusion proc~set_forcing set_forcing proc~initialize->proc~set_forcing proc~initialize_geopotential initialize_geopotential proc~initialize->proc~initialize_geopotential proc~initialize_spectral initialize_spectral proc~initialize->proc~initialize_spectral proc~print_speedy_title print_speedy_title proc~initialize->proc~print_speedy_title proc~first_step first_step proc~initialize->proc~first_step proc~initialize_params initialize_params proc~initialize->proc~initialize_params proc~initialize_physics initialize_physics proc~initialize->proc~initialize_physics proc~initialize_geometry initialize_geometry proc~initialize->proc~initialize_geometry proc~initialize_prognostics initialize_prognostics proc~initialize->proc~initialize_prognostics proc~initialize_boundaries initialize_boundaries proc~initialize->proc~initialize_boundaries float float proc~initialize_date->float proc~sea_model_init sea_model_init proc~initialize_coupler->proc~sea_model_init proc~couple_sea_atm couple_sea_atm proc~initialize_coupler->proc~couple_sea_atm proc~couple_land_atm couple_land_atm proc~initialize_coupler->proc~couple_land_atm proc~land_model_init land_model_init proc~initialize_coupler->proc~land_model_init proc~initialize_horizontal_diffusion->float proc~get_qsat get_qsat proc~set_forcing->proc~get_qsat proc~set_orog_land_sfc_drag set_orog_land_sfc_drag proc~set_forcing->proc~set_orog_land_sfc_drag proc~radset radset proc~set_forcing->proc~radset proc~setgam setgam proc~set_forcing->proc~setgam proc~get_zonal_average_fields get_zonal_average_fields proc~set_forcing->proc~get_zonal_average_fields proc~grid_to_spec grid_to_spec proc~set_forcing->proc~grid_to_spec proc~initialize_fourier initialize_fourier proc~initialize_spectral->proc~initialize_fourier proc~initialize_legendre initialize_legendre proc~initialize_spectral->proc~initialize_legendre proc~initialize_spectral->float proc~step step proc~first_step->proc~step proc~initialize_implicit initialize_implicit proc~first_step->proc~initialize_implicit proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_prognostics->proc~initialize_from_rest_state proc~spectral_truncation spectral_truncation proc~initialize_boundaries->proc~spectral_truncation interface~load_boundary_file load_boundary_file proc~initialize_boundaries->interface~load_boundary_file proc~rffti1 rffti1 proc~initialize_fourier->proc~rffti1 proc~step_field_3d step_field_3d proc~step->proc~step_field_3d interface~do_horizontal_diffusion do_horizontal_diffusion proc~step->interface~do_horizontal_diffusion proc~get_tendencies get_tendencies proc~step->proc~get_tendencies proc~step_field_2d step_field_2d proc~step->proc~step_field_2d proc~sea_model_init->interface~load_boundary_file proc~forchk forchk proc~sea_model_init->proc~forchk proc~forint forint proc~couple_sea_atm->proc~forint proc~forin5 forin5 proc~couple_sea_atm->proc~forin5 proc~run_sea_model run_sea_model proc~couple_sea_atm->proc~run_sea_model proc~run_land_model run_land_model proc~couple_land_atm->proc~run_land_model proc~couple_land_atm->proc~forint proc~couple_land_atm->proc~forin5 proc~initialize_from_rest_state->proc~grid_to_spec proc~output output proc~initialize_from_rest_state->proc~output proc~initialize_implicit->float proc~spectral_truncation->proc~grid_to_spec proc~spec_to_grid spec_to_grid proc~spectral_truncation->proc~spec_to_grid proc~land_model_init->interface~load_boundary_file proc~land_model_init->proc~forchk proc~load_boundary_file_one_month_from_long load_boundary_file_one_month_from_long interface~load_boundary_file->proc~load_boundary_file_one_month_from_long proc~load_boundary_file_2d load_boundary_file_2d interface~load_boundary_file->proc~load_boundary_file_2d proc~load_boundary_file_one_month_from_year load_boundary_file_one_month_from_year interface~load_boundary_file->proc~load_boundary_file_one_month_from_year proc~solar solar proc~get_zonal_average_fields->proc~solar proc~legendre_dir legendre_dir proc~grid_to_spec->proc~legendre_dir proc~fourier_dir fourier_dir proc~grid_to_spec->proc~fourier_dir proc~initialize_legendre->float proc~get_weights get_weights proc~initialize_legendre->proc~get_weights proc~get_legendre_poly get_legendre_poly proc~initialize_legendre->proc~get_legendre_poly proc~output->proc~spec_to_grid nf90_enddef nf90_enddef proc~output->nf90_enddef nf90_close nf90_close proc~output->nf90_close nf90_create nf90_create proc~output->nf90_create nf90_put_att nf90_put_att proc~output->nf90_put_att nf90_def_dim nf90_def_dim proc~output->nf90_def_dim nf90_put_var nf90_put_var proc~output->nf90_put_var nf90_def_var nf90_def_var proc~output->nf90_def_var nf90_inq_varid nf90_inq_varid proc~load_boundary_file_one_month_from_long->nf90_inq_varid proc~load_boundary_file_one_month_from_long->nf90_close nf90_open nf90_open proc~load_boundary_file_one_month_from_long->nf90_open nf90_get_var nf90_get_var proc~load_boundary_file_one_month_from_long->nf90_get_var proc~load_boundary_file_2d->nf90_inq_varid proc~load_boundary_file_2d->nf90_close proc~load_boundary_file_2d->nf90_open proc~load_boundary_file_2d->nf90_get_var proc~fourier_dir->float proc~rfftf1 rfftf1 proc~fourier_dir->proc~rfftf1 proc~step_field_3d->proc~step_field_2d proc~do_horizontal_diffusion_2d do_horizontal_diffusion_2d interface~do_horizontal_diffusion->proc~do_horizontal_diffusion_2d proc~do_horizontal_diffusion_3d do_horizontal_diffusion_3d interface~do_horizontal_diffusion->proc~do_horizontal_diffusion_3d proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_tendencies->proc~get_grid_point_tendencies proc~get_spectral_tendencies get_spectral_tendencies proc~get_tendencies->proc~get_spectral_tendencies proc~implicit_terms implicit_terms proc~get_tendencies->proc~implicit_terms proc~get_legendre_poly->float proc~load_boundary_file_one_month_from_year->nf90_inq_varid proc~load_boundary_file_one_month_from_year->nf90_close proc~load_boundary_file_one_month_from_year->nf90_open proc~load_boundary_file_one_month_from_year->nf90_get_var proc~trunct trunct proc~step_field_2d->proc~trunct proc~legendre_inv legendre_inv proc~spec_to_grid->proc~legendre_inv proc~fourier_inv fourier_inv proc~spec_to_grid->proc~fourier_inv proc~get_grid_point_tendencies->proc~grid_to_spec proc~get_grid_point_tendencies->proc~spec_to_grid proc~get_geopotential get_geopotential proc~get_grid_point_tendencies->proc~get_geopotential proc~laplacian laplacian proc~get_grid_point_tendencies->proc~laplacian proc~rfftb1 rfftb1 proc~fourier_inv->proc~rfftb1 proc~get_spectral_tendencies->proc~get_geopotential proc~get_spectral_tendencies->proc~laplacian proc~do_horizontal_diffusion_3d->proc~do_horizontal_diffusion_2d var panprocinitializeCallsGraph = svgPanZoom('#procinitializeCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initialize~~CalledByGraph proc~initialize initialize program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize.html"},{"title":"print_speedy_title – SPEEDY.f90","text":"private subroutine print_speedy_title() Prints SPEEDY.f90 banner. Arguments None Called by proc~~print_speedy_title~~CalledByGraph proc~print_speedy_title print_speedy_title proc~initialize initialize proc~initialize->proc~print_speedy_title program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/print_speedy_title.html"},{"title":"land_model_init – SPEEDY.f90","text":"public subroutine land_model_init() Uses input_output boundaries proc~~land_model_init~~UsesGraph proc~land_model_init land_model_init module~input_output input_output proc~land_model_init->module~input_output module~boundaries boundaries proc~land_model_init->module~boundaries module~params params module~input_output->module~params netcdf netcdf module~input_output->netcdf module~boundaries->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Initializes land model. Arguments None Calls proc~~land_model_init~~CallsGraph proc~land_model_init land_model_init interface~load_boundary_file load_boundary_file proc~land_model_init->interface~load_boundary_file proc~forchk forchk proc~land_model_init->proc~forchk proc~load_boundary_file_one_month_from_long load_boundary_file_one_month_from_long interface~load_boundary_file->proc~load_boundary_file_one_month_from_long proc~load_boundary_file_2d load_boundary_file_2d interface~load_boundary_file->proc~load_boundary_file_2d proc~load_boundary_file_one_month_from_year load_boundary_file_one_month_from_year interface~load_boundary_file->proc~load_boundary_file_one_month_from_year nf90_inq_varid nf90_inq_varid proc~load_boundary_file_one_month_from_long->nf90_inq_varid nf90_close nf90_close proc~load_boundary_file_one_month_from_long->nf90_close nf90_open nf90_open proc~load_boundary_file_one_month_from_long->nf90_open nf90_get_var nf90_get_var proc~load_boundary_file_one_month_from_long->nf90_get_var proc~load_boundary_file_2d->nf90_inq_varid proc~load_boundary_file_2d->nf90_close proc~load_boundary_file_2d->nf90_open proc~load_boundary_file_2d->nf90_get_var proc~load_boundary_file_one_month_from_year->nf90_inq_varid proc~load_boundary_file_one_month_from_year->nf90_close proc~load_boundary_file_one_month_from_year->nf90_open proc~load_boundary_file_one_month_from_year->nf90_get_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~land_model_init~~CalledByGraph proc~land_model_init land_model_init proc~initialize_coupler initialize_coupler proc~initialize_coupler->proc~land_model_init proc~initialize initialize proc~initialize->proc~initialize_coupler program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/land_model_init.html"},{"title":"couple_land_atm – SPEEDY.f90","text":"public subroutine couple_land_atm(day) Uses date interpolation proc~~couple_land_atm~~UsesGraph proc~couple_land_atm couple_land_atm module~interpolation interpolation proc~couple_land_atm->module~interpolation module~date date proc~couple_land_atm->module~date module~interpolation->module~date module~params params module~interpolation->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Exchanges fluxes between land and atmosphere. Arguments Type Intent Optional Attributes Name integer, intent(in) :: day The day (starting at 0 for the first time step) Calls proc~~couple_land_atm~~CallsGraph proc~couple_land_atm couple_land_atm proc~run_land_model run_land_model proc~couple_land_atm->proc~run_land_model proc~forin5 forin5 proc~couple_land_atm->proc~forin5 proc~forint forint proc~couple_land_atm->proc~forint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~couple_land_atm~~CalledByGraph proc~couple_land_atm couple_land_atm proc~couple_sea_land couple_sea_land proc~couple_sea_land->proc~couple_land_atm proc~initialize_coupler initialize_coupler proc~initialize_coupler->proc~couple_land_atm program~speedy speedy program~speedy->proc~couple_sea_land proc~initialize initialize program~speedy->proc~initialize proc~initialize->proc~initialize_coupler Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/couple_land_atm.html"},{"title":"run_land_model – SPEEDY.f90","text":"private subroutine run_land_model() Uses auxiliaries proc~~run_land_model~~UsesGraph proc~run_land_model run_land_model module~auxiliaries auxiliaries proc~run_land_model->module~auxiliaries module~params params module~auxiliaries->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Integrates slab land-surface model for one day. Arguments None Called by proc~~run_land_model~~CalledByGraph proc~run_land_model run_land_model proc~couple_land_atm couple_land_atm proc~couple_land_atm->proc~run_land_model proc~couple_sea_land couple_sea_land proc~couple_sea_land->proc~couple_land_atm proc~initialize_coupler initialize_coupler proc~initialize_coupler->proc~couple_land_atm program~speedy speedy program~speedy->proc~couple_sea_land proc~initialize initialize program~speedy->proc~initialize proc~initialize->proc~initialize_coupler Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/run_land_model.html"},{"title":"ludcmp – SPEEDY.f90","text":"private subroutine ludcmp(a, n, np, indx, d) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a (np,np) integer, intent(in) :: n integer, intent(in) :: np integer, intent(inout) :: indx (n) real, intent(inout) :: d Called by proc~~ludcmp~~CalledByGraph proc~ludcmp ludcmp proc~inv inv proc~inv->proc~ludcmp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ludcmp.html"},{"title":"lubksb – SPEEDY.f90","text":"private subroutine lubksb(a, n, np, indx, b) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a (np,np) integer, intent(in) :: n integer, intent(in) :: np integer, intent(in) :: indx (n) real, intent(inout) :: b (n) Contents None","tags":"","loc":"proc/lubksb.html"},{"title":"inv – SPEEDY.f90","text":"public subroutine inv(a, y, indx, n) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a (n,n) real, intent(inout) :: y (n,n) integer, intent(inout) :: indx (n) integer, intent(in) :: n Calls proc~~inv~~CallsGraph proc~inv inv proc~ludcmp ludcmp proc~inv->proc~ludcmp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/inv.html"},{"title":"sea_model_init – SPEEDY.f90","text":"public subroutine sea_model_init() Uses boundaries date geometry input_output proc~~sea_model_init~~UsesGraph proc~sea_model_init sea_model_init module~boundaries boundaries proc~sea_model_init->module~boundaries module~input_output input_output proc~sea_model_init->module~input_output module~date date proc~sea_model_init->module~date module~geometry geometry proc~sea_model_init->module~geometry module~params params module~boundaries->module~params module~input_output->module~params netcdf netcdf module~input_output->netcdf module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~sea_model_init~~CallsGraph proc~sea_model_init sea_model_init interface~load_boundary_file load_boundary_file proc~sea_model_init->interface~load_boundary_file proc~forchk forchk proc~sea_model_init->proc~forchk proc~load_boundary_file_one_month_from_long load_boundary_file_one_month_from_long interface~load_boundary_file->proc~load_boundary_file_one_month_from_long proc~load_boundary_file_2d load_boundary_file_2d interface~load_boundary_file->proc~load_boundary_file_2d proc~load_boundary_file_one_month_from_year load_boundary_file_one_month_from_year interface~load_boundary_file->proc~load_boundary_file_one_month_from_year nf90_inq_varid nf90_inq_varid proc~load_boundary_file_one_month_from_long->nf90_inq_varid nf90_close nf90_close proc~load_boundary_file_one_month_from_long->nf90_close nf90_open nf90_open proc~load_boundary_file_one_month_from_long->nf90_open nf90_get_var nf90_get_var proc~load_boundary_file_one_month_from_long->nf90_get_var proc~load_boundary_file_2d->nf90_inq_varid proc~load_boundary_file_2d->nf90_close proc~load_boundary_file_2d->nf90_open proc~load_boundary_file_2d->nf90_get_var proc~load_boundary_file_one_month_from_year->nf90_inq_varid proc~load_boundary_file_one_month_from_year->nf90_close proc~load_boundary_file_one_month_from_year->nf90_open proc~load_boundary_file_one_month_from_year->nf90_get_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~sea_model_init~~CalledByGraph proc~sea_model_init sea_model_init proc~initialize_coupler initialize_coupler proc~initialize_coupler->proc~sea_model_init proc~initialize initialize proc~initialize->proc~initialize_coupler program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/sea_model_init.html"},{"title":"couple_sea_atm – SPEEDY.f90","text":"public subroutine couple_sea_atm(day) Uses date interpolation proc~~couple_sea_atm~~UsesGraph proc~couple_sea_atm couple_sea_atm module~interpolation interpolation proc~couple_sea_atm->module~interpolation module~date date proc~couple_sea_atm->module~date module~interpolation->module~date module~params params module~interpolation->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(in) :: day Calls proc~~couple_sea_atm~~CallsGraph proc~couple_sea_atm couple_sea_atm proc~run_sea_model run_sea_model proc~couple_sea_atm->proc~run_sea_model proc~forin5 forin5 proc~couple_sea_atm->proc~forin5 proc~forint forint proc~couple_sea_atm->proc~forint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~couple_sea_atm~~CalledByGraph proc~couple_sea_atm couple_sea_atm proc~couple_sea_land couple_sea_land proc~couple_sea_land->proc~couple_sea_atm proc~initialize_coupler initialize_coupler proc~initialize_coupler->proc~couple_sea_atm program~speedy speedy program~speedy->proc~couple_sea_land proc~initialize initialize program~speedy->proc~initialize proc~initialize->proc~initialize_coupler Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/couple_sea_atm.html"},{"title":"obs_ssta – SPEEDY.f90","text":"private subroutine obs_ssta() Uses date input_output boundaries proc~~obs_ssta~~UsesGraph proc~obs_ssta obs_ssta module~input_output input_output proc~obs_ssta->module~input_output module~date date proc~obs_ssta->module~date module~boundaries boundaries proc~obs_ssta->module~boundaries module~params params module~input_output->module~params netcdf netcdf module~input_output->netcdf module~boundaries->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~obs_ssta~~CallsGraph proc~obs_ssta obs_ssta interface~load_boundary_file load_boundary_file proc~obs_ssta->interface~load_boundary_file proc~load_boundary_file_one_month_from_long load_boundary_file_one_month_from_long interface~load_boundary_file->proc~load_boundary_file_one_month_from_long proc~load_boundary_file_2d load_boundary_file_2d interface~load_boundary_file->proc~load_boundary_file_2d proc~load_boundary_file_one_month_from_year load_boundary_file_one_month_from_year interface~load_boundary_file->proc~load_boundary_file_one_month_from_year nf90_inq_varid nf90_inq_varid proc~load_boundary_file_one_month_from_long->nf90_inq_varid nf90_close nf90_close proc~load_boundary_file_one_month_from_long->nf90_close nf90_open nf90_open proc~load_boundary_file_one_month_from_long->nf90_open nf90_get_var nf90_get_var proc~load_boundary_file_one_month_from_long->nf90_get_var proc~load_boundary_file_2d->nf90_inq_varid proc~load_boundary_file_2d->nf90_close proc~load_boundary_file_2d->nf90_open proc~load_boundary_file_2d->nf90_get_var proc~load_boundary_file_one_month_from_year->nf90_inq_varid proc~load_boundary_file_one_month_from_year->nf90_close proc~load_boundary_file_one_month_from_year->nf90_open proc~load_boundary_file_one_month_from_year->nf90_get_var Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/obs_ssta.html"},{"title":"run_sea_model – SPEEDY.f90","text":"private subroutine run_sea_model() Uses auxiliaries mod_radcon physical_constants proc~~run_sea_model~~UsesGraph proc~run_sea_model run_sea_model module~mod_radcon mod_radcon proc~run_sea_model->module~mod_radcon module~auxiliaries auxiliaries proc~run_sea_model->module~auxiliaries module~physical_constants physical_constants proc~run_sea_model->module~physical_constants module~params params module~mod_radcon->module~params module~auxiliaries->module~params module~physical_constants->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Called by proc~~run_sea_model~~CalledByGraph proc~run_sea_model run_sea_model proc~couple_sea_atm couple_sea_atm proc~couple_sea_atm->proc~run_sea_model proc~couple_sea_land couple_sea_land proc~couple_sea_land->proc~couple_sea_atm proc~initialize_coupler initialize_coupler proc~initialize_coupler->proc~couple_sea_atm program~speedy speedy program~speedy->proc~couple_sea_land proc~initialize initialize program~speedy->proc~initialize proc~initialize->proc~initialize_coupler Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/run_sea_model.html"},{"title":"sea_domain – SPEEDY.f90","text":"private subroutine sea_domain(cdomain, dmask) Arguments Type Intent Optional Attributes Name character(len=6), intent(in) :: cdomain real, intent(inout) :: dmask (ix,il) Calls proc~~sea_domain~~CallsGraph proc~sea_domain sea_domain float float proc~sea_domain->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/sea_domain.html"},{"title":"step_field_3d – SPEEDY.f90","text":"private function step_field_3d(j1, dt, eps, input, fdt) result(output) Uses spectral proc~~step_field_3d~~UsesGraph proc~step_field_3d step_field_3d module~spectral spectral proc~step_field_3d->module~spectral module~params params module~spectral->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(in) :: j1 real, intent(in) :: dt real, intent(in) :: eps complex, intent(in) :: input (mx,nx,kx,2) complex, intent(inout) :: fdt (mx,nx,kx) Return Value complex\n  (mx,nx,kx,2) Calls proc~~step_field_3d~~CallsGraph proc~step_field_3d step_field_3d proc~step_field_2d step_field_2d proc~step_field_3d->proc~step_field_2d proc~trunct trunct proc~step_field_2d->proc~trunct Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~step_field_3d~~CalledByGraph proc~step_field_3d step_field_3d proc~step step proc~step->proc~step_field_3d program~speedy speedy program~speedy->proc~step proc~initialize initialize program~speedy->proc~initialize proc~first_step first_step proc~first_step->proc~step proc~initialize->proc~first_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/step_field_3d.html"},{"title":"step_field_2d – SPEEDY.f90","text":"private function step_field_2d(j1, dt, eps, input, fdt) result(output) Uses spectral proc~~step_field_2d~~UsesGraph proc~step_field_2d step_field_2d module~spectral spectral proc~step_field_2d->module~spectral module~params params module~spectral->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(in) :: j1 real, intent(in) :: dt real, intent(in) :: eps complex, intent(in) :: input (mx,nx,2) complex, intent(inout) :: fdt (mx,nx) Return Value complex\n  (mx,nx,2) Calls proc~~step_field_2d~~CallsGraph proc~step_field_2d step_field_2d proc~trunct trunct proc~step_field_2d->proc~trunct Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~step_field_2d~~CalledByGraph proc~step_field_2d step_field_2d proc~step step proc~step->proc~step_field_2d proc~step_field_3d step_field_3d proc~step->proc~step_field_3d proc~step_field_3d->proc~step_field_2d program~speedy speedy program~speedy->proc~step proc~initialize initialize program~speedy->proc~initialize proc~first_step first_step proc~first_step->proc~step proc~initialize->proc~first_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/step_field_2d.html"},{"title":"first_step – SPEEDY.f90","text":"public subroutine first_step() Uses implicit proc~~first_step~~UsesGraph proc~first_step first_step module~implicit implicit proc~first_step->module~implicit module~params params module~implicit->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~first_step~~CallsGraph proc~first_step first_step proc~initialize_implicit initialize_implicit proc~first_step->proc~initialize_implicit proc~step step proc~first_step->proc~step float float proc~initialize_implicit->float proc~step_field_3d step_field_3d proc~step->proc~step_field_3d interface~do_horizontal_diffusion do_horizontal_diffusion proc~step->interface~do_horizontal_diffusion proc~get_tendencies get_tendencies proc~step->proc~get_tendencies proc~step_field_2d step_field_2d proc~step->proc~step_field_2d proc~step_field_3d->proc~step_field_2d proc~do_horizontal_diffusion_3d do_horizontal_diffusion_3d interface~do_horizontal_diffusion->proc~do_horizontal_diffusion_3d proc~do_horizontal_diffusion_2d do_horizontal_diffusion_2d interface~do_horizontal_diffusion->proc~do_horizontal_diffusion_2d proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_tendencies->proc~get_grid_point_tendencies proc~get_spectral_tendencies get_spectral_tendencies proc~get_tendencies->proc~get_spectral_tendencies proc~implicit_terms implicit_terms proc~get_tendencies->proc~implicit_terms proc~trunct trunct proc~step_field_2d->proc~trunct proc~get_geopotential get_geopotential proc~get_grid_point_tendencies->proc~get_geopotential proc~grid_to_spec grid_to_spec proc~get_grid_point_tendencies->proc~grid_to_spec proc~spec_to_grid spec_to_grid proc~get_grid_point_tendencies->proc~spec_to_grid proc~laplacian laplacian proc~get_grid_point_tendencies->proc~laplacian proc~get_spectral_tendencies->proc~get_geopotential proc~get_spectral_tendencies->proc~laplacian proc~do_horizontal_diffusion_3d->proc~do_horizontal_diffusion_2d proc~legendre_dir legendre_dir proc~grid_to_spec->proc~legendre_dir proc~fourier_dir fourier_dir proc~grid_to_spec->proc~fourier_dir proc~fourier_inv fourier_inv proc~spec_to_grid->proc~fourier_inv proc~legendre_inv legendre_inv proc~spec_to_grid->proc~legendre_inv proc~rfftb1 rfftb1 proc~fourier_inv->proc~rfftb1 proc~fourier_dir->float proc~rfftf1 rfftf1 proc~fourier_dir->proc~rfftf1 var panprocfirst_stepCallsGraph = svgPanZoom('#procfirst_stepCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~first_step~~CalledByGraph proc~first_step first_step proc~initialize initialize proc~initialize->proc~first_step program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/first_step.html"},{"title":"step – SPEEDY.f90","text":"public subroutine step(j1, j2, dt) Uses dynamical_constants prognostics horizontal_diffusion tendencies proc~~step~~UsesGraph proc~step step module~dynamical_constants dynamical_constants proc~step->module~dynamical_constants module~horizontal_diffusion horizontal_diffusion proc~step->module~horizontal_diffusion module~prognostics prognostics proc~step->module~prognostics module~tendencies tendencies proc~step->module~tendencies module~params params module~horizontal_diffusion->module~params module~prognostics->module~params module~tendencies->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(in) :: j1 integer, intent(in) :: j2 real, intent(in) :: dt Calls proc~~step~~CallsGraph proc~step step interface~do_horizontal_diffusion do_horizontal_diffusion proc~step->interface~do_horizontal_diffusion proc~step_field_3d step_field_3d proc~step->proc~step_field_3d proc~step_field_2d step_field_2d proc~step->proc~step_field_2d proc~get_tendencies get_tendencies proc~step->proc~get_tendencies proc~do_horizontal_diffusion_3d do_horizontal_diffusion_3d interface~do_horizontal_diffusion->proc~do_horizontal_diffusion_3d proc~do_horizontal_diffusion_2d do_horizontal_diffusion_2d interface~do_horizontal_diffusion->proc~do_horizontal_diffusion_2d proc~step_field_3d->proc~step_field_2d proc~trunct trunct proc~step_field_2d->proc~trunct proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_tendencies->proc~get_grid_point_tendencies proc~get_spectral_tendencies get_spectral_tendencies proc~get_tendencies->proc~get_spectral_tendencies proc~implicit_terms implicit_terms proc~get_tendencies->proc~implicit_terms proc~get_geopotential get_geopotential proc~get_grid_point_tendencies->proc~get_geopotential proc~grid_to_spec grid_to_spec proc~get_grid_point_tendencies->proc~grid_to_spec proc~spec_to_grid spec_to_grid proc~get_grid_point_tendencies->proc~spec_to_grid proc~laplacian laplacian proc~get_grid_point_tendencies->proc~laplacian proc~get_spectral_tendencies->proc~get_geopotential proc~get_spectral_tendencies->proc~laplacian proc~do_horizontal_diffusion_3d->proc~do_horizontal_diffusion_2d proc~legendre_dir legendre_dir proc~grid_to_spec->proc~legendre_dir proc~fourier_dir fourier_dir proc~grid_to_spec->proc~fourier_dir proc~fourier_inv fourier_inv proc~spec_to_grid->proc~fourier_inv proc~legendre_inv legendre_inv proc~spec_to_grid->proc~legendre_inv proc~rfftb1 rfftb1 proc~fourier_inv->proc~rfftb1 proc~rfftf1 rfftf1 proc~fourier_dir->proc~rfftf1 float float proc~fourier_dir->float var panprocstepCallsGraph = svgPanZoom('#procstepCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~step~~CalledByGraph proc~step step program~speedy speedy program~speedy->proc~step proc~initialize initialize program~speedy->proc~initialize proc~first_step first_step proc~first_step->proc~step proc~initialize->proc~first_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/step.html"},{"title":"initialize_physics – SPEEDY.f90","text":"public subroutine initialize_physics() Uses physical_constants geometry proc~~initialize_physics~~UsesGraph proc~initialize_physics initialize_physics module~physical_constants physical_constants proc~initialize_physics->module~physical_constants module~geometry geometry proc~initialize_physics->module~geometry module~params params module~physical_constants->module~params module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Called by proc~~initialize_physics~~CalledByGraph proc~initialize_physics initialize_physics proc~initialize initialize proc~initialize->proc~initialize_physics program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize_physics.html"},{"title":"get_physical_tendencies – SPEEDY.f90","text":"public subroutine get_physical_tendencies(vor, div, t, q, phi, psl, utend, vtend, ttend, qtend) Uses auxiliaries physical_constants geometry boundaries land_model sea_model sppt convection large_scale_condensation shortwave_radiation longwave_radiation surface_fluxes vertical_diffusion humidity spectral proc~~get_physical_tendencies~~UsesGraph proc~get_physical_tendencies get_physical_tendencies module~physical_constants physical_constants proc~get_physical_tendencies->module~physical_constants module~surface_fluxes surface_fluxes proc~get_physical_tendencies->module~surface_fluxes module~shortwave_radiation shortwave_radiation proc~get_physical_tendencies->module~shortwave_radiation module~boundaries boundaries proc~get_physical_tendencies->module~boundaries module~geometry geometry proc~get_physical_tendencies->module~geometry module~humidity humidity proc~get_physical_tendencies->module~humidity module~spectral spectral proc~get_physical_tendencies->module~spectral module~convection convection proc~get_physical_tendencies->module~convection module~land_model land_model proc~get_physical_tendencies->module~land_model module~vertical_diffusion vertical_diffusion proc~get_physical_tendencies->module~vertical_diffusion module~auxiliaries auxiliaries proc~get_physical_tendencies->module~auxiliaries module~sea_model sea_model proc~get_physical_tendencies->module~sea_model module~large_scale_condensation large_scale_condensation proc~get_physical_tendencies->module~large_scale_condensation module~sppt sppt proc~get_physical_tendencies->module~sppt module~longwave_radiation longwave_radiation proc~get_physical_tendencies->module~longwave_radiation module~params params module~physical_constants->module~params module~surface_fluxes->module~params module~shortwave_radiation->module~params module~boundaries->module~params module~geometry->module~params module~humidity->module~params module~spectral->module~params module~convection->module~params module~land_model->module~params module~vertical_diffusion->module~params module~auxiliaries->module~params module~sea_model->module~params module~large_scale_condensation->module~params module~sppt->module~params module~longwave_radiation->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute physical parametrization tendencies for u, v, t, q and add them\n  to the dynamical grid-point tendencies Arguments Type Intent Optional Attributes Name complex, intent(in) :: vor (mx,nx,kx) Vorticity complex, intent(in) :: div (mx,nx,kx) Divergence complex, intent(in) :: t (mx,nx,kx) Temperature complex, intent(in) :: q (mx,nx,kx) Specific Humidity complex, intent(in) :: phi (mx,nx,kx) Geopotential complex, intent(in) :: psl (mx,nx) ln(Surface pressure) real, intent(inout) :: utend (ix,il,kx) Zonal velocity tendency real, intent(inout) :: vtend (ix,il,kx) Meridional velocity tendency real, intent(inout) :: ttend (ix,il,kx) Temperature tendency real, intent(inout) :: qtend (ix,il,kx) Specific humidity tendency Calls proc~~get_physical_tendencies~~CallsGraph proc~get_physical_tendencies get_physical_tendencies proc~get_shortwave_rad_fluxes get_shortwave_rad_fluxes proc~get_physical_tendencies->proc~get_shortwave_rad_fluxes proc~get_downward_longwave_rad_fluxes get_downward_longwave_rad_fluxes proc~get_physical_tendencies->proc~get_downward_longwave_rad_fluxes float float proc~get_physical_tendencies->float proc~gen_sppt gen_sppt proc~get_physical_tendencies->proc~gen_sppt proc~get_convection_tendencies get_convection_tendencies proc~get_physical_tendencies->proc~get_convection_tendencies proc~get_large_scale_condensation_tendencies get_large_scale_condensation_tendencies proc~get_physical_tendencies->proc~get_large_scale_condensation_tendencies proc~get_surface_fluxes get_surface_fluxes proc~get_physical_tendencies->proc~get_surface_fluxes proc~clouds clouds proc~get_physical_tendencies->proc~clouds proc~get_vertical_diffusion_tend get_vertical_diffusion_tend proc~get_physical_tendencies->proc~get_vertical_diffusion_tend proc~spec_to_grid spec_to_grid proc~get_physical_tendencies->proc~spec_to_grid proc~gen_sppt->proc~spec_to_grid proc~randn randn proc~gen_sppt->proc~randn proc~diagnose_convection diagnose_convection proc~get_convection_tendencies->proc~diagnose_convection proc~get_qsat get_qsat proc~get_surface_fluxes->proc~get_qsat proc~legendre_inv legendre_inv proc~spec_to_grid->proc~legendre_inv proc~fourier_inv fourier_inv proc~spec_to_grid->proc~fourier_inv proc~rfftb1 rfftb1 proc~fourier_inv->proc~rfftb1 var panprocget_physical_tendenciesCallsGraph = svgPanZoom('#procget_physical_tendenciesCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_physical_tendencies.html"},{"title":"get_surface_fluxes – SPEEDY.f90","text":"public subroutine get_surface_fluxes(psa, ua, va, ta, qa, rh, phi, phi0, fmask, tsea, ssrd, slrd, ustr, vstr, shf, evap, slru, hfluxn, tsfc, tskin, u0, v0, t0, lfluxland) Uses physical_constants geometry mod_radcon land_model humidity proc~~get_surface_fluxes~~UsesGraph proc~get_surface_fluxes get_surface_fluxes module~physical_constants physical_constants proc~get_surface_fluxes->module~physical_constants module~humidity humidity proc~get_surface_fluxes->module~humidity module~land_model land_model proc~get_surface_fluxes->module~land_model module~geometry geometry proc~get_surface_fluxes->module~geometry module~mod_radcon mod_radcon proc~get_surface_fluxes->module~mod_radcon module~params params module~physical_constants->module~params module~humidity->module~params module~land_model->module~params module~geometry->module~params module~mod_radcon->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute surface fluxes of momentum, energy and moisture, and define surface\n  skin temperature from energy balance Arguments Type Intent Optional Attributes Name real, intent(in) :: psa (ix,il) Normalised surface pressure real, intent(in) :: ua (ix,il,kx) u-wind real, intent(in) :: va (ix,il,kx) v-wind real, intent(in) :: ta (ix,il,kx) Temperature real, intent(in) :: qa (ix,il,kx) Specific humidity [g/kg] real, intent(in) :: rh (ix,il,kx) Relative humidity real, intent(in) :: phi (ix,il,kx) Geopotential real, intent(in) :: phi0 (ix,il) Surface geopotential real, intent(in) :: fmask (ix,il) Fractional land-sea mask real, intent(in) :: tsea (ix,il) Sea-surface temperature real, intent(in) :: ssrd (ix,il) Downward flux of short-wave radiation at the surface real, intent(in) :: slrd (ix,il) Downward flux of long-wave radiation at the surface real, intent(out) :: ustr (ix,il,3) u-stress real, intent(out) :: vstr (ix,il,3) v-stress real, intent(out) :: shf (ix,il,3) Sensible heat flux real, intent(out) :: evap (ix,il,3) Evaporation real, intent(out) :: slru (ix,il,3) Upward flux of long-wave radiation at the surface real, intent(out) :: hfluxn (ix,il,2) Net downward heat flux real, intent(out) :: tsfc (ix,il) Surface temperature real, intent(out) :: tskin (ix,il) Skin surface temperature real, intent(out) :: u0 (ix,il) Near-surface u-wind real, intent(out) :: v0 (ix,il) Near-surface v-wind real, intent(out) :: t0 (ix,il) Near-surface temperature logical, intent(in) :: lfluxland Calls proc~~get_surface_fluxes~~CallsGraph proc~get_surface_fluxes get_surface_fluxes proc~get_qsat get_qsat proc~get_surface_fluxes->proc~get_qsat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_surface_fluxes~~CalledByGraph proc~get_surface_fluxes get_surface_fluxes proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->proc~get_surface_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_surface_fluxes.html"},{"title":"set_orog_land_sfc_drag – SPEEDY.f90","text":"public subroutine set_orog_land_sfc_drag(phi0) Uses physical_constants proc~~set_orog_land_sfc_drag~~UsesGraph proc~set_orog_land_sfc_drag set_orog_land_sfc_drag module~physical_constants physical_constants proc~set_orog_land_sfc_drag->module~physical_constants module~params params module~physical_constants->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real, intent(in) :: phi0 (ix,il) Called by proc~~set_orog_land_sfc_drag~~CalledByGraph proc~set_orog_land_sfc_drag set_orog_land_sfc_drag proc~set_forcing set_forcing proc~set_forcing->proc~set_orog_land_sfc_drag program~speedy speedy program~speedy->proc~set_forcing proc~initialize initialize program~speedy->proc~initialize proc~initialize->proc~set_forcing Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_orog_land_sfc_drag.html"},{"title":"get_tendencies – SPEEDY.f90","text":"public subroutine get_tendencies(vordt, divdt, tdt, psdt, trdt, j2) Uses implicit proc~~get_tendencies~~UsesGraph proc~get_tendencies get_tendencies module~implicit implicit proc~get_tendencies->module~implicit module~params params module~implicit->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(mx,nx,kx) :: vordt complex, intent(inout), dimension(mx,nx,kx) :: divdt complex, intent(inout), dimension(mx,nx,kx) :: tdt complex, intent(inout) :: psdt (mx,nx) complex, intent(inout) :: trdt (mx,nx,kx,ntr) integer, intent(in) :: j2 Calls proc~~get_tendencies~~CallsGraph proc~get_tendencies get_tendencies proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_tendencies->proc~get_grid_point_tendencies proc~implicit_terms implicit_terms proc~get_tendencies->proc~implicit_terms proc~get_spectral_tendencies get_spectral_tendencies proc~get_tendencies->proc~get_spectral_tendencies proc~get_geopotential get_geopotential proc~get_grid_point_tendencies->proc~get_geopotential proc~grid_to_spec grid_to_spec proc~get_grid_point_tendencies->proc~grid_to_spec proc~spec_to_grid spec_to_grid proc~get_grid_point_tendencies->proc~spec_to_grid proc~laplacian laplacian proc~get_grid_point_tendencies->proc~laplacian proc~get_spectral_tendencies->proc~get_geopotential proc~get_spectral_tendencies->proc~laplacian proc~legendre_dir legendre_dir proc~grid_to_spec->proc~legendre_dir proc~fourier_dir fourier_dir proc~grid_to_spec->proc~fourier_dir proc~fourier_inv fourier_inv proc~spec_to_grid->proc~fourier_inv proc~legendre_inv legendre_inv proc~spec_to_grid->proc~legendre_inv proc~rfftb1 rfftb1 proc~fourier_inv->proc~rfftb1 proc~rfftf1 rfftf1 proc~fourier_dir->proc~rfftf1 float float proc~fourier_dir->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_tendencies~~CalledByGraph proc~get_tendencies get_tendencies proc~step step proc~step->proc~get_tendencies program~speedy speedy program~speedy->proc~step proc~initialize initialize program~speedy->proc~initialize proc~first_step first_step proc~first_step->proc~step proc~initialize->proc~first_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_tendencies.html"},{"title":"get_grid_point_tendencies – SPEEDY.f90","text":"private subroutine get_grid_point_tendencies(vordt, divdt, tdt, psdt, trdt, j1, j2) Uses prognostics physical_constants geometry implicit geopotential physics spectral proc~~get_grid_point_tendencies~~UsesGraph proc~get_grid_point_tendencies get_grid_point_tendencies module~physical_constants physical_constants proc~get_grid_point_tendencies->module~physical_constants module~physics physics proc~get_grid_point_tendencies->module~physics module~prognostics prognostics proc~get_grid_point_tendencies->module~prognostics module~spectral spectral proc~get_grid_point_tendencies->module~spectral module~geometry geometry proc~get_grid_point_tendencies->module~geometry module~implicit implicit proc~get_grid_point_tendencies->module~implicit module~geopotential geopotential proc~get_grid_point_tendencies->module~geopotential module~params params module~physical_constants->module~params module~physics->module~params module~prognostics->module~params module~spectral->module~params module~geometry->module~params module~implicit->module~params module~geopotential->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(mx,nx,kx) :: vordt complex, intent(inout), dimension(mx,nx,kx) :: divdt complex, intent(inout), dimension(mx,nx,kx) :: tdt complex, intent(inout) :: psdt (mx,nx) complex, intent(inout) :: trdt (mx,nx,kx,ntr) integer, intent(in) :: j1 integer, intent(in) :: j2 Calls proc~~get_grid_point_tendencies~~CallsGraph proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_geopotential get_geopotential proc~get_grid_point_tendencies->proc~get_geopotential proc~grid_to_spec grid_to_spec proc~get_grid_point_tendencies->proc~grid_to_spec proc~spec_to_grid spec_to_grid proc~get_grid_point_tendencies->proc~spec_to_grid proc~laplacian laplacian proc~get_grid_point_tendencies->proc~laplacian proc~legendre_dir legendre_dir proc~grid_to_spec->proc~legendre_dir proc~fourier_dir fourier_dir proc~grid_to_spec->proc~fourier_dir proc~fourier_inv fourier_inv proc~spec_to_grid->proc~fourier_inv proc~legendre_inv legendre_inv proc~spec_to_grid->proc~legendre_inv proc~rfftb1 rfftb1 proc~fourier_inv->proc~rfftb1 proc~rfftf1 rfftf1 proc~fourier_dir->proc~rfftf1 float float proc~fourier_dir->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_grid_point_tendencies~~CalledByGraph proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_tendencies get_tendencies proc~get_tendencies->proc~get_grid_point_tendencies proc~step step proc~step->proc~get_tendencies program~speedy speedy program~speedy->proc~step proc~initialize initialize program~speedy->proc~initialize proc~first_step first_step proc~first_step->proc~step proc~initialize->proc~first_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_grid_point_tendencies.html"},{"title":"get_spectral_tendencies – SPEEDY.f90","text":"private subroutine get_spectral_tendencies(divdt, tdt, psdt, j2) Uses prognostics physical_constants geometry geopotential implicit spectral proc~~get_spectral_tendencies~~UsesGraph proc~get_spectral_tendencies get_spectral_tendencies module~physical_constants physical_constants proc~get_spectral_tendencies->module~physical_constants module~prognostics prognostics proc~get_spectral_tendencies->module~prognostics module~spectral spectral proc~get_spectral_tendencies->module~spectral module~geometry geometry proc~get_spectral_tendencies->module~geometry module~implicit implicit proc~get_spectral_tendencies->module~implicit module~geopotential geopotential proc~get_spectral_tendencies->module~geopotential module~params params module~physical_constants->module~params module~prognostics->module~params module~spectral->module~params module~geometry->module~params module~implicit->module~params module~geopotential->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name complex, intent(inout) :: divdt (mx,nx,kx) complex, intent(inout) :: tdt (mx,nx,kx) complex, intent(inout) :: psdt (mx,nx) integer, intent(in) :: j2 Calls proc~~get_spectral_tendencies~~CallsGraph proc~get_spectral_tendencies get_spectral_tendencies proc~get_geopotential get_geopotential proc~get_spectral_tendencies->proc~get_geopotential proc~laplacian laplacian proc~get_spectral_tendencies->proc~laplacian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_spectral_tendencies~~CalledByGraph proc~get_spectral_tendencies get_spectral_tendencies proc~get_tendencies get_tendencies proc~get_tendencies->proc~get_spectral_tendencies proc~step step proc~step->proc~get_tendencies program~speedy speedy program~speedy->proc~step proc~initialize initialize program~speedy->proc~initialize proc~first_step first_step proc~first_step->proc~step proc~initialize->proc~first_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_spectral_tendencies.html"},{"title":"get_shortwave_rad_fluxes – SPEEDY.f90","text":"public subroutine get_shortwave_rad_fluxes(psa, qa, icltop, cloudc, clstr, fsfcd, fsfc, ftop, dfabs) Uses geometry mod_radcon proc~~get_shortwave_rad_fluxes~~UsesGraph proc~get_shortwave_rad_fluxes get_shortwave_rad_fluxes module~mod_radcon mod_radcon proc~get_shortwave_rad_fluxes->module~mod_radcon module~geometry geometry proc~get_shortwave_rad_fluxes->module~geometry module~params params module~mod_radcon->module~params module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute the absorption of shortwave radiation and initialize arrays\n  for longwave-radiation routines Arguments Type Intent Optional Attributes Name real, intent(in) :: psa (ix,il) Normalised surface pressure [p/p0] real, intent(in) :: qa (ix,il,kx) Specific humidity [g/kg] integer, intent(in) :: icltop (ix,il) Cloud top level real, intent(in) :: cloudc (ix,il) Total cloud cover real, intent(in) :: clstr (ix,il) Stratiform cloud cover real, intent(out) :: fsfcd (ix,il) Total downward flux of short-wave radiation at the\n surface real, intent(out) :: fsfc (ix,il) Net downward flux of short-wave radiation at the\n surface real, intent(out) :: ftop (ix,il) Net downward flux of short-wave radiation at the\n top of the atmosphere real, intent(out) :: dfabs (ix,il,kx) Flux of short-wave radiation absorbed in each\n atmospheric layer Called by proc~~get_shortwave_rad_fluxes~~CalledByGraph proc~get_shortwave_rad_fluxes get_shortwave_rad_fluxes proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->proc~get_shortwave_rad_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_shortwave_rad_fluxes.html"},{"title":"get_zonal_average_fields – SPEEDY.f90","text":"public subroutine get_zonal_average_fields(tyear) Uses geometry proc~~get_zonal_average_fields~~UsesGraph proc~get_zonal_average_fields get_zonal_average_fields module~geometry geometry proc~get_zonal_average_fields->module~geometry module~params params module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute zonally-averaged fields to be used in the computation of\n  short-wave absorption Arguments Type Intent Optional Attributes Name real, intent(in) :: tyear time as fraction of year (0-1, 0 = 1jan.h00) Calls proc~~get_zonal_average_fields~~CallsGraph proc~get_zonal_average_fields get_zonal_average_fields proc~solar solar proc~get_zonal_average_fields->proc~solar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_zonal_average_fields~~CalledByGraph proc~get_zonal_average_fields get_zonal_average_fields proc~set_forcing set_forcing proc~set_forcing->proc~get_zonal_average_fields program~speedy speedy program~speedy->proc~set_forcing proc~initialize initialize program~speedy->proc~initialize proc~initialize->proc~set_forcing Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_zonal_average_fields.html"},{"title":"solar – SPEEDY.f90","text":"private subroutine solar(tyear, csol, topsr) Uses geometry proc~~solar~~UsesGraph proc~solar solar module~geometry geometry proc~solar->module~geometry module~params params module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real, intent(in) :: tyear time as fraction of year (0-1, 0 = 1jan.h00) real, intent(in) :: csol The solar constant [W/m&#94;2] real, intent(out) :: topsr (il) Daily-average insolation at the top of the atmosphere as a\n function of latitude Called by proc~~solar~~CalledByGraph proc~solar solar proc~get_zonal_average_fields get_zonal_average_fields proc~get_zonal_average_fields->proc~solar proc~set_forcing set_forcing proc~set_forcing->proc~get_zonal_average_fields program~speedy speedy program~speedy->proc~set_forcing proc~initialize initialize program~speedy->proc~initialize proc~initialize->proc~set_forcing Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/solar.html"},{"title":"clouds – SPEEDY.f90","text":"public subroutine clouds(qa, rh, precnv, precls, iptop, gse, fmask, icltop, cloudc, clstr) Compute cloud-top level and cloud cover Arguments Type Intent Optional Attributes Name real, intent(in) :: qa (ix,il,kx) Specific humidity [g/kg] real, intent(in) :: rh (ix,il,kx) Relative humidity real, intent(in) :: precnv (ix,il) Convection precipitation real, intent(in) :: precls (ix,il) Large-scale condensational precipitation integer :: iptop (ix,il) real, intent(in) :: gse (ix,il) Vertical gradient of dry static energy real, intent(in) :: fmask (ix,il) Fraction land-sea mask integer, intent(out) :: icltop (ix,il) Cloud top level real, intent(out) :: cloudc (ix,il) Total cloud cover real, intent(out) :: clstr (ix,il) Stratiform cloud cover Called by proc~~clouds~~CalledByGraph proc~clouds clouds proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->proc~clouds Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/clouds.html"},{"title":"datetime_equal – SPEEDY.f90","text":"public function datetime_equal(datetime1, datetime2) Checks whether two datetimes are equal. Arguments Type Intent Optional Attributes Name type( datetime ), intent(in) :: datetime1 type( datetime ), intent(in) :: datetime2 Return Value logical Called by proc~~datetime_equal~~CalledByGraph proc~datetime_equal datetime_equal program~speedy speedy program~speedy->proc~datetime_equal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/datetime_equal.html"},{"title":"initialize_date – SPEEDY.f90","text":"public subroutine initialize_date() Uses params proc~~initialize_date~~UsesGraph proc~initialize_date initialize_date module~params params proc~initialize_date->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Initializes model date and calendar. Arguments None Calls proc~~initialize_date~~CallsGraph proc~initialize_date initialize_date float float proc~initialize_date->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initialize_date~~CalledByGraph proc~initialize_date initialize_date proc~initialize initialize proc~initialize->proc~initialize_date program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize_date.html"},{"title":"newdate – SPEEDY.f90","text":"public subroutine newdate() Uses params proc~~newdate~~UsesGraph proc~newdate newdate module~params params proc~newdate->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Updates the current datetime and related date variables. Arguments None Calls proc~~newdate~~CallsGraph proc~newdate newdate float float proc~newdate->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~newdate~~CalledByGraph proc~newdate newdate program~speedy speedy program~speedy->proc~newdate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/newdate.html"},{"title":"initialize_geometry – SPEEDY.f90","text":"public subroutine initialize_geometry() Uses physical_constants proc~~initialize_geometry~~UsesGraph proc~initialize_geometry initialize_geometry module~physical_constants physical_constants proc~initialize_geometry->module~physical_constants module~params params module~physical_constants->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Initializes all of the model geometry variables. Arguments None Called by proc~~initialize_geometry~~CalledByGraph proc~initialize_geometry initialize_geometry proc~initialize initialize proc~initialize->proc~initialize_geometry program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize_geometry.html"},{"title":"legendre_inv – SPEEDY.f90","text":"public function legendre_inv(input) result(output) Computes inverse Legendre transformation. Arguments Type Intent Optional Attributes Name real, intent(in) :: input (2*mx,nx) Input field Return Value real\n  (2*mx,il) Output field Called by proc~~legendre_inv~~CalledByGraph proc~legendre_inv legendre_inv proc~spec_to_grid spec_to_grid proc~spec_to_grid->proc~legendre_inv proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_grid_point_tendencies->proc~spec_to_grid proc~gen_sppt gen_sppt proc~gen_sppt->proc~spec_to_grid proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->proc~spec_to_grid proc~get_physical_tendencies->proc~gen_sppt proc~spectral_truncation spectral_truncation proc~spectral_truncation->proc~spec_to_grid proc~output output proc~output->proc~spec_to_grid proc~initialize_boundaries initialize_boundaries proc~initialize_boundaries->proc~spectral_truncation proc~get_tendencies get_tendencies proc~get_tendencies->proc~get_grid_point_tendencies proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_from_rest_state->proc~output proc~initialize_prognostics initialize_prognostics proc~initialize_prognostics->proc~initialize_from_rest_state proc~initialize initialize proc~initialize->proc~initialize_boundaries proc~initialize->proc~initialize_prognostics proc~first_step first_step proc~initialize->proc~first_step proc~step step proc~step->proc~get_tendencies program~speedy speedy program~speedy->proc~initialize program~speedy->proc~step proc~first_step->proc~step var panproclegendre_invCalledByGraph = svgPanZoom('#proclegendre_invCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/legendre_inv.html"},{"title":"legendre_dir – SPEEDY.f90","text":"public function legendre_dir(input) result(output) Computes direct Legendre transformation. Arguments Type Intent Optional Attributes Name real, intent(in) :: input (2*mx,il) Input field Return Value real\n  (2*mx,nx) Output field Called by proc~~legendre_dir~~CalledByGraph proc~legendre_dir legendre_dir proc~grid_to_spec grid_to_spec proc~grid_to_spec->proc~legendre_dir proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_grid_point_tendencies->proc~grid_to_spec proc~set_forcing set_forcing proc~set_forcing->proc~grid_to_spec proc~vdspec vdspec proc~vdspec->proc~grid_to_spec proc~spectral_truncation spectral_truncation proc~spectral_truncation->proc~grid_to_spec proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_from_rest_state->proc~grid_to_spec proc~initialize initialize proc~initialize->proc~set_forcing proc~initialize_prognostics initialize_prognostics proc~initialize->proc~initialize_prognostics proc~initialize_boundaries initialize_boundaries proc~initialize->proc~initialize_boundaries proc~first_step first_step proc~initialize->proc~first_step proc~get_tendencies get_tendencies proc~get_tendencies->proc~get_grid_point_tendencies program~speedy speedy program~speedy->proc~set_forcing program~speedy->proc~initialize proc~step step program~speedy->proc~step proc~initialize_prognostics->proc~initialize_from_rest_state proc~initialize_boundaries->proc~spectral_truncation proc~step->proc~get_tendencies proc~first_step->proc~step var panproclegendre_dirCalledByGraph = svgPanZoom('#proclegendre_dirCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/legendre_dir.html"},{"title":"get_weights – SPEEDY.f90","text":"private function get_weights() result(w) Compute Gaussian weights for direct Legendre transform Arguments None Return Value real\n  (iy) Weights in gaussian quadrature (sum should equal 1.0) Called by proc~~get_weights~~CalledByGraph proc~get_weights get_weights proc~initialize_legendre initialize_legendre proc~initialize_legendre->proc~get_weights proc~initialize_spectral initialize_spectral proc~initialize_spectral->proc~initialize_legendre proc~initialize initialize proc~initialize->proc~initialize_spectral program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_weights.html"},{"title":"get_legendre_poly – SPEEDY.f90","text":"private function get_legendre_poly(j) result(poly) Uses geometry proc~~get_legendre_poly~~UsesGraph proc~get_legendre_poly get_legendre_poly module~geometry geometry proc~get_legendre_poly->module~geometry module~params params module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute associated Legendre polynomials at given latitude. Arguments Type Intent Optional Attributes Name integer, intent(in) :: j The latitude to compute the polynomials at Return Value real\n  (mx,nx) The Legendre polynomials Calls proc~~get_legendre_poly~~CallsGraph proc~get_legendre_poly get_legendre_poly float float proc~get_legendre_poly->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_legendre_poly~~CalledByGraph proc~get_legendre_poly get_legendre_poly proc~initialize_legendre initialize_legendre proc~initialize_legendre->proc~get_legendre_poly proc~initialize_spectral initialize_spectral proc~initialize_spectral->proc~initialize_legendre proc~initialize initialize proc~initialize->proc~initialize_spectral program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_legendre_poly.html"},{"title":"initialize_legendre – SPEEDY.f90","text":"public subroutine initialize_legendre() Uses physical_constants proc~~initialize_legendre~~UsesGraph proc~initialize_legendre initialize_legendre module~physical_constants physical_constants proc~initialize_legendre->module~physical_constants module~params params module~physical_constants->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Initializes Legendre transforms and constants used for other subroutines\n  that manipulate spherical harmonics. Arguments None Calls proc~~initialize_legendre~~CallsGraph proc~initialize_legendre initialize_legendre proc~get_legendre_poly get_legendre_poly proc~initialize_legendre->proc~get_legendre_poly proc~get_weights get_weights proc~initialize_legendre->proc~get_weights float float proc~initialize_legendre->float proc~get_legendre_poly->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initialize_legendre~~CalledByGraph proc~initialize_legendre initialize_legendre proc~initialize_spectral initialize_spectral proc~initialize_spectral->proc~initialize_legendre proc~initialize initialize proc~initialize->proc~initialize_spectral program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize_legendre.html"},{"title":"fourier_inv – SPEEDY.f90","text":"public function fourier_inv(input, kcos) result(output) Uses geometry proc~~fourier_inv~~UsesGraph proc~fourier_inv fourier_inv module~geometry geometry proc~fourier_inv->module~geometry module~params params module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Transforms Fourier coefficients to grid-point data. Arguments Type Intent Optional Attributes Name real, intent(in) :: input (2*mx,il) Input field integer, intent(in) :: kcos Scale output by cos(lat) (1) or not (0) Return Value real\n  (ix,il) Output field Calls proc~~fourier_inv~~CallsGraph proc~fourier_inv fourier_inv proc~rfftb1 rfftb1 proc~fourier_inv->proc~rfftb1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fourier_inv~~CalledByGraph proc~fourier_inv fourier_inv proc~spec_to_grid spec_to_grid proc~spec_to_grid->proc~fourier_inv proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_grid_point_tendencies->proc~spec_to_grid proc~gen_sppt gen_sppt proc~gen_sppt->proc~spec_to_grid proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->proc~spec_to_grid proc~get_physical_tendencies->proc~gen_sppt proc~spectral_truncation spectral_truncation proc~spectral_truncation->proc~spec_to_grid proc~output output proc~output->proc~spec_to_grid proc~initialize_boundaries initialize_boundaries proc~initialize_boundaries->proc~spectral_truncation proc~get_tendencies get_tendencies proc~get_tendencies->proc~get_grid_point_tendencies proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_from_rest_state->proc~output proc~initialize_prognostics initialize_prognostics proc~initialize_prognostics->proc~initialize_from_rest_state proc~initialize initialize proc~initialize->proc~initialize_boundaries proc~initialize->proc~initialize_prognostics proc~first_step first_step proc~initialize->proc~first_step proc~step step proc~step->proc~get_tendencies program~speedy speedy program~speedy->proc~initialize program~speedy->proc~step proc~first_step->proc~step var panprocfourier_invCalledByGraph = svgPanZoom('#procfourier_invCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fourier_inv.html"},{"title":"fourier_dir – SPEEDY.f90","text":"public function fourier_dir(input) result(output) Transforms grid-point data to Fourier coefficients. Arguments Type Intent Optional Attributes Name real, intent(in) :: input (ix,il) Input field Return Value real\n  (2*mx,il) Output field Calls proc~~fourier_dir~~CallsGraph proc~fourier_dir fourier_dir proc~rfftf1 rfftf1 proc~fourier_dir->proc~rfftf1 float float proc~fourier_dir->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fourier_dir~~CalledByGraph proc~fourier_dir fourier_dir proc~grid_to_spec grid_to_spec proc~grid_to_spec->proc~fourier_dir proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_grid_point_tendencies->proc~grid_to_spec proc~set_forcing set_forcing proc~set_forcing->proc~grid_to_spec proc~vdspec vdspec proc~vdspec->proc~grid_to_spec proc~spectral_truncation spectral_truncation proc~spectral_truncation->proc~grid_to_spec proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_from_rest_state->proc~grid_to_spec proc~initialize initialize proc~initialize->proc~set_forcing proc~initialize_prognostics initialize_prognostics proc~initialize->proc~initialize_prognostics proc~initialize_boundaries initialize_boundaries proc~initialize->proc~initialize_boundaries proc~first_step first_step proc~initialize->proc~first_step proc~get_tendencies get_tendencies proc~get_tendencies->proc~get_grid_point_tendencies program~speedy speedy program~speedy->proc~set_forcing program~speedy->proc~initialize proc~step step program~speedy->proc~step proc~initialize_prognostics->proc~initialize_from_rest_state proc~initialize_boundaries->proc~spectral_truncation proc~step->proc~get_tendencies proc~first_step->proc~step var panprocfourier_dirCalledByGraph = svgPanZoom('#procfourier_dirCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fourier_dir.html"},{"title":"initialize_fourier – SPEEDY.f90","text":"public subroutine initialize_fourier() Initializes the Fourier transforms. Arguments None Calls proc~~initialize_fourier~~CallsGraph proc~initialize_fourier initialize_fourier proc~rffti1 rffti1 proc~initialize_fourier->proc~rffti1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~initialize_fourier~~CalledByGraph proc~initialize_fourier initialize_fourier proc~initialize_spectral initialize_spectral proc~initialize_spectral->proc~initialize_fourier proc~initialize initialize proc~initialize->proc~initialize_spectral program~speedy speedy program~speedy->proc~initialize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize_fourier.html"},{"title":"auxiliaries – SPEEDY.f90","text":"For storing variables used by multiple physics schemes. Uses params module~~auxiliaries~~UsesGraph module~auxiliaries auxiliaries module~params params module~auxiliaries->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~auxiliaries~~UsedByGraph module~auxiliaries auxiliaries proc~run_land_model run_land_model proc~run_land_model->module~auxiliaries proc~run_sea_model run_sea_model proc~run_sea_model->module~auxiliaries proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->module~auxiliaries Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables precnv precls snowcv snowls cbmf tsr ssrd ssr slrd slr olr slru ustr vstr shf evap hfluxn Variables Type Visibility Attributes Name Initial real, public, dimension(ix,il) :: precnv Convective precipitation  [g/(m&#94;2 s)], total real, public, dimension(ix,il) :: precls Large-scale precipitation [g/(m&#94;2 s)], total real, public, dimension(ix,il) :: snowcv Convective precipitation  [g/(m&#94;2 s)], snow only real, public, dimension(ix,il) :: snowls Large-scale precipitation [g/(m&#94;2 s)], snow only real, public, dimension(ix,il) :: cbmf Cloud-base mass flux real, public, dimension(ix,il) :: tsr Top-of-atmosphere shortwave radiation (downward) real, public, dimension(ix,il) :: ssrd Surface shortwave radiation (downward-only) real, public, dimension(ix,il) :: ssr Surface shortwave radiation (net downward) real, public, dimension(ix,il) :: slrd Surface longwave radiation (downward-only) real, public, dimension(ix,il) :: slr Surface longwave radiation (net upward) real, public, dimension(ix,il) :: olr Outgoing longwave radiation (upward) real, public, dimension(ix,il,3) :: slru Surface longwave emission (upward) real, public, dimension(ix,il,3) :: ustr U-stress real, public, dimension(ix,il,3) :: vstr V-stress real, public, dimension(ix,il,3) :: shf Sensible heat flux real, public, dimension(ix,il,3) :: evap Evaporation [g/(m&#94;2 s)] real, public, dimension(ix,il,3) :: hfluxn Net heat flux into surface","tags":"","loc":"module/auxiliaries.html"},{"title":"dynamical_constants – SPEEDY.f90","text":"Constants for initialization of dynamics. Used by module~~dynamical_constants~~UsedByGraph module~dynamical_constants dynamical_constants proc~step step proc~step->module~dynamical_constants proc~set_forcing set_forcing proc~set_forcing->module~dynamical_constants proc~initialize_horizontal_diffusion initialize_horizontal_diffusion proc~initialize_horizontal_diffusion->module~dynamical_constants proc~initialize_implicit initialize_implicit proc~initialize_implicit->module~dynamical_constants proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_from_rest_state->module~dynamical_constants proc~setgam setgam proc~setgam->module~dynamical_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables gamma hscale hshum refrh1 thd thdd thds tdrs Variables Type Visibility Attributes Name Initial real, public, parameter :: gamma = 6.0 real, public, parameter :: hscale = 7.5 real, public, parameter :: hshum = 2.5 real, public, parameter :: refrh1 = 0.7 real, public, parameter :: thd = 2.4 real, public, parameter :: thdd = 2.4 real, public, parameter :: thds = 12.0 real, public, parameter :: tdrs = 24.0*30.0","tags":"","loc":"module/dynamical_constants.html"},{"title":"geopotential – SPEEDY.f90","text":"For performing geopotential calculations. Uses params module~~geopotential~~UsesGraph module~geopotential geopotential module~params params module~geopotential->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~geopotential~~UsedByGraph module~geopotential geopotential proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_grid_point_tendencies->module~geopotential proc~initialize initialize proc~initialize->module~geopotential proc~get_spectral_tendencies get_spectral_tendencies proc~get_spectral_tendencies->module~geopotential Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables xgeop1 xgeop2 Functions get_geopotential Subroutines initialize_geopotential Variables Type Visibility Attributes Name Initial real, private :: xgeop1 (kx) Constants for hydrostatic equation real, private :: xgeop2 (kx) Constants for hydrostatic equation Functions public function get_geopotential (t, phis) result(phi) Computes spectral geopotential from spectral temperature T and spectral\n  topography phis, as in GFDL Climate Group GCM. Arguments Type Intent Optional Attributes Name complex, intent(in) :: t (mx,nx,kx) Spectral temperature complex, intent(in) :: phis (mx,nx) Spectral surface geopotential Return Value complex\n  (mx,nx,kx) Spectral geopotential Subroutines public subroutine initialize_geopotential () Initializes the arrays used for geopotential calculations Arguments None","tags":"","loc":"module/geopotential.html"},{"title":"interpolation – SPEEDY.f90","text":"For interpolating fields in time. Uses date params module~~interpolation~~UsesGraph module~interpolation interpolation module~params params module~interpolation->module~params module~date date module~interpolation->module~date Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~interpolation~~UsedByGraph module~interpolation interpolation proc~couple_land_atm couple_land_atm proc~couple_land_atm->module~interpolation proc~couple_sea_atm couple_sea_atm proc~couple_sea_atm->module~interpolation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines forint forin5 Subroutines public subroutine forint (imon, for12, for1) Performs linear interpolation of monthly-mean forcing fields. Arguments Type Intent Optional Attributes Name integer, intent(in) :: imon The month real, intent(in) :: for12 (ix*il,*) The input field real, intent(inout) :: for1 (ix*il) The output field public subroutine forin5 (imon, for12, for1) Performs nonlinear, mean-conserving interpolation of monthly-mean forcing fields. Arguments Type Intent Optional Attributes Name integer, intent(in) :: imon The month real, intent(in) :: for12 (ix*il,12) The input field real, intent(inout) :: for1 (ix*il) The output field","tags":"","loc":"module/interpolation.html"},{"title":"input_output – SPEEDY.f90","text":"For performing input and output. Uses netcdf params module~~input_output~~UsesGraph module~input_output input_output module~params params module~input_output->module~params netcdf netcdf module~input_output->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~input_output~~UsedByGraph module~input_output input_output proc~initialize initialize proc~initialize->module~input_output proc~sea_model_init sea_model_init proc~sea_model_init->module~input_output proc~obs_ssta obs_ssta proc~obs_ssta->module~input_output proc~land_model_init land_model_init proc~land_model_init->module~input_output proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_from_rest_state->module~input_output program~speedy speedy program~speedy->module~input_output proc~initialize_boundaries initialize_boundaries proc~initialize_boundaries->module~input_output Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces load_boundary_file Functions load_boundary_file_2d load_boundary_file_one_month_from_year load_boundary_file_one_month_from_long Subroutines output check Interfaces public interface load_boundary_file Interface for reading boundary files. private function load_boundary_file_2d (file_name, field_name) result(field) Loads the given 2D field from the given boundary file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name The NetCDF file to read from character(len=*), intent(in) :: field_name The field to read Return Value real,\n  dimension(ix,il) private function load_boundary_file_one_month_from_year (file_name, field_name, month) result(field) Loads the given 2D field at the given month from the given monthly\n  boundary file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name The NetCDF file to read from character(len=*), intent(in) :: field_name The field to read integer, intent(in) :: month The month to read Return Value real,\n  dimension(ix,il) private function load_boundary_file_one_month_from_long (file_name, field_name, month, length) result(field) Loads the given 2D field at the given month from the given boundary file\n  of a given length. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name The NetCDF file to read from character(len=*), intent(in) :: field_name The field to read integer, intent(in) :: month The month to read integer, intent(in) :: length The total length of the file in number of\n months Return Value real,\n  dimension(ix,il) Functions private function load_boundary_file_2d (file_name, field_name) result(field) Loads the given 2D field from the given boundary file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name The NetCDF file to read from character(len=*), intent(in) :: field_name The field to read Return Value real,\n  dimension(ix,il) private function load_boundary_file_one_month_from_year (file_name, field_name, month) result(field) Loads the given 2D field at the given month from the given monthly\n  boundary file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name The NetCDF file to read from character(len=*), intent(in) :: field_name The field to read integer, intent(in) :: month The month to read Return Value real,\n  dimension(ix,il) private function load_boundary_file_one_month_from_long (file_name, field_name, month, length) result(field) Loads the given 2D field at the given month from the given boundary file\n  of a given length. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name The NetCDF file to read from character(len=*), intent(in) :: field_name The field to read integer, intent(in) :: month The month to read integer, intent(in) :: length The total length of the file in number of\n months Return Value real,\n  dimension(ix,il) Subroutines public subroutine output (timestep, vor, div, t, ps, tr, phi) Writes a snapshot of all prognostic variables to a NetCDF file. Arguments Type Intent Optional Attributes Name integer, intent(in) :: timestep The time step that is being written complex, intent(in) :: vor (mx,nx,kx,2) Vorticity complex, intent(in) :: div (mx,nx,kx,2) Divergence complex, intent(in) :: t (mx,nx,kx,2) Temperature complex, intent(in) :: ps (mx,nx,2) log(normalized surface pressure) complex, intent(in) :: tr (mx,nx,kx,2,ntr) Tracers complex, intent(in) :: phi (mx,nx,kx) Geopotential private subroutine check (ierr) Handles any errors from the NetCDF API. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ierr","tags":"","loc":"module/input_output.html"},{"title":"sppt – SPEEDY.f90","text":"For computing stochastically perturbed parametrization tendency (SPPT)\n  patterns. To be used as multiplicative noise applied to physical tendencies. SPPT is\n  a parametrization of model error.\n  See ECMWF Tech. Memo. #598 (Palmer et al. 2009). Uses params module~~sppt~~UsesGraph module~sppt sppt module~params params module~sppt->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~sppt~~UsedByGraph module~sppt sppt proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->module~sppt Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables mu sppt_spec first time_decorr phi len_decorr stddev sigma Functions gen_sppt randn Subroutines time_seed Variables Type Visibility Attributes Name Initial real, public :: mu (kx) = (/1, 1, 1, 1, 1, 1, 1, 1/) Array for tapering value of SPPT in the different layers of the\n  atmosphere. A value of 1 means the tendency is not tapered at that level complex, private :: sppt_spec (mx,nx,kx) SPPT pattern in spectral space logical, private :: first = .true. Flag for controlling first-use behaviour real, private, parameter :: time_decorr = 6.0 Decorrelation time of SPPT perturbation (in hours) real, private :: phi = exp(-(24/real(nsteps))/time_decorr) Time autocorrelation of spectral AR(1) signals real, private, parameter :: len_decorr = 500000.0 Correlation length scale of SPPT perturbation (in metres) real, private, parameter :: stddev = 0.33 Standard deviation of SPPT perturbation (in grid point space) real, private :: sigma (mx,nx,kx) Total wavenumber-wise standard deviation of spectral signals Functions public function gen_sppt () result(sppt_grid) Generate grid point space SPPT pattern distribution. Arguments None Return Value real\n  (ix,il,kx) The generated grid point pattern private function randn (mean, stdev) Generates a random number drawn for the specified normal distribution. Arguments Type Intent Optional Attributes Name real, intent(in) :: mean The mean of the distribution to draw from real, intent(in) :: stdev The standard deviation of the distribution to draw from Return Value real The generated random number Subroutines private subroutine time_seed () Seeds RNG from system clock. Arguments None","tags":"","loc":"module/sppt.html"},{"title":"convection – SPEEDY.f90","text":"Parametrization of convection Convection is modelled using a simplified version of the Tiedke (1993)\n  mass-flux convection scheme. Uses params module~~convection~~UsesGraph module~convection convection module~params params module~convection->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~convection~~UsedByGraph module~convection convection proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->module~convection Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables psmin trcnv rhbl rhil entmax smf Subroutines get_convection_tendencies diagnose_convection Variables Type Visibility Attributes Name Initial real, private, parameter :: psmin = 0.8 Minimum (normalised) surface pressure for the occurrence of\n convection real, private, parameter :: trcnv = 6.0 Time of relaxation (in hours) towards reference state real, private, parameter :: rhbl = 0.9 Relative humidity threshold in the boundary layer real, private, parameter :: rhil = 0.7 Relative humidity threshold in intermeduate layers for\n secondary mass flux real, private, parameter :: entmax = 0.5 Maximum entrainment as a fraction of cloud-base mass flux real, private, parameter :: smf = 0.8 Ratio between secondary and primary mass flux at cloud-base Subroutines public subroutine get_convection_tendencies (psa, se, qa, qsat, itop, cbmf, precnv, dfse, dfqa) Compute convective fluxes of dry static energy and moisture using a\n  simplified mass-flux scheme Arguments Type Intent Optional Attributes Name real, intent(in) :: psa (ix,il) Normalised surface pressure [p/p0] real, intent(in) :: se (ix,il,kx) Dry static energy [c_p.T + g.z] real, intent(in) :: qa (ix,il,kx) Specific humidity [g/kg] real, intent(in) :: qsat (ix,il,kx) Saturation specific humidity [g/kg] integer, intent(out) :: itop (ix,il) Top of convection (layer index) real, intent(out) :: cbmf (ix,il) Cloud-base mass flux real, intent(out) :: precnv (ix,il) Convective precipitation [g/(m&#94;2 s)] real, intent(out) :: dfse (ix,il,kx) Net flux of dry static energy into each atmospheric\n layer real, intent(out) :: dfqa (ix,il,kx) Net flux of specific humidity into each atmospheric\n layer private subroutine diagnose_convection (psa, se, qa, qsat, itop, qdif) Diagnose convectively unstable gridboxes Read more… Arguments Type Intent Optional Attributes Name real, intent(in) :: psa (ix,il) Normalised surface pressure [p/p0] real, intent(in) :: se (ix,il,kx) Dry static energy [c_p.T + g.z] real, intent(in) :: qa (ix,il,kx) Specific humidity [g/kg] real, intent(in) :: qsat (ix,il,kx) Saturation specific humidity [g/kg] integer, intent(out) :: itop (ix,il) Top of convection (layer index) real, intent(out) :: qdif (ix,il) Excess humidity in convective gridboxes","tags":"","loc":"module/convection.html"},{"title":"large_scale_condensation – SPEEDY.f90","text":"Parametrization of large-scale condensation Large-scale condensation is modelled as a relaxation of humidity to a\n  sigma-dependent threshold value RH(\\sigma) . \\frac{\\partial q}{\\partial t} =\n      -\\frac{q - RH(\\sigma) q_{sat}}{\\tau_{lsc}}, where \\tau_{lsc} is the relaxation timescale. The temperature tendency is\n  computed as the resultant latent heating, \\frac{\\partial T}{\\partial t} =\n      - \\frac{L}{c_p} \\frac{\\partial q}{\\partial t}. Precipitation is diagnosed as all the moisture lost to condensation falling\n  out of the atmospheric column in the timestep, P = -\\frac{1}{g} \\sum_{k=2}&#94;N \\Delta p \\frac{\\partial q}{\\partial t}. Uses params module~~large_scale_condensation~~UsesGraph module~large_scale_condensation large_scale_condensation module~params params module~large_scale_condensation->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~large_scale_condensation~~UsedByGraph module~large_scale_condensation large_scale_condensation proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->module~large_scale_condensation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables trlsc rhlsc drhlsc rhblsc Subroutines get_large_scale_condensation_tendencies Variables Type Visibility Attributes Name Initial real, private, parameter :: trlsc = 4.0 Relaxation time (in hours) for specific humidity real, private, parameter :: rhlsc = 0.9 Maximum relative humidity threshold (at sigma=1) real, private, parameter :: drhlsc = 0.1 Vertical range of relative humidity threshold real, private, parameter :: rhblsc = 0.95 Relative humidity threshold for boundary layer Subroutines public subroutine get_large_scale_condensation_tendencies (psa, qa, qsat, itop, precls, dtlsc, dqlsc) Compute large-scale condensation and associated tendencies of temperature\n  and moisture Arguments Type Intent Optional Attributes Name real, intent(in) :: psa (ix,il) Normalised surface pressure [p/p0] real, intent(in) :: qa (ix,il,kx) Specific humidity [g/kg] real, intent(in) :: qsat (ix,il,kx) Saturation specific humidity [g/kg] integer, intent(inout) :: itop (ix,il) Cloud top diagnosed from precipitation due to\n convection and large-scale condensation real, intent(out) :: precls (ix,il) Precipitation due to large-scale condensation real, intent(out) :: dtlsc (ix,il,kx) Temperature tendency due to large-scale\n condensation real, intent(out) :: dqlsc (ix,il,kx) Specific humidity tendency due to large-scale\n condensation","tags":"","loc":"module/large_scale_condensation.html"},{"title":"longwave_radiation – SPEEDY.f90","text":"Parametrization of long-wave radiation Uses params module~~longwave_radiation~~UsesGraph module~longwave_radiation longwave_radiation module~params params module~longwave_radiation->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~longwave_radiation~~UsedByGraph module~longwave_radiation longwave_radiation proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->module~longwave_radiation proc~set_forcing set_forcing proc~set_forcing->module~longwave_radiation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables nband Subroutines get_downward_longwave_rad_fluxes get_upward_longwave_rad_fluxes radset Variables Type Visibility Attributes Name Initial integer, private, parameter :: nband = 4 Subroutines public subroutine get_downward_longwave_rad_fluxes (ta, fsfcd, dfabs) Compute the downward flux of long-wave radiation Arguments Type Intent Optional Attributes Name real, intent(in) :: ta (ix,il,kx) Absolute temperature [K] real, intent(out) :: fsfcd (ix,il) Downward flux of long-wave radiation at the surface real, intent(out) :: dfabs (ix,il,kx) Flux of long-wave radiation absorbed in each\n atmospheric layer public subroutine get_upward_longwave_rad_fluxes (ta, ts, fsfcd, fsfcu, fsfc, ftop, dfabs) Compute the absorption of upward long-wave radiation fluxes Arguments Type Intent Optional Attributes Name real, intent(in) :: ta (ix,il,kx) Absolute temperature real, intent(in) :: ts (ix,il) Surface temperature real, intent(in) :: fsfcd (ix,il) Downward flux of long-wave radiation at the\n surface real, intent(in) :: fsfcu (ix,il) Surface blackbody emission real, intent(out) :: fsfc (ix,il) Net upward flux of long-wave radiation at the\n surface real, intent(out) :: ftop (ix,il) Outgoing flux of long-wave radiation at the\n top of the atmosphere real, intent(inout) :: dfabs (ix,il,kx) Flux of long-wave radiation absorbed in each\n atmospheric layer public subroutine radset () Compute energy fractions in longwave bands as a function of temperature Arguments None","tags":"","loc":"module/longwave_radiation.html"},{"title":"forcing – SPEEDY.f90","text":"For setting all time-dependent forcing fields. Used by module~~forcing~~UsedByGraph module~forcing forcing program~speedy speedy program~speedy->module~forcing proc~initialize initialize proc~initialize->module~forcing Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines set_forcing setgam Subroutines public subroutine set_forcing (imode) Compute forcing fields for the current date and correction terms for\n  horizontal diffusion Arguments Type Intent Optional Attributes Name integer, intent(in) :: imode Mode -> 0 = initialization step, 1 = daily update private subroutine setgam (gamlat) Compute reference lapse rate as a function of latitude and date Arguments Type Intent Optional Attributes Name real, intent(inout) :: gamlat (il) The reference lapse rate","tags":"","loc":"module/forcing.html"},{"title":"implicit – SPEEDY.f90","text":"For initializing and performing implicit computations. Uses params module~~implicit~~UsesGraph module~implicit implicit module~params params module~implicit->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~implicit~~UsedByGraph module~implicit implicit proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_grid_point_tendencies->module~implicit proc~get_spectral_tendencies get_spectral_tendencies proc~get_spectral_tendencies->module~implicit proc~get_tendencies get_tendencies proc~get_tendencies->module~implicit proc~first_step first_step proc~first_step->module~implicit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables tref tref1 tref2 tref3 xa xb xc xd xe xf xj dhsx elz Subroutines initialize_implicit implicit_terms Variables Type Visibility Attributes Name Initial real, public, dimension(kx) :: tref real, private, dimension(kx) :: tref1 real, public, dimension(kx) :: tref2 real, public, dimension(kx) :: tref3 real, private, dimension(kx,kx) :: xa real, private, dimension(kx,kx) :: xb real, private, dimension(kx,kx) :: xc real, private, dimension(kx,kx) :: xd real, private, dimension(kx,kx) :: xe real, private, dimension(kx,kx,mx+nx+1) :: xf real, private, dimension(kx,kx,mx+nx+1) :: xj real, private :: dhsx (kx) real, private :: elz (mx,nx) Subroutines public subroutine initialize_implicit (dt) Initialize constants for implicit computation of horizontal diffusion and\n  gravity waves. Read more… Arguments Type Intent Optional Attributes Name real, intent(in) :: dt Time step public subroutine implicit_terms (divdt, tdt, psdt) Correct tendencies for implicit gravity wave model Arguments Type Intent Optional Attributes Name complex, intent(inout) :: divdt (mx,nx,kx) Divergence tendency complex, intent(inout) :: tdt (mx,nx,kx) Temperature tendency complex, intent(inout) :: psdt (mx,nx) log(surface pressure) tendency","tags":"","loc":"module/implicit.html"},{"title":"boundaries – SPEEDY.f90","text":"For reading and storing boundary conditions. This module handles the reading and storing of the land-sea mask, the\n  surface geopotential (i.e. the orography), the filtered surface geopotential\n  (i.e. the smoothed orography) and the bare-land annual-mean albedo. Uses params module~~boundaries~~UsesGraph module~boundaries boundaries module~params params module~boundaries->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~boundaries~~UsedByGraph module~boundaries boundaries proc~initialize initialize proc~initialize->module~boundaries proc~set_forcing set_forcing proc~set_forcing->module~boundaries proc~sea_model_init sea_model_init proc~sea_model_init->module~boundaries proc~obs_ssta obs_ssta proc~obs_ssta->module~boundaries proc~land_model_init land_model_init proc~land_model_init->module~boundaries proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->module~boundaries proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_from_rest_state->module~boundaries Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables fmask phi0 phis0 alb0 Subroutines initialize_boundaries forchk spectral_truncation fillsf Variables Type Visibility Attributes Name Initial real, public :: fmask (ix,il) Original (fractional) land-sea mask real, public :: phi0 (ix,il) Unfiltered surface geopotential real, public :: phis0 (ix,il) Spectrally-filtered surface geopotential real, public :: alb0 (ix,il) Bare-land annual-mean albedo Subroutines public subroutine initialize_boundaries () Initialize boundary conditions (land-sea mask, surface geopotential\n  and surface albedo). Arguments None public subroutine forchk (fmask, nf, fmin, fmax, fset, field) Check consistency of surface fields with land-sea mask and set undefined\n  values to a constant (to avoid over/underflow). Arguments Type Intent Optional Attributes Name real, intent(in) :: fmask (ix,il) The fractional land-sea mask integer, intent(in) :: nf The number of input 2D fields real, intent(in) :: fmin The minimum allowable value real, intent(in) :: fmax The maximum allowable value real, intent(in) :: fset Replacement for undefined values real, intent(inout) :: field (ix,il,nf) The output field private subroutine spectral_truncation (fg1, fg2) Compute a spectrally-filtered grid-point field. Arguments Type Intent Optional Attributes Name real, intent(inout) :: fg1 (ix,il) Original grid-point field real, intent(inout) :: fg2 (ix,il) Filtered grid-point field public subroutine fillsf (sf, fmis) Replace missing values in surface fields. Read more… Arguments Type Intent Optional Attributes Name real, intent(inout) :: sf (ix,il) Field to replace missing values in real, intent(in) :: fmis Replacement for missing values","tags":"","loc":"module/boundaries.html"},{"title":"coupler – SPEEDY.f90","text":"Highest level interface to land and sea models. Used by module~~coupler~~UsedByGraph module~coupler coupler program~speedy speedy program~speedy->module~coupler proc~initialize initialize proc~initialize->module~coupler Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines initialize_coupler couple_sea_land Subroutines public subroutine initialize_coupler () Initialize both land and sea models. Arguments None public subroutine couple_sea_land (day) Exchange fluxes between atmosphere and land/sea. Arguments Type Intent Optional Attributes Name integer, intent(in) :: day The current day of the model integration (starting from 0)","tags":"","loc":"module/coupler.html"},{"title":"diagnostics – SPEEDY.f90","text":"For checking model diagnostics in case of numerical instability. Used by module~~diagnostics~~UsedByGraph module~diagnostics diagnostics program~speedy speedy program~speedy->module~diagnostics proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_from_rest_state->module~diagnostics Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines check_diagnostics Subroutines public subroutine check_diagnostics (vor, div, t, istep) Prints global means of eddy kinetic energy and temperature.\n  Also stops the integration if the computed diagnostics are outside of\n  allowable ranges. Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(mx,nx,kx) :: vor Spectral vorticity complex, intent(in), dimension(mx,nx,kx) :: div Spectral divergence complex, intent(in), dimension(mx,nx,kx) :: t Spectral temperature integer, intent(in) :: istep Current time step","tags":"","loc":"module/diagnostics.html"},{"title":"prognostics – SPEEDY.f90","text":"Uses params module~~prognostics~~UsesGraph module~prognostics prognostics module~params params module~prognostics->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~prognostics~~UsedByGraph module~prognostics prognostics proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_grid_point_tendencies->module~prognostics proc~initialize initialize proc~initialize->module~prognostics proc~step step proc~step->module~prognostics program~speedy speedy program~speedy->module~prognostics proc~get_spectral_tendencies get_spectral_tendencies proc~get_spectral_tendencies->module~prognostics Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables vor div t ps tr phi phis Subroutines initialize_prognostics initialize_from_rest_state Variables Type Visibility Attributes Name Initial complex, public :: vor (mx,nx,kx,2) complex, public :: div (mx,nx,kx,2) complex, public :: t (mx,nx,kx,2) complex, public :: ps (mx,nx,2) complex, public :: tr (mx,nx,kx,2,ntr) complex, public :: phi (mx,nx,kx) complex, public :: phis (mx,nx) Subroutines public subroutine initialize_prognostics () Arguments None private subroutine initialize_from_rest_state () Arguments None","tags":"","loc":"module/prognostics.html"},{"title":"params – SPEEDY.f90","text":"Used by module~~params~~UsedByGraph module~params params proc~initialize_date initialize_date proc~initialize_date->module~params proc~check_diagnostics check_diagnostics proc~check_diagnostics->module~params module~spectral spectral proc~check_diagnostics->module~spectral module~auxiliaries auxiliaries module~auxiliaries->module~params module~sea_model sea_model module~sea_model->module~params module~geometry geometry module~geometry->module~params module~implicit implicit module~implicit->module~params module~time_stepping time_stepping module~time_stepping->module~params module~geopotential geopotential module~geopotential->module~params module~physics physics module~physics->module~params module~prognostics prognostics module~prognostics->module~params module~land_model land_model module~land_model->module~params module~input_output input_output module~input_output->module~params program~speedy speedy program~speedy->module~params program~speedy->module~time_stepping program~speedy->module~prognostics program~speedy->module~input_output module~shortwave_radiation shortwave_radiation program~speedy->module~shortwave_radiation proc~setgam setgam proc~setgam->module~params module~physical_constants physical_constants proc~setgam->module~physical_constants module~mod_radcon mod_radcon module~mod_radcon->module~params module~tendencies tendencies module~tendencies->module~params module~interpolation interpolation module~interpolation->module~params module~legendre legendre module~legendre->module~params module~shortwave_radiation->module~params proc~set_forcing set_forcing proc~set_forcing->module~params proc~set_forcing->module~sea_model proc~set_forcing->module~land_model proc~set_forcing->module~mod_radcon proc~set_forcing->module~shortwave_radiation module~humidity humidity proc~set_forcing->module~humidity proc~set_forcing->module~spectral proc~set_forcing->module~physical_constants module~surface_fluxes surface_fluxes proc~set_forcing->module~surface_fluxes module~horizontal_diffusion horizontal_diffusion proc~set_forcing->module~horizontal_diffusion module~boundaries boundaries proc~set_forcing->module~boundaries module~longwave_radiation longwave_radiation proc~set_forcing->module~longwave_radiation module~humidity->module~params module~spectral->module~params module~convection convection module~convection->module~params module~vertical_diffusion vertical_diffusion module~vertical_diffusion->module~params proc~newdate newdate proc~newdate->module~params module~sppt sppt module~sppt->module~params module~fourier fourier module~fourier->module~params proc~initialize initialize proc~initialize->module~params proc~initialize->module~sea_model proc~initialize->module~geometry proc~initialize->module~time_stepping proc~initialize->module~geopotential proc~initialize->module~physics proc~initialize->module~prognostics proc~initialize->module~input_output proc~initialize->module~spectral proc~initialize->module~horizontal_diffusion proc~initialize->module~boundaries module~physical_constants->module~params module~surface_fluxes->module~params module~horizontal_diffusion->module~params module~boundaries->module~params module~large_scale_condensation large_scale_condensation module~large_scale_condensation->module~params module~longwave_radiation->module~params proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_grid_point_tendencies->module~geometry proc~get_grid_point_tendencies->module~implicit proc~get_grid_point_tendencies->module~geopotential proc~get_grid_point_tendencies->module~physics proc~get_grid_point_tendencies->module~prognostics proc~get_grid_point_tendencies->module~spectral proc~get_grid_point_tendencies->module~physical_constants proc~run_land_model run_land_model proc~run_land_model->module~auxiliaries proc~get_shortwave_rad_fluxes get_shortwave_rad_fluxes proc~get_shortwave_rad_fluxes->module~geometry proc~get_shortwave_rad_fluxes->module~mod_radcon proc~get_upward_longwave_rad_fluxes get_upward_longwave_rad_fluxes proc~get_upward_longwave_rad_fluxes->module~geometry proc~get_upward_longwave_rad_fluxes->module~mod_radcon proc~couple_land_atm couple_land_atm proc~couple_land_atm->module~interpolation proc~couple_sea_atm couple_sea_atm proc~couple_sea_atm->module~interpolation proc~gen_sppt gen_sppt proc~gen_sppt->module~spectral proc~gen_sppt->module~physical_constants proc~set_orog_land_sfc_drag set_orog_land_sfc_drag proc~set_orog_land_sfc_drag->module~physical_constants proc~initialize_implicit initialize_implicit proc~initialize_implicit->module~geometry proc~initialize_implicit->module~physical_constants proc~initialize_implicit->module~horizontal_diffusion proc~get_large_scale_condensation_tendencies get_large_scale_condensation_tendencies proc~get_large_scale_condensation_tendencies->module~geometry proc~get_large_scale_condensation_tendencies->module~physical_constants proc~spectral_truncation spectral_truncation proc~spectral_truncation->module~spectral proc~solar solar proc~solar->module~geometry proc~output output proc~output->module~geometry proc~output->module~spectral proc~output->module~physical_constants proc~run_sea_model run_sea_model proc~run_sea_model->module~auxiliaries proc~run_sea_model->module~mod_radcon proc~run_sea_model->module~physical_constants proc~step step proc~step->module~prognostics proc~step->module~tendencies proc~step->module~horizontal_diffusion proc~diagnose_convection diagnose_convection proc~diagnose_convection->module~physical_constants proc~initialize_geopotential initialize_geopotential proc~initialize_geopotential->module~geometry proc~initialize_geopotential->module~physical_constants proc~sea_model_init sea_model_init proc~sea_model_init->module~geometry proc~sea_model_init->module~input_output proc~sea_model_init->module~boundaries proc~get_convection_tendencies get_convection_tendencies proc~get_convection_tendencies->module~geometry proc~get_convection_tendencies->module~physical_constants proc~radset radset proc~radset->module~mod_radcon proc~get_legendre_poly get_legendre_poly proc~get_legendre_poly->module~geometry proc~couple_sea_land couple_sea_land proc~couple_sea_land->module~sea_model proc~couple_sea_land->module~land_model proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->module~auxiliaries proc~get_physical_tendencies->module~sea_model proc~get_physical_tendencies->module~geometry proc~get_physical_tendencies->module~land_model proc~get_physical_tendencies->module~shortwave_radiation proc~get_physical_tendencies->module~humidity proc~get_physical_tendencies->module~spectral proc~get_physical_tendencies->module~convection proc~get_physical_tendencies->module~vertical_diffusion proc~get_physical_tendencies->module~sppt proc~get_physical_tendencies->module~physical_constants proc~get_physical_tendencies->module~surface_fluxes proc~get_physical_tendencies->module~boundaries proc~get_physical_tendencies->module~large_scale_condensation proc~get_physical_tendencies->module~longwave_radiation proc~get_surface_fluxes get_surface_fluxes proc~get_surface_fluxes->module~geometry proc~get_surface_fluxes->module~land_model proc~get_surface_fluxes->module~mod_radcon proc~get_surface_fluxes->module~humidity proc~get_surface_fluxes->module~physical_constants proc~first_step first_step proc~first_step->module~implicit proc~get_zonal_average_fields get_zonal_average_fields proc~get_zonal_average_fields->module~geometry proc~get_vertical_diffusion_tend get_vertical_diffusion_tend proc~get_vertical_diffusion_tend->module~geometry proc~get_vertical_diffusion_tend->module~physical_constants proc~initialize_boundaries initialize_boundaries proc~initialize_boundaries->module~input_output proc~initialize_boundaries->module~physical_constants proc~step_field_3d step_field_3d proc~step_field_3d->module~spectral proc~vdspec vdspec proc~vdspec->module~geometry proc~initialize_spectral initialize_spectral proc~initialize_spectral->module~legendre proc~initialize_spectral->module~fourier proc~initialize_spectral->module~physical_constants proc~step_field_2d step_field_2d proc~step_field_2d->module~spectral proc~initialize_physics initialize_physics proc~initialize_physics->module~geometry proc~initialize_physics->module~physical_constants proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_from_rest_state->module~geometry proc~initialize_from_rest_state->module~input_output proc~initialize_from_rest_state->module~spectral proc~initialize_from_rest_state->module~physical_constants proc~initialize_from_rest_state->module~boundaries proc~initialize_geometry initialize_geometry proc~initialize_geometry->module~physical_constants proc~grid_to_spec grid_to_spec proc~grid_to_spec->module~legendre proc~grid_to_spec->module~fourier proc~get_spectral_tendencies get_spectral_tendencies proc~get_spectral_tendencies->module~geometry proc~get_spectral_tendencies->module~implicit proc~get_spectral_tendencies->module~geopotential proc~get_spectral_tendencies->module~prognostics proc~get_spectral_tendencies->module~spectral proc~get_spectral_tendencies->module~physical_constants proc~get_downward_longwave_rad_fluxes get_downward_longwave_rad_fluxes proc~get_downward_longwave_rad_fluxes->module~mod_radcon proc~get_downward_longwave_rad_fluxes->module~physical_constants proc~spec_to_grid spec_to_grid proc~spec_to_grid->module~legendre proc~spec_to_grid->module~fourier proc~initialize_legendre initialize_legendre proc~initialize_legendre->module~physical_constants proc~initialize_coupler initialize_coupler proc~initialize_coupler->module~sea_model proc~initialize_coupler->module~land_model proc~initialize_horizontal_diffusion initialize_horizontal_diffusion proc~initialize_horizontal_diffusion->module~geometry proc~initialize_horizontal_diffusion->module~physical_constants proc~fourier_inv fourier_inv proc~fourier_inv->module~geometry proc~obs_ssta obs_ssta proc~obs_ssta->module~input_output proc~obs_ssta->module~boundaries proc~get_tendencies get_tendencies proc~get_tendencies->module~implicit proc~land_model_init land_model_init proc~land_model_init->module~input_output proc~land_model_init->module~boundaries proc~get_geopotential get_geopotential proc~get_geopotential->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables trunc ix iy il kx nx mx ntr nsteps delt rob wil alph iseasc nstrad sppt_on issty0 nstdia nsteps_out Subroutines initialize_params Variables Type Visibility Attributes Name Initial integer, public, parameter :: trunc = 30 integer, public, parameter :: ix = 96 integer, public, parameter :: iy = 24 integer, public, parameter :: il = 2*iy integer, public, parameter :: kx = 8 integer, public, parameter :: nx = trunc+2 integer, public, parameter :: mx = trunc+1 integer, public, parameter :: ntr = 1 integer, public, parameter :: nsteps = 36 real, public, parameter :: delt = 86400.0/nsteps real, public, parameter :: rob = 0.05 real, public, parameter :: wil = 0.53 real, public, parameter :: alph = 0.5 integer, public, parameter :: iseasc = 1 integer, public, parameter :: nstrad = 3 logical, public, parameter :: sppt_on = .false. integer, public, parameter :: issty0 = 1979 integer, public :: nstdia integer, public :: nsteps_out Subroutines public subroutine initialize_params () Initializes user-defined parameters from namelist file. Arguments None","tags":"","loc":"module/params.html"},{"title":"spectral – SPEEDY.f90","text":"Uses params module~~spectral~~UsesGraph module~spectral spectral module~params params module~spectral->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~spectral~~UsedByGraph module~spectral spectral proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_grid_point_tendencies->module~spectral proc~initialize initialize proc~initialize->module~spectral proc~set_forcing set_forcing proc~set_forcing->module~spectral proc~gen_sppt gen_sppt proc~gen_sppt->module~spectral proc~step_field_3d step_field_3d proc~step_field_3d->module~spectral proc~check_diagnostics check_diagnostics proc~check_diagnostics->module~spectral proc~step_field_2d step_field_2d proc~step_field_2d->module~spectral proc~spectral_truncation spectral_truncation proc~spectral_truncation->module~spectral proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_from_rest_state->module~spectral proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->module~spectral proc~output output proc~output->module~spectral proc~get_spectral_tendencies get_spectral_tendencies proc~get_spectral_tendencies->module~spectral Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables el2 elm2 el4 trfilt gradx gradym gradyp uvdx uvdym uvdyp vddym vddyp Functions laplacian inverse_laplacian spec_to_grid grid_to_spec Subroutines initialize_spectral grad vds uvspec vdspec trunct Variables Type Visibility Attributes Name Initial real, public, dimension(mx,nx) :: el2 real, private, dimension(mx,nx) :: elm2 real, private, dimension(mx,nx) :: el4 real, private, dimension(mx,nx) :: trfilt real, private :: gradx (mx) real, private :: gradym (mx,nx) real, private :: gradyp (mx,nx) real, private, dimension(mx,nx) :: uvdx real, private, dimension(mx,nx) :: uvdym real, private, dimension(mx,nx) :: uvdyp real, private, dimension(mx,nx) :: vddym real, private, dimension(mx,nx) :: vddyp Functions public function laplacian (input) result(output) Arguments Type Intent Optional Attributes Name complex, intent(in) :: input (mx,nx) Return Value complex\n  (mx,nx) public function inverse_laplacian (input) result(output) Arguments Type Intent Optional Attributes Name complex, intent(in) :: input (mx,nx) Return Value complex\n  (mx,nx) public function spec_to_grid (vorm, kcos) result(vorg) Arguments Type Intent Optional Attributes Name complex, intent(in) :: vorm (mx,nx) integer, intent(in) :: kcos Return Value real\n  (ix,il) public function grid_to_spec (vorg) result(vorm) Arguments Type Intent Optional Attributes Name real, intent(in) :: vorg (ix,il) Return Value complex\n  (mx,nx) Subroutines public subroutine initialize_spectral () Arguments None public subroutine grad (psi, psdx, psdy) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(mx,nx) :: psi complex, intent(inout), dimension(mx,nx) :: psdx complex, intent(inout), dimension(mx,nx) :: psdy public subroutine vds (ucosm, vcosm, vorm, divm) Arguments Type Intent Optional Attributes Name complex, dimension(mx,nx) :: ucosm complex, dimension(mx,nx) :: vcosm complex, intent(inout), dimension(mx,nx) :: vorm complex, intent(inout), dimension(mx,nx) :: divm public subroutine uvspec (vorm, divm, ucosm, vcosm) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(mx,nx) :: vorm complex, intent(in), dimension(mx,nx) :: divm complex, intent(inout), dimension(mx,nx) :: ucosm complex, intent(inout), dimension(mx,nx) :: vcosm public subroutine vdspec (ug, vg, vorm, divm, kcos) Arguments Type Intent Optional Attributes Name real, intent(in) :: ug (ix,il) real, intent(in) :: vg (ix,il) complex, intent(out) :: vorm (mx,nx) complex, intent(out) :: divm (mx,nx) integer, intent(in) :: kcos public subroutine trunct (vor) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: vor (mx,nx)","tags":"","loc":"module/spectral.html"},{"title":"humidity – SPEEDY.f90","text":"For converting between specific and relative humidity, and computing the\n  saturation specific humidity. Uses params module~~humidity~~UsesGraph module~humidity humidity module~params params module~humidity->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~humidity~~UsedByGraph module~humidity humidity proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->module~humidity proc~get_surface_fluxes get_surface_fluxes proc~get_surface_fluxes->module~humidity proc~set_forcing set_forcing proc~set_forcing->module~humidity Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions get_qsat Subroutines spec_hum_to_rel_hum rel_hum_to_spec_hum Functions public function get_qsat (ta, ps, sig) result(qsat) Computes saturation specific humidity. Arguments Type Intent Optional Attributes Name real, intent(in) :: ta (ix,il) Absolute temperature real, intent(in) :: ps (ix,il) Normalized pressure (p/1000 hPa) real, intent(in) :: sig Sigma level Return Value real\n  (ix,il) Saturation specific humidity in g/kg Subroutines public subroutine spec_hum_to_rel_hum (ta, ps, sig, qa, rh, qsat) Converts specific humidity to relative humidity, and also returns\n  saturation specific humidity. Arguments Type Intent Optional Attributes Name real, intent(in) :: ta (ix,il) Absolute temperature real, intent(in) :: ps (ix,il) Normalized pressure (p/1000 hPa) real, intent(in) :: sig Sigma level real, intent(in) :: qa (ix,il) Specific humidity real, intent(inout) :: rh (ix,il) Relative humidity real, intent(inout) :: qsat (ix,il) Saturation specific humidity public subroutine rel_hum_to_spec_hum (ta, ps, sig, rh, qa, qsat) Converts relative humidity to specific humidity, and also returns\n  saturation specific humidity. Arguments Type Intent Optional Attributes Name real, intent(in) :: ta (ix,il) Absolute temperature real, intent(in) :: ps (ix,il) Normalized pressure (p/1000 hPa) real, intent(in) :: sig Sigma level real, intent(in) :: rh (ix,il) Relative humidity real, intent(inout) :: qa (ix,il) Specific humidity real, intent(inout) :: qsat (ix,il) Saturation specific humidity","tags":"","loc":"module/humidity.html"},{"title":"vertical_diffusion – SPEEDY.f90","text":"Parametrization of vertical diffusion Three different processes are modelled by the vertical diffusion scheme:\n 1) Shallow convection - A redistribution of moisture and dry static energy\n    between the lowest two layers where there is conditional instability\n 2) A slow diffusion of moisture in stable conditions\n 3) A fast redistribution of dry static energy where the lapse rate is close to\n    the dry adiabatic limit Uses params module~~vertical_diffusion~~UsesGraph module~vertical_diffusion vertical_diffusion module~params params module~vertical_diffusion->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~vertical_diffusion~~UsedByGraph module~vertical_diffusion vertical_diffusion proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->module~vertical_diffusion Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables trshc trvdi trvds redshc rhgrad segrad Subroutines get_vertical_diffusion_tend Variables Type Visibility Attributes Name Initial real, private, parameter :: trshc = 6.0 Relaxation time (in hours) for shallow convection real, private, parameter :: trvdi = 24.0 Relaxation time (in hours) for moisture diffusion real, private, parameter :: trvds = 6.0 Relaxation time (in hours) for super-adiabatic conditions real, private, parameter :: redshc = 0.5 Reduction factor of shallow convection in areas of deep\n convection real, private, parameter :: rhgrad = 0.5 Maximum gradient of relative humidity (d_RH/d_sigma) real, private, parameter :: segrad = 0.1 Minimum gradient of dry static energy (d_DSE/d_phi) Subroutines public subroutine get_vertical_diffusion_tend (se, rh, qa, qsat, phi, icnv, utenvd, vtenvd, ttenvd, qtenvd) Compute tendencies of momentum, energy and moisture due to vertical diffusion\n  and shallow convection Arguments Type Intent Optional Attributes Name real, intent(in) :: se (ix,il,kx) Dry static energy real, intent(in) :: rh (ix,il,kx) Relative humidity real, intent(in) :: qa (ix,il,kx) Specific humidity [g/kg] real, intent(in) :: qsat (ix,il,kx) Saturated specific humidity [g/kg] real, intent(in) :: phi (ix,il,kx) Geopotential integer, intent(in) :: icnv (ix,il) Sigma-level index of deep convection real, intent(out) :: utenvd (ix,il,kx) u-wind tendency real, intent(out) :: vtenvd (ix,il,kx) v-wind tendency real, intent(out) :: ttenvd (ix,il,kx) Temperature tendency real, intent(out) :: qtenvd (ix,il,kx) Specific humidity tendency","tags":"","loc":"module/vertical_diffusion.html"},{"title":"horizontal_diffusion – SPEEDY.f90","text":"For performing horizontal diffusion. Uses params module~~horizontal_diffusion~~UsesGraph module~horizontal_diffusion horizontal_diffusion module~params params module~horizontal_diffusion->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~horizontal_diffusion~~UsedByGraph module~horizontal_diffusion horizontal_diffusion proc~initialize initialize proc~initialize->module~horizontal_diffusion proc~initialize_implicit initialize_implicit proc~initialize_implicit->module~horizontal_diffusion proc~step step proc~step->module~horizontal_diffusion proc~set_forcing set_forcing proc~set_forcing->module~horizontal_diffusion Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables dmp dmpd dmps dmp1 dmp1d dmp1s tcorv qcorv tcorh qcorh Interfaces do_horizontal_diffusion Functions do_horizontal_diffusion_2d do_horizontal_diffusion_3d Subroutines initialize_horizontal_diffusion Variables Type Visibility Attributes Name Initial real, public :: dmp (mx,nx) Damping coefficient for temperature and vorticity (explicit) real, public :: dmpd (mx,nx) Damping coefficient for divergence (explicit) real, public :: dmps (mx,nx) Damping coefficient for extra diffusion in the stratosphere (explicit) real, public :: dmp1 (mx,nx) Damping coefficient for temperature and vorticity (implicit) real, public :: dmp1d (mx,nx) Damping coefficient for divergence (implicit) real, public :: dmp1s (mx,nx) Damping coefficient for extra diffusion in the stratosphere (implicit) real, public :: tcorv (kx) Vertical component of orographic correction for temperature real, public :: qcorv (kx) Vertical component of orographic correction for humidity complex, public :: tcorh (mx,nx) Horizontal component of orographic correction for temperature complex, public :: qcorh (mx,nx) Horizontal component of orographic correction for humidity Interfaces public interface do_horizontal_diffusion private function do_horizontal_diffusion_2d (field, fdt_in, dmp, dmp1) result(fdt_out) Adds horizontal diffusion tendency of field to spectral tendency fdt\n  using damping coefficients dmp and dmp1. Arguments Type Intent Optional Attributes Name complex, intent(in) :: field (mx,nx) complex, intent(in) :: fdt_in (mx,nx) real, intent(in) :: dmp (mx,nx) real, intent(in) :: dmp1 (mx,nx) Return Value complex\n  (mx,nx) private function do_horizontal_diffusion_3d (field, fdt_in, dmp, dmp1) result(fdt_out) Adds horizontal diffusion tendency of field to spectral tendency fdt\n  at all model levels using damping coefficients dmp and dmp1. Arguments Type Intent Optional Attributes Name complex, intent(in) :: field (mx,nx,kx) complex, intent(in) :: fdt_in (mx,nx,kx) real, intent(in) :: dmp (mx,nx) real, intent(in) :: dmp1 (mx,nx) Return Value complex\n  (mx,nx,kx) Functions private function do_horizontal_diffusion_2d (field, fdt_in, dmp, dmp1) result(fdt_out) Adds horizontal diffusion tendency of field to spectral tendency fdt\n  using damping coefficients dmp and dmp1. Arguments Type Intent Optional Attributes Name complex, intent(in) :: field (mx,nx) complex, intent(in) :: fdt_in (mx,nx) real, intent(in) :: dmp (mx,nx) real, intent(in) :: dmp1 (mx,nx) Return Value complex\n  (mx,nx) private function do_horizontal_diffusion_3d (field, fdt_in, dmp, dmp1) result(fdt_out) Adds horizontal diffusion tendency of field to spectral tendency fdt\n  at all model levels using damping coefficients dmp and dmp1. Arguments Type Intent Optional Attributes Name complex, intent(in) :: field (mx,nx,kx) complex, intent(in) :: fdt_in (mx,nx,kx) real, intent(in) :: dmp (mx,nx) real, intent(in) :: dmp1 (mx,nx) Return Value complex\n  (mx,nx,kx) Subroutines public subroutine initialize_horizontal_diffusion () Initializes the arrays used for horizontal diffusion. Arguments None","tags":"","loc":"module/horizontal_diffusion.html"},{"title":"initialization – SPEEDY.f90","text":"The master initialization module. Used by module~~initialization~~UsedByGraph module~initialization initialization program~speedy speedy program~speedy->module~initialization Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines initialize print_speedy_title Subroutines public subroutine initialize () Initializes everything. Arguments None private subroutine print_speedy_title () Prints SPEEDY.f90 banner. Arguments None","tags":"","loc":"module/initialization.html"},{"title":"land_model – SPEEDY.f90","text":"For running the land-surface model. Uses params module~~land_model~~UsesGraph module~land_model land_model module~params params module~land_model->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~land_model~~UsedByGraph module~land_model land_model proc~set_forcing set_forcing proc~set_forcing->module~land_model proc~initialize_coupler initialize_coupler proc~initialize_coupler->module~land_model proc~couple_sea_land couple_sea_land proc~couple_sea_land->module~land_model proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->module~land_model proc~get_surface_fluxes get_surface_fluxes proc~get_surface_fluxes->module~land_model Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables rhcapl cdland stlcl_ob snowdcl_ob soilwcl_ob stl_am snowd_am soilw_am stl_lm fmask_l bmask_l stl12 snowd12 soilw12 land_coupling_flag sd2sc Subroutines land_model_init couple_land_atm run_land_model Variables Type Visibility Attributes Name Initial real, private :: rhcapl (ix,il) 1/heat capacity (land) real, private :: cdland (ix,il) 1/dissipation time (land) real, private :: stlcl_ob (ix,il) Climatological land surface temperature real, private :: snowdcl_ob (ix,il) Climatological snow depth (water equivalent) real, private :: soilwcl_ob (ix,il) Climatological soil water availability real, public :: stl_am (ix,il) Land surface temperature real, public :: snowd_am (ix,il) Snow depth (water equivalent) real, public :: soilw_am (ix,il) Soil water availability real, private :: stl_lm (ix,il) Land-model surface temperature real, public :: fmask_l (ix,il) Fraction of land real, private :: bmask_l (ix,il) Binary land mask real, private :: stl12 (ix,il,12) Land surface temperature monthly-mean climatology real, private :: snowd12 (ix,il,12) Snow depth (water equivalent) monthly-mean climatology real, private :: soilw12 (ix,il,12) Soil water availability monthly-mean climatology integer, public :: land_coupling_flag = 1 Flag for land-coupling (0: off, 1: on) real, public, parameter :: sd2sc = 60.0 Snow depth (mm water) corresponding to snow cover = 1 Subroutines public subroutine land_model_init () Initializes land model. Arguments None public subroutine couple_land_atm (day) Exchanges fluxes between land and atmosphere. Arguments Type Intent Optional Attributes Name integer, intent(in) :: day The day (starting at 0 for the first time step) private subroutine run_land_model () Integrates slab land-surface model for one day. Arguments None","tags":"","loc":"module/land_model.html"},{"title":"matrix_inversion – SPEEDY.f90","text":"Used by module~~matrix_inversion~~UsedByGraph module~matrix_inversion matrix_inversion proc~initialize_implicit initialize_implicit proc~initialize_implicit->module~matrix_inversion Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines ludcmp lubksb inv Subroutines private subroutine ludcmp (a, n, np, indx, d) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a (np,np) integer, intent(in) :: n integer, intent(in) :: np integer, intent(inout) :: indx (n) real, intent(inout) :: d private subroutine lubksb (a, n, np, indx, b) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a (np,np) integer, intent(in) :: n integer, intent(in) :: np integer, intent(in) :: indx (n) real, intent(inout) :: b (n) public subroutine inv (a, y, indx, n) Arguments Type Intent Optional Attributes Name real, intent(inout) :: a (n,n) real, intent(inout) :: y (n,n) integer, intent(inout) :: indx (n) integer, intent(in) :: n","tags":"","loc":"module/matrix_inversion.html"},{"title":"sea_model – SPEEDY.f90","text":"Uses params module~~sea_model~~UsesGraph module~sea_model sea_model module~params params module~sea_model->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~sea_model~~UsedByGraph module~sea_model sea_model proc~initialize initialize proc~initialize->module~sea_model proc~set_forcing set_forcing proc~set_forcing->module~sea_model proc~initialize_coupler initialize_coupler proc~initialize_coupler->module~sea_model proc~couple_sea_land couple_sea_land proc~couple_sea_land->module~sea_model proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->module~sea_model Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables rhcaps rhcapi cdsea cdice beta fmask_s bmask_s deglat_s sst12 sice12 sstan3 hfseacl sstom12 sstcl_ob sicecl_ob ticecl_ob sstan_ob sstcl_om sst_am sstan_am sice_am tice_am sst_om sice_om tice_om ssti_om wsst_ob sea_coupling_flag ice_coupling_flag sst_anomaly_coupling_flag Subroutines sea_model_init couple_sea_atm obs_ssta run_sea_model sea_domain Variables Type Visibility Attributes Name Initial real, private :: rhcaps (ix,il) real, private :: rhcapi (ix,il) real, private :: cdsea (ix,il) real, private :: cdice (ix,il) real, private :: beta = 1.0 real, public :: fmask_s (ix,il) real, private :: bmask_s (ix,il) real, private :: deglat_s (il) real, private :: sst12 (ix,il,12) real, private :: sice12 (ix,il,12) real, private :: sstan3 (ix,il,3) real, private :: hfseacl (ix,il) real, private :: sstom12 (ix,il,12) real, public :: sstcl_ob (ix,il) real, private :: sicecl_ob (ix,il) real, private :: ticecl_ob (ix,il) real, private :: sstan_ob (ix,il) real, private :: sstcl_om (ix,il) real, public :: sst_am (ix,il) real, private :: sstan_am (ix,il) real, public :: sice_am (ix,il) real, public :: tice_am (ix,il) real, private :: sst_om (ix,il) real, private :: sice_om (ix,il) real, private :: tice_om (ix,il) real, public :: ssti_om (ix,il) real, private :: wsst_ob (ix,il) integer, public :: sea_coupling_flag = 0 integer, private :: ice_coupling_flag = 1 integer, public :: sst_anomaly_coupling_flag = 1 Subroutines public subroutine sea_model_init () Arguments None public subroutine couple_sea_atm (day) Arguments Type Intent Optional Attributes Name integer, intent(in) :: day private subroutine obs_ssta () Arguments None private subroutine run_sea_model () Arguments None private subroutine sea_domain (cdomain, dmask) Arguments Type Intent Optional Attributes Name character(len=6), intent(in) :: cdomain real, intent(inout) :: dmask (ix,il)","tags":"","loc":"module/sea_model.html"},{"title":"time_stepping – SPEEDY.f90","text":"Uses params module~~time_stepping~~UsesGraph module~time_stepping time_stepping module~params params module~time_stepping->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~time_stepping~~UsedByGraph module~time_stepping time_stepping program~speedy speedy program~speedy->module~time_stepping proc~initialize initialize proc~initialize->module~time_stepping Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions step_field_3d step_field_2d Subroutines first_step step Functions private function step_field_3d (j1, dt, eps, input, fdt) result(output) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j1 real, intent(in) :: dt real, intent(in) :: eps complex, intent(in) :: input (mx,nx,kx,2) complex, intent(inout) :: fdt (mx,nx,kx) Return Value complex\n  (mx,nx,kx,2) private function step_field_2d (j1, dt, eps, input, fdt) result(output) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j1 real, intent(in) :: dt real, intent(in) :: eps complex, intent(in) :: input (mx,nx,2) complex, intent(inout) :: fdt (mx,nx) Return Value complex\n  (mx,nx,2) Subroutines public subroutine first_step () Arguments None public subroutine step (j1, j2, dt) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j1 integer, intent(in) :: j2 real, intent(in) :: dt","tags":"","loc":"module/time_stepping.html"},{"title":"physics – SPEEDY.f90","text":"Uses params module~~physics~~UsesGraph module~physics physics module~params params module~physics->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~physics~~UsedByGraph module~physics physics proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_grid_point_tendencies->module~physics proc~initialize initialize proc~initialize->module~physics Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines initialize_physics get_physical_tendencies Subroutines public subroutine initialize_physics () Arguments None public subroutine get_physical_tendencies (vor, div, t, q, phi, psl, utend, vtend, ttend, qtend) Compute physical parametrization tendencies for u, v, t, q and add them\n  to the dynamical grid-point tendencies Arguments Type Intent Optional Attributes Name complex, intent(in) :: vor (mx,nx,kx) Vorticity complex, intent(in) :: div (mx,nx,kx) Divergence complex, intent(in) :: t (mx,nx,kx) Temperature complex, intent(in) :: q (mx,nx,kx) Specific Humidity complex, intent(in) :: phi (mx,nx,kx) Geopotential complex, intent(in) :: psl (mx,nx) ln(Surface pressure) real, intent(inout) :: utend (ix,il,kx) Zonal velocity tendency real, intent(inout) :: vtend (ix,il,kx) Meridional velocity tendency real, intent(inout) :: ttend (ix,il,kx) Temperature tendency real, intent(inout) :: qtend (ix,il,kx) Specific humidity tendency","tags":"","loc":"module/physics.html"},{"title":"surface_fluxes – SPEEDY.f90","text":"Parametrization of surface fluxes Uses params module~~surface_fluxes~~UsesGraph module~surface_fluxes surface_fluxes module~params params module~surface_fluxes->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~surface_fluxes~~UsedByGraph module~surface_fluxes surface_fluxes proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->module~surface_fluxes proc~set_forcing set_forcing proc~set_forcing->module~surface_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables fwind0 ftemp0 fhum0 cdl cds chl chs vgust ctday dtheta fstab hdrag clambda clambsn forog Subroutines get_surface_fluxes set_orog_land_sfc_drag Variables Type Visibility Attributes Name Initial real, private :: fwind0 = 0.95 Ratio of near-sfc wind to lowest-level wind real, private :: ftemp0 = 1.0 Weight for near-sfc temperature extrapolation (0-1) :\n  1 : linear extrapolation from two lowest levels\n  0 : constant potential temperature ( = lowest level) real, private :: fhum0 = 0.0 Weight for near-sfc specific humidity extrapolation (0-1) :\n  1 : extrap. with constant relative hum. ( = lowest level)\n  0 : constant specific hum. ( = lowest level) real, private :: cdl = 2.4e-3 Drag coefficient for momentum over land real, private :: cds = 1.0e-3 Drag coefficient for momentum over sea real, private :: chl = 1.2e-3 Heat exchange coefficient over land real, private :: chs = 0.9e-3 Heat exchange coefficient over sea real, private :: vgust = 5.0 Wind speed for sub-grid-scale gusts real, private :: ctday = 1.0e-2 Daily-cycle correction (dTskin/dSSRad) real, private :: dtheta = 3.0 Potential temp. gradient for stability correction real, private :: fstab = 0.67 Amplitude of stability correction (fraction) real, private :: hdrag = 2000.0 Height scale for orographic correction real, private :: clambda = 7.0 Heat conductivity in skin-to-root soil layer real, private :: clambsn = 7.0 Heat conductivity in soil for snow cover = 1 real, private :: forog (ix,il) Subroutines public subroutine get_surface_fluxes (psa, ua, va, ta, qa, rh, phi, phi0, fmask, tsea, ssrd, slrd, ustr, vstr, shf, evap, slru, hfluxn, tsfc, tskin, u0, v0, t0, lfluxland) Compute surface fluxes of momentum, energy and moisture, and define surface\n  skin temperature from energy balance Arguments Type Intent Optional Attributes Name real, intent(in) :: psa (ix,il) Normalised surface pressure real, intent(in) :: ua (ix,il,kx) u-wind real, intent(in) :: va (ix,il,kx) v-wind real, intent(in) :: ta (ix,il,kx) Temperature real, intent(in) :: qa (ix,il,kx) Specific humidity [g/kg] real, intent(in) :: rh (ix,il,kx) Relative humidity real, intent(in) :: phi (ix,il,kx) Geopotential real, intent(in) :: phi0 (ix,il) Surface geopotential real, intent(in) :: fmask (ix,il) Fractional land-sea mask real, intent(in) :: tsea (ix,il) Sea-surface temperature real, intent(in) :: ssrd (ix,il) Downward flux of short-wave radiation at the surface real, intent(in) :: slrd (ix,il) Downward flux of long-wave radiation at the surface real, intent(out) :: ustr (ix,il,3) u-stress real, intent(out) :: vstr (ix,il,3) v-stress real, intent(out) :: shf (ix,il,3) Sensible heat flux real, intent(out) :: evap (ix,il,3) Evaporation real, intent(out) :: slru (ix,il,3) Upward flux of long-wave radiation at the surface real, intent(out) :: hfluxn (ix,il,2) Net downward heat flux real, intent(out) :: tsfc (ix,il) Surface temperature real, intent(out) :: tskin (ix,il) Skin surface temperature real, intent(out) :: u0 (ix,il) Near-surface u-wind real, intent(out) :: v0 (ix,il) Near-surface v-wind real, intent(out) :: t0 (ix,il) Near-surface temperature logical, intent(in) :: lfluxland public subroutine set_orog_land_sfc_drag (phi0) Arguments Type Intent Optional Attributes Name real, intent(in) :: phi0 (ix,il)","tags":"","loc":"module/surface_fluxes.html"},{"title":"mod_radcon – SPEEDY.f90","text":"Uses params module~~mod_radcon~~UsesGraph module~mod_radcon mod_radcon module~params params module~mod_radcon->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mod_radcon~~UsedByGraph module~mod_radcon mod_radcon proc~get_shortwave_rad_fluxes get_shortwave_rad_fluxes proc~get_shortwave_rad_fluxes->module~mod_radcon proc~get_upward_longwave_rad_fluxes get_upward_longwave_rad_fluxes proc~get_upward_longwave_rad_fluxes->module~mod_radcon proc~set_forcing set_forcing proc~set_forcing->module~mod_radcon proc~radset radset proc~radset->module~mod_radcon proc~get_surface_fluxes get_surface_fluxes proc~get_surface_fluxes->module~mod_radcon proc~run_sea_model run_sea_model proc~run_sea_model->module~mod_radcon proc~get_downward_longwave_rad_fluxes get_downward_longwave_rad_fluxes proc~get_downward_longwave_rad_fluxes->module~mod_radcon Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables albsea albice albsn epslw emisfc ablco2_ref fband alb_l alb_s albsfc snowc tau2 st4a stratc flux Variables Type Visibility Attributes Name Initial real, public :: albsea = 0.07 real, public :: albice = 0.60 real, public :: albsn = 0.60 real, public :: epslw = 0.05 real, public :: emisfc = 0.98 real, public :: ablco2_ref real, public :: fband (100:400,4) real, public, dimension(ix,il) :: alb_l real, public, dimension(ix,il) :: alb_s real, public, dimension(ix,il) :: albsfc real, public, dimension(ix,il) :: snowc real, public :: tau2 (ix,il,kx,4) real, public :: st4a (ix,il,kx,2) real, public :: stratc (ix,il,2) real, public :: flux (ix,il,4)","tags":"","loc":"module/mod_radcon.html"},{"title":"physical_constants – SPEEDY.f90","text":"Uses params module~~physical_constants~~UsesGraph module~physical_constants physical_constants module~params params module~physical_constants->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~physical_constants~~UsedByGraph module~physical_constants physical_constants proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_grid_point_tendencies->module~physical_constants proc~gen_sppt gen_sppt proc~gen_sppt->module~physical_constants proc~set_orog_land_sfc_drag set_orog_land_sfc_drag proc~set_orog_land_sfc_drag->module~physical_constants proc~initialize_implicit initialize_implicit proc~initialize_implicit->module~physical_constants proc~get_large_scale_condensation_tendencies get_large_scale_condensation_tendencies proc~get_large_scale_condensation_tendencies->module~physical_constants proc~output output proc~output->module~physical_constants proc~run_sea_model run_sea_model proc~run_sea_model->module~physical_constants proc~diagnose_convection diagnose_convection proc~diagnose_convection->module~physical_constants proc~initialize_geopotential initialize_geopotential proc~initialize_geopotential->module~physical_constants proc~get_convection_tendencies get_convection_tendencies proc~get_convection_tendencies->module~physical_constants proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->module~physical_constants proc~get_surface_fluxes get_surface_fluxes proc~get_surface_fluxes->module~physical_constants proc~setgam setgam proc~setgam->module~physical_constants proc~initialize_boundaries initialize_boundaries proc~initialize_boundaries->module~physical_constants proc~get_vertical_diffusion_tend get_vertical_diffusion_tend proc~get_vertical_diffusion_tend->module~physical_constants proc~set_forcing set_forcing proc~set_forcing->module~physical_constants proc~initialize_spectral initialize_spectral proc~initialize_spectral->module~physical_constants proc~initialize_physics initialize_physics proc~initialize_physics->module~physical_constants proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_from_rest_state->module~physical_constants proc~initialize_geometry initialize_geometry proc~initialize_geometry->module~physical_constants proc~initialize_legendre initialize_legendre proc~initialize_legendre->module~physical_constants proc~get_downward_longwave_rad_fluxes get_downward_longwave_rad_fluxes proc~get_downward_longwave_rad_fluxes->module~physical_constants proc~get_spectral_tendencies get_spectral_tendencies proc~get_spectral_tendencies->module~physical_constants proc~initialize_horizontal_diffusion initialize_horizontal_diffusion proc~initialize_horizontal_diffusion->module~physical_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables rearth omega grav akap rgas p0 rd cp alhc alhs sbc sigl sigh grdsig grdscp wvi Variables Type Visibility Attributes Name Initial real, public, parameter :: rearth = 6.371e+6 real, public, parameter :: omega = 7.292e-05 real, public, parameter :: grav = 9.81 real, public, parameter :: akap = 2.0/7.0 real, public, parameter :: rgas = akap*1004.0 real, public, parameter :: p0 = 1.e+5 real, public, parameter :: rd = 287.0 real, public, parameter :: cp = 1004.0 real, public, parameter :: alhc = 2501.0 real, public, parameter :: alhs = 2801.0 real, public, parameter :: sbc = 5.67e-8 real, public, dimension(kx) :: sigl real, public, dimension(0:kx) :: sigh real, public, dimension(kx) :: grdsig real, public, dimension(kx) :: grdscp real, public, dimension(kx,2) :: wvi","tags":"","loc":"module/physical_constants.html"},{"title":"tendencies – SPEEDY.f90","text":"Uses params module~~tendencies~~UsesGraph module~tendencies tendencies module~params params module~tendencies->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~tendencies~~UsedByGraph module~tendencies tendencies proc~step step proc~step->module~tendencies Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines get_tendencies get_grid_point_tendencies get_spectral_tendencies Subroutines public subroutine get_tendencies (vordt, divdt, tdt, psdt, trdt, j2) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(mx,nx,kx) :: vordt complex, intent(inout), dimension(mx,nx,kx) :: divdt complex, intent(inout), dimension(mx,nx,kx) :: tdt complex, intent(inout) :: psdt (mx,nx) complex, intent(inout) :: trdt (mx,nx,kx,ntr) integer, intent(in) :: j2 private subroutine get_grid_point_tendencies (vordt, divdt, tdt, psdt, trdt, j1, j2) Arguments Type Intent Optional Attributes Name complex, intent(inout), dimension(mx,nx,kx) :: vordt complex, intent(inout), dimension(mx,nx,kx) :: divdt complex, intent(inout), dimension(mx,nx,kx) :: tdt complex, intent(inout) :: psdt (mx,nx) complex, intent(inout) :: trdt (mx,nx,kx,ntr) integer, intent(in) :: j1 integer, intent(in) :: j2 private subroutine get_spectral_tendencies (divdt, tdt, psdt, j2) Arguments Type Intent Optional Attributes Name complex, intent(inout) :: divdt (mx,nx,kx) complex, intent(inout) :: tdt (mx,nx,kx) complex, intent(inout) :: psdt (mx,nx) integer, intent(in) :: j2","tags":"","loc":"module/tendencies.html"},{"title":"shortwave_radiation – SPEEDY.f90","text":"Parametrization of short-wave radiation Uses params module~~shortwave_radiation~~UsesGraph module~shortwave_radiation shortwave_radiation module~params params module~shortwave_radiation->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~shortwave_radiation~~UsedByGraph module~shortwave_radiation shortwave_radiation program~speedy speedy program~speedy->module~shortwave_radiation proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->module~shortwave_radiation proc~set_forcing set_forcing proc~set_forcing->module~shortwave_radiation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables solc rhcl1 rhcl2 qacl wpcl pmaxcl clsmax clsminl gse_s0 gse_s1 albcl albcls epssw absdry absaer abswv1 abswv2 abscl1 abscl2 ablwin ablco2 ablwv1 ablwv2 ablcl1 ablcl2 fsol ozone ozupp zenit stratz qcloud increase_co2 compute_shortwave Subroutines get_shortwave_rad_fluxes get_zonal_average_fields solar clouds Variables Type Visibility Attributes Name Initial real, private, parameter :: solc = 342.0 Solar constant (area averaged) in W/m&#94;2 real, private, parameter :: rhcl1 = 0.30 Relative humidity threshold corresponding to\n cloud cover = 0 real, private, parameter :: rhcl2 = 1.00 Relative humidity correponding to cloud cover = 1 real, private, parameter :: qacl = 0.20 Specific humidity threshold for cloud cover real, private, parameter :: wpcl = 0.2 Cloud cover weight for the square-root of precipitation\n (for p = 1 mm/day) real, private, parameter :: pmaxcl = 10.0 Maximum value of precipitation (mm/day) contributing to\n cloud cover real, private, parameter :: clsmax = 0.60 Maximum stratiform cloud cover real, private, parameter :: clsminl = 0.15 Minimum stratiform cloud cover over land (for RH = 1) real, private, parameter :: gse_s0 = 0.25 Gradient of dry static energy corresponding to stratiform\n cloud cover = 0 real, private, parameter :: gse_s1 = 0.40 Gradient of dry static energy corresponding to stratiform\n cloud cover = 1 real, private, parameter :: albcl = 0.43 Cloud albedo (for cloud cover = 1) real, private, parameter :: albcls = 0.50 Stratiform cloud albedo (for st. cloud cover = 1) real, private, parameter :: epssw = 0.020 Fraction of incoming solar radiation absorbed by ozone real, private, parameter :: absdry = 0.033 Absorptivity of dry air (visible band) real, private, parameter :: absaer = 0.033 Absorptivity of aerosols (visible band) real, private, parameter :: abswv1 = 0.022 Absorptivity of water vapour\n (visible band, for dq = 1 g/kg) real, private, parameter :: abswv2 = 15.000 Absorptivity of water vapour\n (near IR band, for dq = 1 g/kg) real, private, parameter :: abscl1 = 0.015 Absorptivity of clouds (visible band, maximum value) real, private, parameter :: abscl2 = 0.15 Absorptivity of clouds\n (visible band, for dq_base = 1 g/kg) real, private, parameter :: ablwin = 0.3 Absorptivity of air in \"window\" band real, public :: ablco2 = 6.0 Absorptivity of air in CO2 band real, private, parameter :: ablwv1 = 0.7 Absorptivity of water vapour in H2O band 1 (weak),\n (for dq = 1 g/kg) real, private, parameter :: ablwv2 = 50.0 Absorptivity of water vapour in H2O band 2 (strong),\n (for dq = 1 g/kg) real, private, parameter :: ablcl1 = 12.0 Absorptivity of \"thick\" clouds in window band\n (below cloud top) real, private, parameter :: ablcl2 = 0.6 Absorptivity of \"thin\" upper clouds in window and H2O bands real, private, dimension(ix,il) :: fsol Flux of incoming solar radiation real, private, dimension(ix,il) :: ozone Flux absorbed by ozone (lower stratosphere) real, private, dimension(ix,il) :: ozupp Flux absorbed by ozone (upper stratosphere) real, private, dimension(ix,il) :: zenit Optical depth ratio (function of solar zenith angle) real, private, dimension(ix,il) :: stratz Stratospheric correction for polar night real, private, dimension(ix,il) :: qcloud Equivalent specific humidity of clouds logical, public, parameter :: increase_co2 = .false. Flag for CO2 optical thickness increase logical, public :: compute_shortwave = .true. Flag for shortwave radiation routine (turned on\n and off in main loop depending on the value of\n nstrad) Subroutines public subroutine get_shortwave_rad_fluxes (psa, qa, icltop, cloudc, clstr, fsfcd, fsfc, ftop, dfabs) Compute the absorption of shortwave radiation and initialize arrays\n  for longwave-radiation routines Arguments Type Intent Optional Attributes Name real, intent(in) :: psa (ix,il) Normalised surface pressure [p/p0] real, intent(in) :: qa (ix,il,kx) Specific humidity [g/kg] integer, intent(in) :: icltop (ix,il) Cloud top level real, intent(in) :: cloudc (ix,il) Total cloud cover real, intent(in) :: clstr (ix,il) Stratiform cloud cover real, intent(out) :: fsfcd (ix,il) Total downward flux of short-wave radiation at the\n surface real, intent(out) :: fsfc (ix,il) Net downward flux of short-wave radiation at the\n surface real, intent(out) :: ftop (ix,il) Net downward flux of short-wave radiation at the\n top of the atmosphere real, intent(out) :: dfabs (ix,il,kx) Flux of short-wave radiation absorbed in each\n atmospheric layer public subroutine get_zonal_average_fields (tyear) Compute zonally-averaged fields to be used in the computation of\n  short-wave absorption Arguments Type Intent Optional Attributes Name real, intent(in) :: tyear time as fraction of year (0-1, 0 = 1jan.h00) private subroutine solar (tyear, csol, topsr) Arguments Type Intent Optional Attributes Name real, intent(in) :: tyear time as fraction of year (0-1, 0 = 1jan.h00) real, intent(in) :: csol The solar constant [W/m&#94;2] real, intent(out) :: topsr (il) Daily-average insolation at the top of the atmosphere as a\n function of latitude public subroutine clouds (qa, rh, precnv, precls, iptop, gse, fmask, icltop, cloudc, clstr) Compute cloud-top level and cloud cover Arguments Type Intent Optional Attributes Name real, intent(in) :: qa (ix,il,kx) Specific humidity [g/kg] real, intent(in) :: rh (ix,il,kx) Relative humidity real, intent(in) :: precnv (ix,il) Convection precipitation real, intent(in) :: precls (ix,il) Large-scale condensational precipitation integer :: iptop (ix,il) real, intent(in) :: gse (ix,il) Vertical gradient of dry static energy real, intent(in) :: fmask (ix,il) Fraction land-sea mask integer, intent(out) :: icltop (ix,il) Cloud top level real, intent(out) :: cloudc (ix,il) Total cloud cover real, intent(out) :: clstr (ix,il) Stratiform cloud cover","tags":"","loc":"module/shortwave_radiation.html"},{"title":"date – SPEEDY.f90","text":"For keeping track of the model's date and time. Used by module~~date~~UsedByGraph module~date date module~interpolation interpolation module~interpolation->module~date proc~initialize initialize proc~initialize->module~date proc~set_forcing set_forcing proc~set_forcing->module~date proc~sea_model_init sea_model_init proc~sea_model_init->module~date proc~couple_land_atm couple_land_atm proc~couple_land_atm->module~date proc~couple_land_atm->module~interpolation proc~couple_sea_atm couple_sea_atm proc~couple_sea_atm->module~date proc~couple_sea_atm->module~interpolation proc~obs_ssta obs_ssta proc~obs_ssta->module~date program~speedy speedy program~speedy->module~date proc~output output proc~output->module~date Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables model_datetime start_datetime end_datetime imont1 tmonth tyear isst0 ndaycal ncal ncal365 Derived Types datetime Functions datetime_equal Subroutines initialize_date newdate Variables Type Visibility Attributes Name Initial type( datetime ), public :: model_datetime The model's current datetime (continuously updated) type( datetime ), public :: start_datetime The start datetime type( datetime ), public :: end_datetime The end datetime integer, public :: imont1 The month used for computing seasonal forcing fields real, public :: tmonth The fraction of the current month elapsed real, public :: tyear The fraction of the current year elapsed integer, public :: isst0 Initial month of SST anomalies integer, public :: ndaycal (12,2) The model calendar integer, private, parameter :: ncal = 365 The number of days in a year integer, private :: ncal365 (12) = (/31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/) The number of days in each month Derived Types type, private :: datetime For storing dates and times. Components Type Visibility Attributes Name Initial integer, public :: year integer, public :: month integer, public :: day integer, public :: hour integer, public :: minute Functions public function datetime_equal (datetime1, datetime2) Checks whether two datetimes are equal. Arguments Type Intent Optional Attributes Name type( datetime ), intent(in) :: datetime1 type( datetime ), intent(in) :: datetime2 Return Value logical Subroutines public subroutine initialize_date () Initializes model date and calendar. Arguments None public subroutine newdate () Updates the current datetime and related date variables. Arguments None","tags":"","loc":"module/date.html"},{"title":"geometry – SPEEDY.f90","text":"For storing all variables related to the model's grid space. Uses params module~~geometry~~UsesGraph module~geometry geometry module~params params module~geometry->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~geometry~~UsedByGraph module~geometry geometry proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_grid_point_tendencies->module~geometry proc~get_shortwave_rad_fluxes get_shortwave_rad_fluxes proc~get_shortwave_rad_fluxes->module~geometry proc~get_upward_longwave_rad_fluxes get_upward_longwave_rad_fluxes proc~get_upward_longwave_rad_fluxes->module~geometry proc~initialize_implicit initialize_implicit proc~initialize_implicit->module~geometry proc~get_large_scale_condensation_tendencies get_large_scale_condensation_tendencies proc~get_large_scale_condensation_tendencies->module~geometry proc~solar solar proc~solar->module~geometry proc~output output proc~output->module~geometry proc~initialize_geopotential initialize_geopotential proc~initialize_geopotential->module~geometry proc~sea_model_init sea_model_init proc~sea_model_init->module~geometry proc~get_convection_tendencies get_convection_tendencies proc~get_convection_tendencies->module~geometry proc~get_legendre_poly get_legendre_poly proc~get_legendre_poly->module~geometry proc~get_physical_tendencies get_physical_tendencies proc~get_physical_tendencies->module~geometry proc~get_surface_fluxes get_surface_fluxes proc~get_surface_fluxes->module~geometry proc~get_zonal_average_fields get_zonal_average_fields proc~get_zonal_average_fields->module~geometry proc~get_vertical_diffusion_tend get_vertical_diffusion_tend proc~get_vertical_diffusion_tend->module~geometry proc~vdspec vdspec proc~vdspec->module~geometry proc~initialize_physics initialize_physics proc~initialize_physics->module~geometry proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_from_rest_state->module~geometry proc~get_spectral_tendencies get_spectral_tendencies proc~get_spectral_tendencies->module~geometry proc~initialize initialize proc~initialize->module~geometry proc~initialize_horizontal_diffusion initialize_horizontal_diffusion proc~initialize_horizontal_diffusion->module~geometry proc~fourier_inv fourier_inv proc~fourier_inv->module~geometry proc~get_geopotential get_geopotential proc~get_geopotential->module~geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables hsg dhs fsg dhsr fsgr radang coriol sia coa sia_half coa_half cosg cosgr cosgr2 Subroutines initialize_geometry Variables Type Visibility Attributes Name Initial real, public :: hsg (kx+1) Half sigma levels real, public :: dhs (kx) Sigma level thicknesses real, public :: fsg (kx) Full sigma levels real, public :: dhsr (kx) 1/(2*sigma level thicknesses) real, public :: fsgr (kx) akap/(2*full sigma levels) real, public, dimension(il) :: radang Latitudes in radians real, public, dimension(il) :: coriol Coriolis parameter as a function of latitude real, public, dimension(il) :: sia sine(latitude) real, public, dimension(il) :: coa cosine(latitude) real, public, dimension(iy) :: sia_half sine(latitude) over one hemisphere only real, public, dimension(il) :: coa_half cosine(latitude) over one hemisphere only real, public, dimension(il) :: cosg Same as coa (TODO: remove) real, public, dimension(il) :: cosgr 1/coa real, public, dimension(il) :: cosgr2 1/coa&#94;2 Subroutines public subroutine initialize_geometry () Initializes all of the model geometry variables. Arguments None","tags":"","loc":"module/geometry.html"},{"title":"legendre – SPEEDY.f90","text":"For computing direct and inverse Legendre transforms. Uses params module~~legendre~~UsesGraph module~legendre legendre module~params params module~legendre->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~legendre~~UsedByGraph module~legendre legendre proc~grid_to_spec grid_to_spec proc~grid_to_spec->module~legendre proc~spec_to_grid spec_to_grid proc~spec_to_grid->module~legendre proc~initialize_spectral initialize_spectral proc~initialize_spectral->module~legendre Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables cpol epsi repsi nsh2 wt Functions legendre_inv legendre_dir get_weights get_legendre_poly Subroutines initialize_legendre Variables Type Visibility Attributes Name Initial real, private :: cpol (2*mx,nx,iy) The Legendre polynomials real, public :: epsi (mx+1,nx+1) Epsilon function used for various spectral calculations real, private :: repsi (mx+1,nx+1) 1/epsi integer, private :: nsh2 (nx) Used for defining shape of spectral triangle real, private, dimension(iy) :: wt Gaussian weights used for integration in direct Legendre transform Functions public function legendre_inv (input) result(output) Computes inverse Legendre transformation. Arguments Type Intent Optional Attributes Name real, intent(in) :: input (2*mx,nx) Input field Return Value real\n  (2*mx,il) Output field public function legendre_dir (input) result(output) Computes direct Legendre transformation. Arguments Type Intent Optional Attributes Name real, intent(in) :: input (2*mx,il) Input field Return Value real\n  (2*mx,nx) Output field private function get_weights () result(w) Compute Gaussian weights for direct Legendre transform Arguments None Return Value real\n  (iy) Weights in gaussian quadrature (sum should equal 1.0) private function get_legendre_poly (j) result(poly) Compute associated Legendre polynomials at given latitude. Arguments Type Intent Optional Attributes Name integer, intent(in) :: j The latitude to compute the polynomials at Return Value real\n  (mx,nx) The Legendre polynomials Subroutines public subroutine initialize_legendre () Initializes Legendre transforms and constants used for other subroutines\n  that manipulate spherical harmonics. Arguments None","tags":"","loc":"module/legendre.html"},{"title":"fourier – SPEEDY.f90","text":"For computing direct and inverse Fourier transforms. Uses params module~~fourier~~UsesGraph module~fourier fourier module~params params module~fourier->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~fourier~~UsedByGraph module~fourier fourier proc~grid_to_spec grid_to_spec proc~grid_to_spec->module~fourier proc~spec_to_grid spec_to_grid proc~spec_to_grid->module~fourier proc~initialize_spectral initialize_spectral proc~initialize_spectral->module~fourier Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables work ifac Functions fourier_inv fourier_dir Subroutines initialize_fourier Variables Type Visibility Attributes Name Initial real, private :: work (ix) Work array required by FFTPACK. Contains trigonometric functions etc. integer, private :: ifac (15) Work array required by FFTPACK. Contains prime factors Functions public function fourier_inv (input, kcos) result(output) Transforms Fourier coefficients to grid-point data. Arguments Type Intent Optional Attributes Name real, intent(in) :: input (2*mx,il) Input field integer, intent(in) :: kcos Scale output by cos(lat) (1) or not (0) Return Value real\n  (ix,il) Output field public function fourier_dir (input) result(output) Transforms grid-point data to Fourier coefficients. Arguments Type Intent Optional Attributes Name real, intent(in) :: input (ix,il) Input field Return Value real\n  (2*mx,il) Output field Subroutines public subroutine initialize_fourier () Initializes the Fourier transforms. Arguments None","tags":"","loc":"module/fourier.html"},{"title":"speedy – SPEEDY.f90","text":"Uses params date shortwave_radiation input_output coupler initialization time_stepping diagnostics prognostics forcing program~~speedy~~UsesGraph program~speedy speedy module~diagnostics diagnostics program~speedy->module~diagnostics module~shortwave_radiation shortwave_radiation program~speedy->module~shortwave_radiation module~forcing forcing program~speedy->module~forcing module~date date program~speedy->module~date module~prognostics prognostics program~speedy->module~prognostics module~initialization initialization program~speedy->module~initialization module~input_output input_output program~speedy->module~input_output module~params params program~speedy->module~params module~coupler coupler program~speedy->module~coupler module~time_stepping time_stepping program~speedy->module~time_stepping module~shortwave_radiation->module~params module~prognostics->module~params module~input_output->module~params netcdf netcdf module~input_output->netcdf module~time_stepping->module~params Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. The top-level program. Here we initialize the model and run the main loop\n until the (continually updated) model datetime ( model_datetime ) equals the\n final datetime ( end_datetime ). Calls program~~speedy~~CallsGraph program~speedy speedy proc~datetime_equal datetime_equal program~speedy->proc~datetime_equal proc~initialize initialize program~speedy->proc~initialize proc~step step program~speedy->proc~step proc~set_forcing set_forcing program~speedy->proc~set_forcing proc~newdate newdate program~speedy->proc~newdate proc~couple_sea_land couple_sea_land program~speedy->proc~couple_sea_land proc~initialize->proc~set_forcing proc~initialize_date initialize_date proc~initialize->proc~initialize_date proc~initialize_geopotential initialize_geopotential proc~initialize->proc~initialize_geopotential proc~print_speedy_title print_speedy_title proc~initialize->proc~print_speedy_title proc~first_step first_step proc~initialize->proc~first_step proc~initialize_params initialize_params proc~initialize->proc~initialize_params proc~initialize_boundaries initialize_boundaries proc~initialize->proc~initialize_boundaries proc~initialize_spectral initialize_spectral proc~initialize->proc~initialize_spectral proc~initialize_physics initialize_physics proc~initialize->proc~initialize_physics proc~initialize_geometry initialize_geometry proc~initialize->proc~initialize_geometry proc~initialize_prognostics initialize_prognostics proc~initialize->proc~initialize_prognostics proc~initialize_coupler initialize_coupler proc~initialize->proc~initialize_coupler proc~initialize_horizontal_diffusion initialize_horizontal_diffusion proc~initialize->proc~initialize_horizontal_diffusion proc~step_field_3d step_field_3d proc~step->proc~step_field_3d proc~step_field_2d step_field_2d proc~step->proc~step_field_2d interface~do_horizontal_diffusion do_horizontal_diffusion proc~step->interface~do_horizontal_diffusion proc~get_tendencies get_tendencies proc~step->proc~get_tendencies proc~get_qsat get_qsat proc~set_forcing->proc~get_qsat proc~set_orog_land_sfc_drag set_orog_land_sfc_drag proc~set_forcing->proc~set_orog_land_sfc_drag proc~radset radset proc~set_forcing->proc~radset proc~setgam setgam proc~set_forcing->proc~setgam proc~get_zonal_average_fields get_zonal_average_fields proc~set_forcing->proc~get_zonal_average_fields proc~grid_to_spec grid_to_spec proc~set_forcing->proc~grid_to_spec float float proc~newdate->float proc~couple_land_atm couple_land_atm proc~couple_sea_land->proc~couple_land_atm proc~couple_sea_atm couple_sea_atm proc~couple_sea_land->proc~couple_sea_atm proc~initialize_date->float proc~run_land_model run_land_model proc~couple_land_atm->proc~run_land_model proc~forint forint proc~couple_land_atm->proc~forint proc~forin5 forin5 proc~couple_land_atm->proc~forin5 proc~run_sea_model run_sea_model proc~couple_sea_atm->proc~run_sea_model proc~couple_sea_atm->proc~forint proc~couple_sea_atm->proc~forin5 proc~first_step->proc~step proc~initialize_implicit initialize_implicit proc~first_step->proc~initialize_implicit proc~solar solar proc~get_zonal_average_fields->proc~solar proc~spectral_truncation spectral_truncation proc~initialize_boundaries->proc~spectral_truncation interface~load_boundary_file load_boundary_file proc~initialize_boundaries->interface~load_boundary_file proc~step_field_3d->proc~step_field_2d proc~initialize_spectral->float proc~initialize_fourier initialize_fourier proc~initialize_spectral->proc~initialize_fourier proc~initialize_legendre initialize_legendre proc~initialize_spectral->proc~initialize_legendre proc~trunct trunct proc~step_field_2d->proc~trunct proc~fourier_dir fourier_dir proc~grid_to_spec->proc~fourier_dir proc~legendre_dir legendre_dir proc~grid_to_spec->proc~legendre_dir proc~initialize_from_rest_state initialize_from_rest_state proc~initialize_prognostics->proc~initialize_from_rest_state proc~initialize_coupler->proc~couple_land_atm proc~initialize_coupler->proc~couple_sea_atm proc~sea_model_init sea_model_init proc~initialize_coupler->proc~sea_model_init proc~land_model_init land_model_init proc~initialize_coupler->proc~land_model_init proc~initialize_horizontal_diffusion->float proc~do_horizontal_diffusion_3d do_horizontal_diffusion_3d interface~do_horizontal_diffusion->proc~do_horizontal_diffusion_3d proc~do_horizontal_diffusion_2d do_horizontal_diffusion_2d interface~do_horizontal_diffusion->proc~do_horizontal_diffusion_2d proc~get_grid_point_tendencies get_grid_point_tendencies proc~get_tendencies->proc~get_grid_point_tendencies proc~implicit_terms implicit_terms proc~get_tendencies->proc~implicit_terms proc~get_spectral_tendencies get_spectral_tendencies proc~get_tendencies->proc~get_spectral_tendencies proc~get_grid_point_tendencies->proc~grid_to_spec proc~laplacian laplacian proc~get_grid_point_tendencies->proc~laplacian proc~get_geopotential get_geopotential proc~get_grid_point_tendencies->proc~get_geopotential proc~spec_to_grid spec_to_grid proc~get_grid_point_tendencies->proc~spec_to_grid proc~initialize_implicit->float proc~spectral_truncation->proc~grid_to_spec proc~spectral_truncation->proc~spec_to_grid proc~do_horizontal_diffusion_3d->proc~do_horizontal_diffusion_2d proc~fourier_dir->float proc~rfftf1 rfftf1 proc~fourier_dir->proc~rfftf1 proc~sea_model_init->interface~load_boundary_file proc~forchk forchk proc~sea_model_init->proc~forchk proc~rffti1 rffti1 proc~initialize_fourier->proc~rffti1 proc~initialize_from_rest_state->proc~grid_to_spec proc~output output proc~initialize_from_rest_state->proc~output proc~load_boundary_file_one_month_from_long load_boundary_file_one_month_from_long interface~load_boundary_file->proc~load_boundary_file_one_month_from_long proc~load_boundary_file_2d load_boundary_file_2d interface~load_boundary_file->proc~load_boundary_file_2d proc~load_boundary_file_one_month_from_year load_boundary_file_one_month_from_year interface~load_boundary_file->proc~load_boundary_file_one_month_from_year proc~get_spectral_tendencies->proc~laplacian proc~get_spectral_tendencies->proc~get_geopotential proc~initialize_legendre->float proc~get_weights get_weights proc~initialize_legendre->proc~get_weights proc~get_legendre_poly get_legendre_poly proc~initialize_legendre->proc~get_legendre_poly proc~land_model_init->interface~load_boundary_file proc~land_model_init->proc~forchk nf90_inq_varid nf90_inq_varid proc~load_boundary_file_one_month_from_long->nf90_inq_varid nf90_close nf90_close proc~load_boundary_file_one_month_from_long->nf90_close nf90_open nf90_open proc~load_boundary_file_one_month_from_long->nf90_open nf90_get_var nf90_get_var proc~load_boundary_file_one_month_from_long->nf90_get_var proc~load_boundary_file_2d->nf90_inq_varid proc~load_boundary_file_2d->nf90_close proc~load_boundary_file_2d->nf90_open proc~load_boundary_file_2d->nf90_get_var proc~get_legendre_poly->float proc~load_boundary_file_one_month_from_year->nf90_inq_varid proc~load_boundary_file_one_month_from_year->nf90_close proc~load_boundary_file_one_month_from_year->nf90_open proc~load_boundary_file_one_month_from_year->nf90_get_var proc~output->proc~spec_to_grid nf90_enddef nf90_enddef proc~output->nf90_enddef proc~output->nf90_close nf90_create nf90_create proc~output->nf90_create nf90_put_att nf90_put_att proc~output->nf90_put_att nf90_def_dim nf90_def_dim proc~output->nf90_def_dim nf90_put_var nf90_put_var proc~output->nf90_put_var nf90_def_var nf90_def_var proc~output->nf90_def_var proc~legendre_inv legendre_inv proc~spec_to_grid->proc~legendre_inv proc~fourier_inv fourier_inv proc~spec_to_grid->proc~fourier_inv proc~rfftb1 rfftb1 proc~fourier_inv->proc~rfftb1 var panprogramspeedyCallsGraph = svgPanZoom('#programspeedyCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables model_step Variables Type Attributes Name Initial integer :: model_step = 1","tags":"","loc":"program/speedy.html"}]}